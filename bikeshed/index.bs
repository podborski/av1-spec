<pre class='metadata'>
Title: AV1 Bitstream &amp; Decoding Process Specification (bikeshed experiment)
Status: PD
URL: https://aomediacodec.github.io/av1-spec/
Shortname: av1-spec
Editor: Peter de Rivaz, Argon Design Ltd  
Editor: Jack Haughton, Argon Design Ltd
Editor: Adrian Grange, Google LLC
Editor: Lou Quillio, Google LLC
Abstract: This document defines the bitstream formats and decoding process for the <a href="https://aomedia.org">Alliance for Open Media</a> AV1 video codec.
Date: 2024-03-01
Repository: AOMediaCodec/av1-spec
Group: AOM
!Latest approved version: <a href="https://aomediacodec.github.io/av1-spec/av1-spec.pdf">https://aomediacodec.github.io/av1-spec/av1-spec.pdf</a>
Metadata Order: This version, !*, *
Markup Shorthands: markdown yes
Local Boilerplate: footer yes
</pre>


# Scope # {#scope}

This document specifies the Alliance for Open Media AV1 bitstream formats and
decoding process.

# Terms and definitions # {#terms_and_definitions}

For the purposes of this document, the following terms and definitions apply:

<dfn>AC coefficient</dfn>

Any transform coefficient whose frequency indices are non-zero in at least one dimension.

<dfn>Altref</dfn>

(Alternative reference frame) A frame that can be used in inter coding.

<dfn>Base layer</dfn>

The layer with spatial_id and temporal_id values equal to 0.

<dfn>Bitstream</dfn>

The sequence of bits generated by encoding a sequence of frames.

<dfn>Bit string</dfn>

An ordered string with limited number of bits. The left most bit is the most significant bit (MSB), the right most bit is the least significant bit (LSB).

<dfn>Block</dfn>

A square or rectangular region of samples.

<dfn>Block scan</dfn>

A specified serial ordering of quantized coefficients.

<dfn>Byte</dfn>

An 8-bit bit string.

<dfn>Byte alignment</dfn>

One bit is byte aligned if the position of the bit is an integer multiple of eight from the position of the first bit in the bitstream.

<dfn>CDEF</dfn>

Constrained Directional Enhancement Filter designed to adaptively filter blocks based on identifying the direction.

<dfn>CDF</dfn>

Cumulative distribution function representing the probability times 32768 that a symbol has value less than or equal to a given level.

<dfn>Chroma</dfn>

A sample value matrix or a single sample value of one of the two color difference signals.  

NOTE: Symbols of chroma are U and V. 

<dfn>Coded frame</dfn>

The representation of one frame before the decoding process.

<dfn>Component</dfn>

One of the three sample value matrices (one luma matrix and two chroma matrices) or its single sample value.

<dfn>Compound prediction</dfn>

A type of inter prediction where sample values are computed by blending together predictions from two reference frames (the frames blended can be the same or different).

<dfn>DC coefficient</dfn>

A transform coefficient whose frequency indices are zero in both dimensions.

<dfn>Decoded frame</dfn>

The frame reconstructed out of the bitstream by the decoder.

<dfn>Decoder</dfn>

One embodiment of the decoding process.

<dfn>Decoding process</dfn>

The process that derives decoded frames from syntax elements, including any processing  steps used prior to and for the film grain synthesis process.

<dfn>Dequantization</dfn>

The process in which transform coefficients are obtained by scaling the quantized coefficients.

<dfn>Encoder</dfn>

One embodiment of the encoding process.

<dfn>Encoding process</dfn>

A process not specified in this Specification that generates the bitstream that conforms to the description provided in this document.

<dfn>Enhancement layer</dfn>

A layer with either spatial_id greater than 0 or temporal_id greater than 0.

<dfn>Flag</dfn>

A binary variable - some variables and syntax elements (e.g. obu_extension_flag) are described using the word flag to highlight that the syntax element can only be equal to 0 or equal to 1.

<dfn>Frame</dfn>

The representation of video signals in the spatial domain, composed of one luma sample matrix (Y) and two chroma sample matrices (U and V).

<dfn>Frame context</dfn>

A set of probabilities used in the decoding process.

<dfn>Golden frame</dfn>

A frame that can be used in inter coding. Typically the golden frame is encoded with higher quality and is used as a reference for multiple inter frames.

<dfn>Inter coding</dfn>

Coding one block or frame using inter prediction.

<dfn>Inter frame</dfn>

A frame compressed by referencing previously decoded frames and which may use intra prediction or inter prediction.

<dfn>Inter prediction</dfn>

The process of deriving the prediction value for the current frame using previously decoded frames.

<dfn>Intra coding</dfn>

Coding one block or frame using intra prediction.

<dfn>Intra frame</dfn>

A frame compressed using only intra prediction which can be independently decoded.

<dfn>Intra prediction</dfn>

The process of deriving the prediction value for the current sample using previously decoded sample values in the same decoded frame.

<dfn>Inverse transform</dfn>

The process in which a transform coefficient matrix is transformed into a spatial sample value matrix.

<dfn>Key frame</dfn>

An Intra frame which resets the decoding process when it is shown.

<dfn>Layer</dfn>

A set of tile group OBUs with identical spatial_id and identical temporal_id values.

<dfn>Level</dfn>

A defined set of constraints on the values for the syntax elements and variables.

<dfn>Loop filter</dfn>

A filtering process applied to the reconstruction intended to reduce the visibility of block edges.

<dfn>Luma</dfn>

A sample value matrix or a single sample value representing the monochrome signal related to the primary colors.  

NOTE: The symbol representing luma is Y. 

<dfn>Mode info</dfn>

Syntax elements sent for a block containing an indication of how a block is to be predicted during the decoding process.

<dfn>Mode info block</dfn>

A luma sample value block of size 4x4 or larger and its two corresponding chroma sample value blocks (if present).

<dfn>Motion vector</dfn>

A two-dimensional vector used for inter prediction which refers the current frame to the reference frame, the value of which provides the coordinate offsets from a location in the current frame to a location in the reference frame.

<dfn>OBU</dfn>

All structures are packetized in "Open Bitstream Units" or OBUs. Each OBU has a header, which provides identifying information for the contained data (payload).

<dfn>Parse</dfn>

The procedure of getting the syntax element from the bitstream.

<dfn>Prediction</dfn>

The implementation of the prediction process consisting of either inter or intra prediction.

<dfn>Prediction process</dfn>

The process of estimating the decoded sample value or data element using a predictor.

<dfn>Prediction value</dfn>

The value, which is the combination of the previously decoded sample values or data elements, used in the decoding process of the next sample value or data element.

<dfn>Profile</dfn>

A subset of syntax, semantics and algorithms defined in a part.

<dfn>Quantization parameter</dfn>

A variable used for scaling the quantized coefficients in the decoding process.

<dfn>Quantized coefficient</dfn>

A transform coefficient before dequantization.

<dfn>Raster scan</dfn>

Maps a two dimensional rectangular raster into a one dimensional raster, in which the entry of the one dimensional raster starts from the first row of the two dimensional raster, and the scanning then goes through the second row and the third row, and so on. Each raster row is scanned in left to right order.

<dfn>Reconstruction</dfn>

Obtaining the addition of the decoded residual and the corresponding prediction values.

<dfn>Reference</dfn>

One of a set of tags, each of which is mapped to a reference frame.

<dfn>Reference frame</dfn>

A storage area for a previously decoded frame and associated information.

<dfn>Reserved</dfn>

A special syntax element value which may be used to extend this part in the future.

<dfn>Residual</dfn>

The differences between the reconstructed samples and the corresponding prediction values.

<dfn>Sample</dfn>

The basic elements that compose the frame.

<dfn>Sample value</dfn>

The value of a sample. This is an integer from 0 to 255 (inclusive) for 8-bit frames, from 0 to 1023 (inclusive) for 10-bit frames, and from 0 to 4095 (inclusive) for 12-bit frames.

<dfn>Segmentation map</dfn>

One 3-bit number per 4x4 block in the frame specifying the segment affiliation of that block. A segmentation map is stored for each reference frame to allow new frames to use a previously coded map.

<dfn>Sequence</dfn>

The highest level syntax structure of coding bitstream, including one or several consecutive coded frames.

<dfn>Superblock</dfn>

The top level of the block quadtree within a tile. All superblocks within a frame are the same size and are square. The superblocks may be 128x128 luma samples or 64x64 luma samples. A superblock may contain 1 or 2 or 4 mode info blocks, or may be bisected in each direction to create 4 sub-blocks, which may themselves be further subpartitioned, forming the block quadtree.

<dfn>Switch Frame</dfn>

An inter frame that can be used as a point to switch between sequences. Switch frames overwrite all the reference frames without forcing the use of intra coding.  The intention is to allow a streaming use case where videos can be encoded in small chunks (say of 1 second duration), each starting with a switch frame.  If the available bandwidth drops, the server can start sending chunks from a lower bitrate encoding instead. When this happens the inter prediction uses the existing higher quality reference frames to decode the switch frame.  This approach allows a bitrate switch without the cost of a full key frame.

<dfn>Syntax element</dfn>

An element of data represented in the bitstream.

<dfn>Temporal delimiter OBU</dfn>

An indication that the following OBUs will have a different presentation/decoding time stamp from the one of the last frame prior to the temporal delimiter.

<dfn>Temporal unit</dfn>

A Temporal unit consists of all the OBUs that are associated with a specific, distinct time instant. It consists of a temporal delimiter OBU, and all the OBUs that follow, up to but not including the next temporal delimiter.

<dfn>Temporal group</dfn>

A set of frames whose temporal prediction structure is used periodically in a video sequence.

<dfn>Tier</dfn>

A specified category of level constraints imposed on the values of the syntax elements in the bitstream.

<dfn>Tile</dfn>

A rectangular region of the frame that can be decoded and encoded independently, although loop-filtering across tile edges is still applied.

<dfn>Transform block</dfn>

A rectangular transform coefficient matrix, used as input to the inverse transform process.

<dfn>Transform coefficient</dfn>

A scalar value, considered to be in a frequency domain, contained in a transform block.

<dfn>Uncompressed header</dfn>

High level description of the frame to be decoded that is encoded without the use of arithmetic encoding.


# Symbols and abbreviated terms # {#symbols_and_abbreviated_terms}

DCT

: Discrete Cosine Transform

ADST

: Asymmetric Discrete Sine Transform

LSB

: Least Significant Bit

MSB

: Most Significant Bit

WHT

: Walsh Hadamard Transform

The specification makes use of a number of constant integers.  Constants that
relate to the semantics of a particular syntax element are defined in
[section 6][].

Additional constants are defined below:

<table class="table table-sm table-bordered table-striped">
  <thead>
    <tr>
      <th>Symbol name</th>
      <th style="text-align: center">Value</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code >REFS_PER_FRAME</code></td>
      <td style="text-align: center">7</td>
      <td>Number of reference frames that can be used for inter prediction</td>
    </tr>
    <tr>
      <td><code >TOTAL_REFS_PER_FRAME</code></td>
      <td style="text-align: center">8</td>
      <td>Number of reference frame types (including intra type)</td>
    </tr>
    <tr>
      <td><code >BLOCK_SIZE_GROUPS</code></td>
      <td style="text-align: center">4</td>
      <td>Number of contexts when decoding <code >y_mode</code></td>
    </tr>
    <tr>
      <td><code >BLOCK_SIZES</code></td>
      <td style="text-align: center">22</td>
      <td>Number of different block sizes used</td>
    </tr>
    <tr>
      <td><code >BLOCK_INVALID</code></td>
      <td style="text-align: center">22</td>
      <td>Sentinel value to mark partition choices that are not allowed</td>
    </tr>
    <tr>
      <td><code >MAX_SB_SIZE</code></td>
      <td style="text-align: center">128</td>
      <td>Maximum size of a superblock in luma samples</td>
    </tr>
    <tr>
      <td><code >MI_SIZE</code></td>
      <td style="text-align: center">4</td>
      <td>Smallest size of a mode info block in luma samples</td>
    </tr>
    <tr>
      <td><code >MI_SIZE_LOG2</code></td>
      <td style="text-align: center">2</td>
      <td>Base 2 logarithm of smallest size of a mode info block</td>
    </tr>
    <tr>
      <td><code >MAX_TILE_WIDTH</code></td>
      <td style="text-align: center">4096</td>
      <td>Maximum width of a tile in units of luma samples</td>
    </tr>
    <tr>
      <td><code >MAX_TILE_AREA</code></td>
      <td style="text-align: center">4096 * 2304</td>
      <td>Maximum area of a tile in units of luma samples</td>
    </tr>
    <tr>
      <td><code >MAX_TILE_ROWS</code></td>
      <td style="text-align: center">64</td>
      <td>Maximum number of tile rows</td>
    </tr>
    <tr>
      <td><code >MAX_TILE_COLS</code></td>
      <td style="text-align: center">64</td>
      <td>Maximum number of tile columns</td>
    </tr>
    <tr>
      <td><code >INTRABC_DELAY_PIXELS</code></td>
      <td style="text-align: center">256</td>
      <td>Number of horizontal luma samples before intra block copy can be used</td>
    </tr>
    <tr>
      <td><code >INTRABC_DELAY_SB64</code></td>
      <td style="text-align: center">4</td>
      <td>Number of 64 by 64 blocks before intra block copy can be used</td>
    </tr>
    <tr>
      <td><code >NUM_REF_FRAMES</code></td>
      <td style="text-align: center">8</td>
      <td>Number of frames that can be stored for future reference</td>
    </tr>
    <tr>
      <td><code >IS_INTER_CONTEXTS</code></td>
      <td style="text-align: center">4</td>
      <td>Number of contexts for <code >is_inter</code></td>
    </tr>
    <tr>
      <td><code >REF_CONTEXTS</code></td>
      <td style="text-align: center">3</td>
      <td>Number of contexts for <code >single_ref</code>, <code >comp_ref</code>, <code >comp_bwdref</code>, <code >uni_comp_ref</code>, <code >uni_comp_ref_p1</code> and <code >uni_comp_ref_p2</code></td>
    </tr>
    <tr>
      <td><code >MAX_SEGMENTS</code></td>
      <td style="text-align: center">8</td>
      <td>Number of segments allowed in segmentation map</td>
    </tr>
    <tr>
      <td><code >SEGMENT_ID_CONTEXTS</code></td>
      <td style="text-align: center">3</td>
      <td>Number of contexts for <code >segment_id</code></td>
    </tr>
    <tr>
      <td><code >SEG_LVL_ALT_Q</code></td>
      <td style="text-align: center">0</td>
      <td>Index for quantizer segment feature</td>
    </tr>
    <tr>
      <td><code >SEG_LVL_ALT_LF_Y_V</code></td>
      <td style="text-align: center">1</td>
      <td>Index for vertical luma loop filter segment feature</td>
    </tr>
    <tr>
      <td><code >SEG_LVL_REF_FRAME</code></td>
      <td style="text-align: center">5</td>
      <td>Index for reference frame segment feature</td>
    </tr>
    <tr>
      <td><code >SEG_LVL_SKIP</code></td>
      <td style="text-align: center">6</td>
      <td>Index for skip segment feature</td>
    </tr>
    <tr>
      <td><code >SEG_LVL_GLOBALMV</code></td>
      <td style="text-align: center">7</td>
      <td>Index for global mv feature</td>
    </tr>
    <tr>
      <td><code >SEG_LVL_MAX</code></td>
      <td style="text-align: center">8</td>
      <td>Number of segment features</td>
    </tr>
    <tr>
      <td><code >PLANE_TYPES</code></td>
      <td style="text-align: center">2</td>
      <td>Number of different plane types (luma or chroma)</td>
    </tr>
    <tr>
      <td><code >TX_SIZE_CONTEXTS</code></td>
      <td style="text-align: center">3</td>
      <td>Number of contexts for transform size</td>
    </tr>
    <tr>
      <td><code >INTERP_FILTERS</code></td>
      <td style="text-align: center">3</td>
      <td>Number of values for <code >interp_filter</code></td>
    </tr>
    <tr>
      <td><code >INTERP_FILTER_CONTEXTS</code></td>
      <td style="text-align: center">16</td>
      <td>Number of contexts for <code >interp_filter</code></td>
    </tr>
    <tr>
      <td><code >SKIP_MODE_CONTEXTS</code></td>
      <td style="text-align: center">3</td>
      <td>Number of contexts for decoding skip_mode</td>
    </tr>
    <tr>
      <td><code >SKIP_CONTEXTS</code></td>
      <td style="text-align: center">3</td>
      <td>Number of contexts for decoding skip</td>
    </tr>
    <tr>
      <td><code >PARTITION_CONTEXTS</code></td>
      <td style="text-align: center">4</td>
      <td>Number of contexts when decoding <code >partition</code></td>
    </tr>
    <tr>
      <td><code >TX_SIZES</code></td>
      <td style="text-align: center">5</td>
      <td>Number of square transform sizes</td>
    </tr>
    <tr>
      <td><code >TX_SIZES_ALL</code></td>
      <td style="text-align: center">19</td>
      <td>Number of transform sizes (including non-square sizes)</td>
    </tr>
    <tr>
      <td><code >TX_MODES</code></td>
      <td style="text-align: center">3</td>
      <td>Number of values for <code >tx_mode</code></td>
    </tr>
    <tr>
      <td><code >DCT_DCT</code></td>
      <td style="text-align: center">0</td>
      <td>Inverse transform rows with <code >DCT</code> and columns with <code >DCT</code></td>
    </tr>
    <tr>
      <td><code >ADST_DCT</code></td>
      <td style="text-align: center">1</td>
      <td>Inverse transform rows with <code >DCT</code> and columns with <code >ADST</code></td>
    </tr>
    <tr>
      <td><code >DCT_ADST</code></td>
      <td style="text-align: center">2</td>
      <td>Inverse transform rows with <code >ADST</code> and columns with <code >DCT</code></td>
    </tr>
    <tr>
      <td><code >ADST_ADST</code></td>
      <td style="text-align: center">3</td>
      <td>Inverse transform rows with <code >ADST</code> and columns with <code >ADST</code></td>
    </tr>
    <tr>
      <td><code >FLIPADST_DCT</code></td>
      <td style="text-align: center">4</td>
      <td>Inverse transform rows with <code >DCT</code> and columns with <code >FLIPADST</code></td>
    </tr>
    <tr>
      <td><code >DCT_FLIPADST</code></td>
      <td style="text-align: center">5</td>
      <td>Inverse transform rows with <code >FLIPADST</code> and columns with <code >DCT</code></td>
    </tr>
    <tr>
      <td><code >FLIPADST_FLIPADST</code></td>
      <td style="text-align: center">6</td>
      <td>Inverse transform rows with <code >FLIPADST</code> and columns with <code >FLIPADST</code></td>
    </tr>
    <tr>
      <td><code >ADST_FLIPADST</code></td>
      <td style="text-align: center">7</td>
      <td>Inverse transform rows with <code >FLIPADST</code> and columns with <code >ADST</code></td>
    </tr>
    <tr>
      <td><code >FLIPADST_ADST</code></td>
      <td style="text-align: center">8</td>
      <td>Inverse transform rows with <code >ADST</code> and columns with <code >FLIPADST</code></td>
    </tr>
    <tr>
      <td><code >IDTX</code></td>
      <td style="text-align: center">9</td>
      <td>Inverse transform rows with identity and columns with identity</td>
    </tr>
    <tr>
      <td><code >V_DCT</code></td>
      <td style="text-align: center">10</td>
      <td>Inverse transform rows with identity and columns with <code >DCT</code></td>
    </tr>
    <tr>
      <td><code >H_DCT</code></td>
      <td style="text-align: center">11</td>
      <td>Inverse transform rows with <code >DCT</code> and columns with identity</td>
    </tr>
    <tr>
      <td><code >V_ADST</code></td>
      <td style="text-align: center">12</td>
      <td>Inverse transform rows with identity and columns with <code >ADST</code></td>
    </tr>
    <tr>
      <td><code >H_ADST</code></td>
      <td style="text-align: center">13</td>
      <td>Inverse transform rows with <code >ADST</code> and columns with identity</td>
    </tr>
    <tr>
      <td><code >V_FLIPADST</code></td>
      <td style="text-align: center">14</td>
      <td>Inverse transform rows with identity and columns with <code >FLIPADST</code></td>
    </tr>
    <tr>
      <td><code >H_FLIPADST</code></td>
      <td style="text-align: center">15</td>
      <td>Inverse transform rows with <code >FLIPADST</code> and columns with identity</td>
    </tr>
    <tr>
      <td><code >TX_TYPES</code></td>
      <td style="text-align: center">16</td>
      <td>Number of inverse transform types</td>
    </tr>
    <tr>
      <td><code >MB_MODE_COUNT</code></td>
      <td style="text-align: center">17</td>
      <td>Number of values for <code >YMode</code></td>
    </tr>
    <tr>
      <td><code >INTRA_MODES</code></td>
      <td style="text-align: center">13</td>
      <td>Number of values for <code >y_mode</code></td>
    </tr>
    <tr>
      <td><code >UV_INTRA_MODES_CFL_NOT_ALLOWED</code></td>
      <td style="text-align: center">13</td>
      <td>Number of values for <code >uv_mode</code> when chroma from luma is not allowed</td>
    </tr>
    <tr>
      <td><code >UV_INTRA_MODES_CFL_ALLOWED</code></td>
      <td style="text-align: center">14</td>
      <td>Number of values for <code >uv_mode</code> when chroma from luma is allowed</td>
    </tr>
    <tr>
      <td><code >COMPOUND_MODES</code></td>
      <td style="text-align: center">8</td>
      <td>Number of values for <code >compound_mode</code></td>
    </tr>
    <tr>
      <td><code >COMPOUND_MODE_CONTEXTS</code></td>
      <td style="text-align: center">8</td>
      <td>Number of contexts for <code >compound_mode</code></td>
    </tr>
    <tr>
      <td><code >COMP_NEWMV_CTXS</code></td>
      <td style="text-align: center">5</td>
      <td>Number of new mv values used when constructing context for <code >compound_mode</code></td>
    </tr>
    <tr>
      <td><code >NEW_MV_CONTEXTS</code></td>
      <td style="text-align: center">6</td>
      <td>Number of contexts for <code >new_mv</code></td>
    </tr>
    <tr>
      <td><code >ZERO_MV_CONTEXTS</code></td>
      <td style="text-align: center">2</td>
      <td>Number of contexts for <code >zero_mv</code></td>
    </tr>
    <tr>
      <td><code >REF_MV_CONTEXTS</code></td>
      <td style="text-align: center">6</td>
      <td>Number of contexts for <code >ref_mv</code></td>
    </tr>
    <tr>
      <td><code >DRL_MODE_CONTEXTS</code></td>
      <td style="text-align: center">3</td>
      <td>Number of contexts for <code >drl_mode</code></td>
    </tr>
    <tr>
      <td><code >MV_CONTEXTS</code></td>
      <td style="text-align: center">2</td>
      <td>Number of contexts for decoding motion vectors including one for intra block copy</td>
    </tr>
    <tr>
      <td><code >MV_INTRABC_CONTEXT</code></td>
      <td style="text-align: center">1</td>
      <td>Motion vector context used for intra block copy</td>
    </tr>
    <tr>
      <td><code >MV_JOINTS</code></td>
      <td style="text-align: center">4</td>
      <td>Number of values for <code >mv_joint</code></td>
    </tr>
    <tr>
      <td><code >MV_CLASSES</code></td>
      <td style="text-align: center">11</td>
      <td>Number of values for <code >mv_class</code></td>
    </tr>
    <tr>
      <td><code >CLASS0_SIZE</code></td>
      <td style="text-align: center">2</td>
      <td>Number of values for <code >mv_class0_bit</code></td>
    </tr>
    <tr>
      <td><code >MV_OFFSET_BITS</code></td>
      <td style="text-align: center">10</td>
      <td>Maximum number of bits for decoding motion vectors</td>
    </tr>
    <tr>
      <td><code >MAX_LOOP_FILTER</code></td>
      <td style="text-align: center">63</td>
      <td>Maximum value used for loop filtering</td>
    </tr>
    <tr>
      <td><code >REF_SCALE_SHIFT</code></td>
      <td style="text-align: center">14</td>
      <td>Number of bits of precision when scaling reference frames</td>
    </tr>
    <tr>
      <td><code >SUBPEL_BITS</code></td>
      <td style="text-align: center">4</td>
      <td>Number of bits of precision when choosing an inter prediction filter kernel</td>
    </tr>
    <tr>
      <td><code >SUBPEL_MASK</code></td>
      <td style="text-align: center">15</td>
      <td><code >( 1 &lt;&lt; SUBPEL_BITS ) - 1</code></td>
    </tr>
    <tr>
      <td><code >SCALE_SUBPEL_BITS</code></td>
      <td style="text-align: center">10</td>
      <td>Number of bits of precision when computing inter prediction locations</td>
    </tr>
    <tr>
      <td><code >MV_BORDER</code></td>
      <td style="text-align: center">128</td>
      <td>Value used when clipping motion vectors</td>
    </tr>
    <tr>
      <td><code >PALETTE_COLOR_CONTEXTS</code></td>
      <td style="text-align: center">5</td>
      <td>Number of values for color contexts</td>
    </tr>
    <tr>
      <td><code >PALETTE_MAX_COLOR_CONTEXT_HASH</code></td>
      <td style="text-align: center">8</td>
      <td>Number of mappings between color context hash and color context</td>
    </tr>
    <tr>
      <td><code >PALETTE_BLOCK_SIZE_CONTEXTS</code></td>
      <td style="text-align: center">7</td>
      <td>Number of values for palette block size</td>
    </tr>
    <tr>
      <td><code >PALETTE_Y_MODE_CONTEXTS</code></td>
      <td style="text-align: center">3</td>
      <td>Number of values for palette Y plane mode contexts</td>
    </tr>
    <tr>
      <td><code >PALETTE_UV_MODE_CONTEXTS</code></td>
      <td style="text-align: center">2</td>
      <td>Number of values for palette U and V plane mode contexts</td>
    </tr>
    <tr>
      <td><code >PALETTE_SIZES</code></td>
      <td style="text-align: center">7</td>
      <td>Number of values for palette_size</td>
    </tr>
    <tr>
      <td><code >PALETTE_COLORS</code></td>
      <td style="text-align: center">8</td>
      <td>Number of values for palette_color</td>
    </tr>
    <tr>
      <td><code >PALETTE_NUM_NEIGHBORS</code></td>
      <td style="text-align: center">3</td>
      <td>Number of neighbors considered within palette computation</td>
    </tr>
    <tr>
      <td><code >DELTA_Q_SMALL</code></td>
      <td style="text-align: center">3</td>
      <td>Value indicating alternative encoding of quantizer index delta values</td>
    </tr>
    <tr>
      <td><code >DELTA_LF_SMALL</code></td>
      <td style="text-align: center">3</td>
      <td>Value indicating alternative encoding of loop filter delta values</td>
    </tr>
    <tr>
      <td><code >QM_TOTAL_SIZE</code></td>
      <td style="text-align: center">3344</td>
      <td>Number of values in the quantizer matrix</td>
    </tr>
    <tr>
      <td><code >MAX_ANGLE_DELTA</code></td>
      <td style="text-align: center">3</td>
      <td>Maximum magnitude of AngleDeltaY and AngleDeltaUV</td>
    </tr>
    <tr>
      <td><code >DIRECTIONAL_MODES</code></td>
      <td style="text-align: center">8</td>
      <td>Number of directional intra modes</td>
    </tr>
    <tr>
      <td><code >ANGLE_STEP</code></td>
      <td style="text-align: center">3</td>
      <td>Number of degrees of step per unit increase in AngleDeltaY or AngleDeltaUV.</td>
    </tr>
    <tr>
      <td><code >TX_SET_TYPES_INTRA</code></td>
      <td style="text-align: center">3</td>
      <td>Number of intra transform set types</td>
    </tr>
    <tr>
      <td><code >TX_SET_TYPES_INTER</code></td>
      <td style="text-align: center">4</td>
      <td>Number of inter transform set types</td>
    </tr>
    <tr>
      <td><code >WARPEDMODEL_PREC_BITS</code></td>
      <td style="text-align: center">16</td>
      <td>Internal precision of warped motion models</td>
    </tr>
    <tr>
      <td><code >IDENTITY</code></td>
      <td style="text-align: center">0</td>
      <td>Warp model is just an identity transform</td>
    </tr>
    <tr>
      <td><code >TRANSLATION</code></td>
      <td style="text-align: center">1</td>
      <td>Warp model is a pure translation</td>
    </tr>
    <tr>
      <td><code >ROTZOOM</code></td>
      <td style="text-align: center">2</td>
      <td>Warp model is a rotation + symmetric zoom + translation</td>
    </tr>
    <tr>
      <td><code >AFFINE</code></td>
      <td style="text-align: center">3</td>
      <td>Warp model is a general affine transform</td>
    </tr>
    <tr>
      <td><code >GM_ABS_TRANS_BITS</code></td>
      <td style="text-align: center">12</td>
      <td>Number of bits encoded for translational components of global motion models, if part of a ROTZOOM or AFFINE model</td>
    </tr>
    <tr>
      <td><code >GM_ABS_TRANS_ONLY_BITS</code></td>
      <td style="text-align: center">9</td>
      <td>Number of bits encoded for translational components of global motion models, if part of a TRANSLATION model</td>
    </tr>
    <tr>
      <td><code >GM_ABS_ALPHA_BITS</code></td>
      <td style="text-align: center">12</td>
      <td>Number of bits encoded for non-translational components of global motion models</td>
    </tr>
    <tr>
      <td><code >DIV_LUT_PREC_BITS</code></td>
      <td style="text-align: center">14</td>
      <td>Number of fractional bits of entries in divisor lookup table</td>
    </tr>
    <tr>
      <td><code >DIV_LUT_BITS</code></td>
      <td style="text-align: center">8</td>
      <td>Number of fractional bits for lookup in divisor lookup table</td>
    </tr>
    <tr>
      <td><code >DIV_LUT_NUM</code></td>
      <td style="text-align: center">257</td>
      <td>Number of entries in divisor lookup table</td>
    </tr>
    <tr>
      <td><code >MOTION_MODES</code></td>
      <td style="text-align: center">3</td>
      <td>Number of values for motion modes</td>
    </tr>
    <tr>
      <td><code >SIMPLE</code></td>
      <td style="text-align: center">0</td>
      <td>Use translation or global motion compensation</td>
    </tr>
    <tr>
      <td><code >OBMC</code></td>
      <td style="text-align: center">1</td>
      <td>Use overlapped block motion compensation</td>
    </tr>
    <tr>
      <td><code >LOCALWARP</code></td>
      <td style="text-align: center">2</td>
      <td>Use local warp motion compensation</td>
    </tr>
    <tr>
      <td><code >LEAST_SQUARES_SAMPLES_MAX</code></td>
      <td style="text-align: center">8</td>
      <td>Largest number of samples used when computing a local warp</td>
    </tr>
    <tr>
      <td><code >LS_MV_MAX</code></td>
      <td style="text-align: center">256</td>
      <td>Largest motion vector difference to include in local warp computation</td>
    </tr>
    <tr>
      <td><code >WARPEDMODEL_TRANS_CLAMP</code></td>
      <td style="text-align: center">1&lt;&lt;23</td>
      <td>Clamping value used for translation components of warp</td>
    </tr>
    <tr>
      <td><code >WARPEDMODEL_NONDIAGAFFINE_CLAMP</code></td>
      <td style="text-align: center">1&lt;&lt;13</td>
      <td>Clamping value used for matrix components of warp</td>
    </tr>
    <tr>
      <td><code >WARPEDPIXEL_PREC_SHIFTS</code></td>
      <td style="text-align: center">1&lt;&lt;6</td>
      <td>Number of phases used in warped filtering</td>
    </tr>
    <tr>
      <td><code >WARPEDDIFF_PREC_BITS</code></td>
      <td style="text-align: center">10</td>
      <td>Number of extra bits of precision in warped filtering</td>
    </tr>
    <tr>
      <td><code >GM_ALPHA_PREC_BITS</code></td>
      <td style="text-align: center">15</td>
      <td>Number of fractional bits for sending non-translational warp model coefficients</td>
    </tr>
    <tr>
      <td><code >GM_TRANS_PREC_BITS</code></td>
      <td style="text-align: center">6</td>
      <td>Number of fractional bits for sending translational warp model coefficients</td>
    </tr>
    <tr>
      <td><code >GM_TRANS_ONLY_PREC_BITS</code></td>
      <td style="text-align: center">3</td>
      <td>Number of fractional bits used for pure translational warps</td>
    </tr>
    <tr>
      <td><code >INTERINTRA_MODES</code></td>
      <td style="text-align: center">4</td>
      <td>Number of inter intra modes</td>
    </tr>
    <tr>
      <td><code >MASK_MASTER_SIZE</code></td>
      <td style="text-align: center">64</td>
      <td>Size of MasterMask array</td>
    </tr>
    <tr>
      <td><code >SEGMENT_ID_PREDICTED_CONTEXTS</code></td>
      <td style="text-align: center">3</td>
      <td>Number of contexts for <code >segment_id_predicted</code></td>
    </tr>
    <tr>
      <td><code >IS_INTER_CONTEXTS</code></td>
      <td style="text-align: center">4</td>
      <td>Number of contexts for <code >is_inter</code></td>
    </tr>
    <tr>
      <td><code >FWD_REFS</code></td>
      <td style="text-align: center">4</td>
      <td>Number of syntax elements for forward reference frames</td>
    </tr>
    <tr>
      <td><code >BWD_REFS</code></td>
      <td style="text-align: center">3</td>
      <td>Number of syntax elements for backward reference frames</td>
    </tr>
    <tr>
      <td><code >SINGLE_REFS</code></td>
      <td style="text-align: center">7</td>
      <td>Number of syntax elements for single reference frames</td>
    </tr>
    <tr>
      <td><code >UNIDIR_COMP_REFS</code></td>
      <td style="text-align: center">4</td>
      <td>Number of syntax elements for unidirectional compound reference frames</td>
    </tr>
    <tr>
      <td><code >COMPOUND_TYPES</code></td>
      <td style="text-align: center">2</td>
      <td>Number of values for <code >compound_type</code></td>
    </tr>
    <tr>
      <td><code >CFL_JOINT_SIGNS</code></td>
      <td style="text-align: center">8</td>
      <td>Number of values for <code >cfl_alpha_signs</code></td>
    </tr>
    <tr>
      <td><code >CFL_ALPHABET_SIZE</code></td>
      <td style="text-align: center">16</td>
      <td>Number of values for <code >cfl_alpha_u</code> and <code >cfl_alpha_v</code></td>
    </tr>
    <tr>
      <td><code >COMP_INTER_CONTEXTS</code></td>
      <td style="text-align: center">5</td>
      <td>Number of contexts for <code >comp_mode</code></td>
    </tr>
    <tr>
      <td><code >COMP_REF_TYPE_CONTEXTS</code></td>
      <td style="text-align: center">5</td>
      <td>Number of contexts for <code >comp_ref_type</code></td>
    </tr>
    <tr>
      <td><code >CFL_ALPHA_CONTEXTS</code></td>
      <td style="text-align: center">6</td>
      <td>Number of contexts for <code >cfl_alpha_u</code> and <code >cfl_alpha_v</code></td>
    </tr>
    <tr>
      <td><code >INTRA_MODE_CONTEXTS</code></td>
      <td style="text-align: center">5</td>
      <td>Number of each of left and above contexts for <code >intra_frame_y_mode</code></td>
    </tr>
    <tr>
      <td><code >COMP_GROUP_IDX_CONTEXTS</code></td>
      <td style="text-align: center">6</td>
      <td>Number of contexts for <code >comp_group_idx</code></td>
    </tr>
    <tr>
      <td><code >COMPOUND_IDX_CONTEXTS</code></td>
      <td style="text-align: center">6</td>
      <td>Number of contexts for <code >compound_idx</code></td>
    </tr>
    <tr>
      <td><code >INTRA_EDGE_KERNELS</code></td>
      <td style="text-align: center">3</td>
      <td>Number of filter kernels for the intra edge filter</td>
    </tr>
    <tr>
      <td><code >INTRA_EDGE_TAPS</code></td>
      <td style="text-align: center">5</td>
      <td>Number of kernel taps for the intra edge filter</td>
    </tr>
    <tr>
      <td><code >FRAME_LF_COUNT</code></td>
      <td style="text-align: center">4</td>
      <td>Number of loop filter strength values</td>
    </tr>
    <tr>
      <td><code >MAX_VARTX_DEPTH</code></td>
      <td style="text-align: center">2</td>
      <td>Maximum depth for variable transform trees</td>
    </tr>
    <tr>
      <td><code >TXFM_PARTITION_CONTEXTS</code></td>
      <td style="text-align: center">21</td>
      <td>Number of contexts for txfm_split</td>
    </tr>
    <tr>
      <td><code >REF_CAT_LEVEL</code></td>
      <td style="text-align: center">640</td>
      <td>Bonus weight for close motion vectors</td>
    </tr>
    <tr>
      <td><code >MAX_REF_MV_STACK_SIZE</code></td>
      <td style="text-align: center">8</td>
      <td>Maximum number of motion vectors in the stack</td>
    </tr>
    <tr>
      <td><code >MFMV_STACK_SIZE</code></td>
      <td style="text-align: center">3</td>
      <td>Stack size for motion field motion vectors</td>
    </tr>
    <tr>
      <td><code >MAX_TX_DEPTH</code></td>
      <td style="text-align: center">2</td>
      <td>Maximum times the transform can be split</td>
    </tr>
    <tr>
      <td><code >WEDGE_TYPES</code></td>
      <td style="text-align: center">16</td>
      <td>Number of directions for the wedge mask process</td>
    </tr>
    <tr>
      <td><code >FILTER_BITS</code></td>
      <td style="text-align: center">7</td>
      <td>Number of bits used in Wiener filter coefficients</td>
    </tr>
    <tr>
      <td><code >WIENER_COEFFS</code></td>
      <td style="text-align: center">3</td>
      <td>Number of Wiener filter coefficients to read</td>
    </tr>
    <tr>
      <td><code >SGRPROJ_PARAMS_BITS</code></td>
      <td style="text-align: center">4</td>
      <td>Number of bits needed to specify self guided filter set</td>
    </tr>
    <tr>
      <td><code >SGRPROJ_PRJ_SUBEXP_K</code></td>
      <td style="text-align: center">4</td>
      <td>Controls how self guided deltas are read</td>
    </tr>
    <tr>
      <td><code >SGRPROJ_PRJ_BITS</code></td>
      <td style="text-align: center">7</td>
      <td>Precision bits during self guided restoration</td>
    </tr>
    <tr>
      <td><code >SGRPROJ_RST_BITS</code></td>
      <td style="text-align: center">4</td>
      <td>Restoration precision bits generated higher than source before projection</td>
    </tr>
    <tr>
      <td><code >SGRPROJ_MTABLE_BITS</code></td>
      <td style="text-align: center">20</td>
      <td>Precision of mtable division table</td>
    </tr>
    <tr>
      <td><code >SGRPROJ_RECIP_BITS</code></td>
      <td style="text-align: center">12</td>
      <td>Precision of division by n table</td>
    </tr>
    <tr>
      <td><code >SGRPROJ_SGR_BITS</code></td>
      <td style="text-align: center">8</td>
      <td>Internal precision bits for core selfguided_restoration</td>
    </tr>
    <tr>
      <td><code >EC_PROB_SHIFT</code></td>
      <td style="text-align: center">6</td>
      <td>Number of bits to reduce CDF precision during arithmetic coding</td>
    </tr>
    <tr>
      <td><code >EC_MIN_PROB</code></td>
      <td style="text-align: center">4</td>
      <td>Minimum probability assigned to each symbol during arithmetic coding</td>
    </tr>
    <tr>
      <td><code >SELECT_SCREEN_CONTENT_TOOLS</code></td>
      <td style="text-align: center">2</td>
      <td>Value that indicates the allow_screen_content_tools syntax element is coded</td>
    </tr>
    <tr>
      <td><code >SELECT_INTEGER_MV</code></td>
      <td style="text-align: center">2</td>
      <td>Value that indicates the force_integer_mv syntax element is coded</td>
    </tr>
    <tr>
      <td><code >RESTORATION_TILESIZE_MAX</code></td>
      <td style="text-align: center">256</td>
      <td>Maximum size of a loop restoration tile</td>
    </tr>
    <tr>
      <td><code >MAX_FRAME_DISTANCE</code></td>
      <td style="text-align: center">31</td>
      <td>Maximum distance when computing weighted prediction</td>
    </tr>
    <tr>
      <td><code >MAX_OFFSET_WIDTH</code></td>
      <td style="text-align: center">8</td>
      <td>Maximum horizontal offset of a projected motion vector</td>
    </tr>
    <tr>
      <td><code >MAX_OFFSET_HEIGHT</code></td>
      <td style="text-align: center">0</td>
      <td>Maximum vertical offset of a projected motion vector</td>
    </tr>
    <tr>
      <td><code >WARP_PARAM_REDUCE_BITS</code></td>
      <td style="text-align: center">6</td>
      <td>Rounding bitwidth for the parameters to the shear process</td>
    </tr>
    <tr>
      <td><code >NUM_BASE_LEVELS</code></td>
      <td style="text-align: center">2</td>
      <td>Number of quantizer base levels</td>
    </tr>
    <tr>
      <td><code >COEFF_BASE_RANGE</code></td>
      <td style="text-align: center">12</td>
      <td>The quantizer range above NUM_BASE_LEVELS above which the Exp-Golomb coding process is activated</td>
    </tr>
    <tr>
      <td><code >BR_CDF_SIZE</code></td>
      <td style="text-align: center">4</td>
      <td>Number of values for <code >coeff_br</code></td>
    </tr>
    <tr>
      <td><code >SIG_COEF_CONTEXTS_EOB</code></td>
      <td style="text-align: center">4</td>
      <td>Number of contexts for <code >coeff_base_eob</code></td>
    </tr>
    <tr>
      <td><code >SIG_COEF_CONTEXTS_2D</code></td>
      <td style="text-align: center">26</td>
      <td>Context offset for <code >coeff_base</code> for horizontal-only or vertical-only transforms.</td>
    </tr>
    <tr>
      <td><code >SIG_COEF_CONTEXTS</code></td>
      <td style="text-align: center">42</td>
      <td>Number of contexts for <code >coeff_base</code></td>
    </tr>
    <tr>
      <td><code >SIG_REF_DIFF_OFFSET_NUM</code></td>
      <td style="text-align: center">5</td>
      <td>Maximum number of context samples to be used in determining the context index for <code >coeff_base</code> and <code >coeff_base_eob</code>.</td>
    </tr>
    <tr>
      <td><code >SUPERRES_NUM</code></td>
      <td style="text-align: center">8</td>
      <td>Numerator for upscaling ratio</td>
    </tr>
    <tr>
      <td><code >SUPERRES_DENOM_MIN</code></td>
      <td style="text-align: center">9</td>
      <td>Smallest denominator for upscaling ratio</td>
    </tr>
    <tr>
      <td><code >SUPERRES_DENOM_BITS</code></td>
      <td style="text-align: center">3</td>
      <td>Number of bits sent to specify denominator of upscaling ratio</td>
    </tr>
    <tr>
      <td><code >SUPERRES_FILTER_BITS</code></td>
      <td style="text-align: center">6</td>
      <td>Number of bits of fractional precision for upscaling filter selection</td>
    </tr>
    <tr>
      <td><code >SUPERRES_FILTER_SHIFTS</code></td>
      <td style="text-align: center">1 &lt;&lt; SUPERRES_FILTER_BITS</td>
      <td>Number of phases of upscaling filters</td>
    </tr>
    <tr>
      <td><code >SUPERRES_FILTER_TAPS</code></td>
      <td style="text-align: center">8</td>
      <td>Number of taps of upscaling filters</td>
    </tr>
    <tr>
      <td><code >SUPERRES_FILTER_OFFSET</code></td>
      <td style="text-align: center">3</td>
      <td>Sample offset for upscaling filters</td>
    </tr>
    <tr>
      <td><code >SUPERRES_SCALE_BITS</code></td>
      <td style="text-align: center">14</td>
      <td>Number of fractional bits for computing position in upscaling</td>
    </tr>
    <tr>
      <td><code >SUPERRES_SCALE_MASK</code></td>
      <td style="text-align: center">(1 &lt;&lt; 14) - 1</td>
      <td>Mask for computing position in upscaling</td>
    </tr>
    <tr>
      <td><code >SUPERRES_EXTRA_BITS</code></td>
      <td style="text-align: center">8</td>
      <td>Difference in precision between SUPERRES_SCALE_BITS and SUPERRES_FILTER_BITS</td>
    </tr>
    <tr>
      <td><code >TXB_SKIP_CONTEXTS</code></td>
      <td style="text-align: center">13</td>
      <td>Number of contexts for <code >all_zero</code></td>
    </tr>
    <tr>
      <td><code >EOB_COEF_CONTEXTS</code></td>
      <td style="text-align: center">9</td>
      <td>Number of contexts for <code >eob_extra</code></td>
    </tr>
    <tr>
      <td><code >DC_SIGN_CONTEXTS</code></td>
      <td style="text-align: center">3</td>
      <td>Number of contexts for <code >dc_sign</code></td>
    </tr>
    <tr>
      <td><code >LEVEL_CONTEXTS</code></td>
      <td style="text-align: center">21</td>
      <td>Number of contexts for <code >coeff_br</code></td>
    </tr>
    <tr>
      <td><code >TX_CLASS_2D</code></td>
      <td style="text-align: center">0</td>
      <td>Transform class for transform types performing non-identity transforms in both directions</td>
    </tr>
    <tr>
      <td><code >TX_CLASS_HORIZ</code></td>
      <td style="text-align: center">1</td>
      <td>Transform class for transforms performing only a horizontal non-identity transform</td>
    </tr>
    <tr>
      <td><code >TX_CLASS_VERT</code></td>
      <td style="text-align: center">2</td>
      <td>Transform class for transforms performing only a vertical non-identity transform</td>
    </tr>
    <tr>
      <td><code >REFMVS_LIMIT</code></td>
      <td style="text-align: center">( 1 &lt;&lt; 12 ) - 1</td>
      <td>Largest reference MV component that can be saved</td>
    </tr>
    <tr>
      <td><code >INTRA_FILTER_SCALE_BITS</code></td>
      <td style="text-align: center">4</td>
      <td>Scaling shift for intra filtering process</td>
    </tr>
    <tr>
      <td><code >INTRA_FILTER_MODES</code></td>
      <td style="text-align: center">5</td>
      <td>Number of types of intra filtering</td>
    </tr>
    <tr>
      <td><code >COEFF_CDF_Q_CTXS</code></td>
      <td style="text-align: center">4</td>
      <td>Number of selectable context types for the coeff( ) syntax structure</td>
    </tr>
    <tr>
      <td><code >PRIMARY_REF_NONE</code></td>
      <td style="text-align: center">7</td>
      <td>Value of <code >primary_ref_frame</code> indicating that there is no primary reference frame</td>
    </tr>
    <tr>
      <td><code >BUFFER_POOL_MAX_SIZE</code></td>
      <td style="text-align: center">10</td>
      <td>Number of frames in buffer pool</td>
    </tr>
  </tbody>
</table>

# Conventions # {#conventions}

## General ## {#conventions-general}

The mathematical operators and their precedence rules used to describe this Specification are similar to those used in the C programming language. However, the operation of integer division with truncation is specifically defined.

In addition, a length 2 array used to hold a motion vector (indicated by the variable name ending with the letters Mv or Mvs) can be accessed using either array notation (e.g. <code>Mv[ 0 ]</code> and <code>Mv[ 1 ]</code>), or by just the name (e.g., <code>Mv</code>). The only operations defined when using the name are assignment and equality/inequality testing. Assignment of an array is represented using the notation <code>A = B</code> and is specified to mean the same as doing both the individual assignments <code>A[ 0 ] = B[ 0 ]</code> and <code>A[ 1 ] = B[ 1 ]</code>. Equality testing of 2 motion vectors is represented using the notation <code>A == B</code> and is specified to mean the same as (<code>A[ 0 ] == B[ 0 ] && A[ 1 ] == B[ 1 ]</code>). Inequality testing is defined as <code>A != B</code> and is specified to mean the same as (<code>A[ 0 ] != B[ 0 ] || A[ 1 ] != B[ 1 ]</code>).

When a variable is said to be representable by a signed integer with <code>x</code> bits, it means that the variable is greater than or equal to <code>-(1 << (x-1))</code>, and that the variable is less than or equal to <code>(1 << (x-1))-1</code>.

The key words “must”, “must not”, “required”, “shall”, “shall not”, “should”, “should not”, “recommended”, “may”, and “optional” in this document are to be interpreted as described in RFC 2119.

## Arithmetic operators ## {#conventions-arithmetic-operators}

<table class="table table-sm table-bordered table-nohead">
  <tbody>
    <tr>
      <td>+</td>
      <td>Addition</td>
    </tr>
    <tr>
      <td>–</td>
      <td>Subtraction (as a binary operator) or negation (as a unary prefix operator)</td>
    </tr>
    <tr>
      <td>*</td>
      <td>Multiplication</td>
    </tr>
    <tr>
      <td>/</td>
      <td>Integer division with truncation of the result toward zero. For example, <code>7/4</code> and <code>-7/-4</code> are truncated to <code>1</code> and <code>-7/4</code> and <code>7/-4</code> are truncated to <code>-1</code>.</td>
    </tr>
    <tr>
      <td>a&nbsp;%&nbsp;b</td>
      <td>Remainder from division of <code>a</code> by <code>b</code>. Both <code>a</code> and <code>b</code> are positive integers.</td>
    </tr>
    <tr>
      <td>÷</td>
      <td>Floating point (arithmetical) division.</td>
    </tr>
    <tr>
      <td>ceil(x)</td>
      <td>The smallest integer that is greater or equal than <code>x</code>.</td>
    </tr>
    <tr>
      <td>floor(x)</td>
      <td>The largest integer that is smaller or equal than <code>x</code>.</td>
    </tr>
  </tbody>
</table>

## Logical operators ## {#conventions-logical-operators}

<table class="table table-sm table-bordered table-nohead">
  <tbody>
    <tr>
      <td>a &amp;&amp; b</td>
      <td>Logical AND operation between <code>a</code> and <code>b</code></td>
    </tr>
    <tr>
      <td>a || b</td>
      <td>Logical OR operation between <code>a</code> and <code>b</code></td>
    </tr>
    <tr>
      <td>!</td>
      <td>Logical NOT operation.</td>
    </tr>
  </tbody>
</table>

## Relational operators ## {#conventions-relational-operators}

<table class="table table-sm table-bordered table-nohead">
  <tbody>
    <tr>
      <td>&gt;</td>
      <td>Greater than</td>
    </tr>
    <tr>
      <td>&gt;=</td>
      <td>Greater than or equal to</td>
    </tr>
    <tr>
      <td>&lt;</td>
      <td>Less than</td>
    </tr>
    <tr>
      <td>&lt;=</td>
      <td>Less than or equal to</td>
    </tr>
    <tr>
      <td>==</td>
      <td>Equal to</td>
    </tr>
    <tr>
      <td>!=</td>
      <td>Not equal to</td>
    </tr>
  </tbody>
</table>

## Bitwise operators ## {#conventions-bitwise-operators}

<table class="table table-sm table-bordered table-nohead">
  <tbody>
    <tr>
      <td>&amp;</td>
      <td>AND operation</td>
    </tr>
    <tr>
      <td>|</td>
      <td>OR operation</td>
    </tr>
    <tr>
      <td>^</td>
      <td>XOR operation</td>
    </tr>
    <tr>
      <td>~</td>
      <td>Negation operation</td>
    </tr>
    <tr>
      <td>a&nbsp;&gt;&gt;&nbsp;b</td>
      <td>Shift <code>a</code> in 2’s complement binary integer representation format to the right by <code>b</code> bit positions. This operator is only used with <code>b</code> being a non-negative integer. Bits shifted into the MSBs as a result of the right shift have a value equal to the MSB of <code>a</code> prior to the shift operation.</td>
    </tr>
    <tr>
      <td>a&nbsp;&lt;&lt;&nbsp;b</td>
      <td>Shift <code>a</code> in 2’s complement binary integer representation format to the left by <code>b</code> bit positions. This operator is only used with <code>b</code> being a non-negative integer. Bits shifted into the LSBs as a result of the left shift have a value equal to <code>0</code>.</td>
    </tr>
  </tbody>
</table>

## Assignment ## {#conventions-assignment}

<table class="table table-sm table-bordered table-nohead">
  <tbody>
    <tr>
      <td>=</td>
      <td>Assignment operator</td>
    </tr>
    <tr>
      <td>++</td>
      <td>Increment, <code>x++</code> is equivalent to <code>x = x + 1</code>. When this operator is used for an array index, the variable value is obtained before the auto increment operation</td>
    </tr>
    <tr>
      <td>- -</td>
      <td>Decrement, i.e. <code>x--</code> is equivalent to <code>x = x - 1</code>. When this operator is used for an array index, the variable value is obtained before the auto decrement operation</td>
    </tr>
    <tr>
      <td>+=</td>
      <td>Addition assignment operator, for example <code>x += 3</code> corresponds to <code>x = x + 3</code></td>
    </tr>
    <tr>
      <td>-=</td>
      <td>Subtraction assignment operator, for example <code>x -= 3</code> corresponds to <code>x = x - 3</code></td>
    </tr>
  </tbody>
</table>

## Mathematical functions ## {#conventions-mathematical-functions}

The following mathematical functions (Abs, Clip3, Clip1, Min, Max, Round2 and Round2Signed) are defined as follows:

\[
\text{Abs}(x) =
\begin{cases}
x; & x \geq 0\\
-x; & x < 0
\end{cases}
\]

\[
  \text{Clip1}(x) = \text{Clip3}(0, 2^{BitDepth}-1, x)
\]

\[
\text{Clip3}(x,y,z) =
\begin{cases}
x; & z < x \\
y; & z > y \\
z; & \text{otherwise}
\end{cases}
\]

\[
\text{Min}(x, y) =
\begin{cases}
x; & x \leq y \\
y; & x > y
\end{cases}
\]

\[
\text{Max}(x, y) =
\begin{cases}
x; & x \geq y \\
y; & x < y
\end{cases}
\]

\[
  \text{Round2}(x,n) = \left\lfloor \frac{x+2^{n-1}}{2^n} \right\rfloor
\]

\[
  \text{Round2Signed}(x,n) =
\begin{cases}
\text{Round2}(x,n); & x \geq 0\\
-\text{Round2}(-x,n); & x < 0
\end{cases}
\]

The definition of Round2 uses standard mathematical power and division operations, not integer operations. An equivalent definition using integer operations is:

```cpp
Round2( x, n ) {
  if ( n == 0 )
    return x;
  return (x + (1 << (n - 1)) ) > > n;
}
```

The `FloorLog2(x)` function is defined to be the floor of the base 2 logarithm of the input x.

The input x will always be an integer, and will always be greater than or equal to 1.

This function extracts the location of the most significant bit in x.

An equivalent definition (using the pseudo-code notation introduced in the following section) is:

```cpp
FloorLog2( x ) {
  s = 0
  while ( x != 0 ) {
    x = x >> 1
    s++
  }
  return s - 1
}
```

The `CeilLog2(x)` function is defined to be the ceiling of the base 2 logarithm of the input x (when x is 0, it is defined to return 0).

The input x will always be an integer, and will always be greater than or equal to 0.

This function extracts the number of bits needed to code a value in the range 0 to x-1.

An equivalent definition (using the pseudo-code notation introduced in the following section) is:

```cpp
CeilLog2( x ) {
  if ( x < 2 )
    return 0
  i = 1
  p = 2
  while ( p < x ) {
    i++
    p = p << 1
  }
  return i
}
```

## Method of describing bitstream syntax ## {#conventions-bitstream-syntax}

The description style of the syntax is similar to the C programming language. Syntax elements in the bitstream are represented in bold type. Each syntax element is described by its name (using only lower case letters with underscore characters) and a descriptor for its method of coded representation. The decoding process behaves according to the value of the syntax element and to the values of previously decoded syntax elements. When a value of a syntax element is used in the syntax tables or the text, it appears in regular (i.e. not bold) type. If the value of a syntax element is being computed (e.g. being written with a default value instead of being coded in the bitstream), it also appears in regular type (e.g. tile_size_minus_1).

In some cases the syntax tables may use the values of other variables derived from syntax elements values. Such variables appear in the syntax tables, or text, named by a mixture of lower case and upper case letter and without any underscore characters. Variables starting with an upper case letter are derived for the decoding of the current syntax structure and all depending syntax structures. These variables may be used in the decoding process for later syntax structures. Variables starting with a lower case letter are only used within the process from which they are derived. (Single character variables are allowed.)

Constant values appear in all upper case letters with underscore characters (e.g. MI_SIZE).

Constant lookup tables appear as words (with the first letter of each word in upper case, and remaining letters in lower case) separated with underscore characters (e.g. Block_Width[…]).

Hexadecimal notation, indicated by prefixing the hexadecimal number by <code>0x</code>, may be used when the number of bits is an integer multiple of 4. For example, <code>0x1a</code> represents a bit string <code>0001 1010</code>.

Binary notation is indicated by prefixing the binary number by <code>0b</code>. For example, <code>0b00011010</code> represents a bit string <code>0001 1010</code>. Binary numbers may include underscore characters to enhance readability. If present, the underscore characters appear every 4 binary digits starting from the LSB. For example, <code>0b11010</code> may also be written as <code>0b1_1010</code>.

A value equal to 0 represents a FALSE condition in a test statement. The value TRUE is represented by any value not equal to 0.

The following table lists examples of the syntax specification format. When <code>syntax_element</code> appears (with bold face font), it specifies that this syntax element is parsed from the bitstream.

TBD

## Functions ## {#conventions-functions}

Bitstream functions used for syntax description are specified in this section.

Other functions are included in the syntax tables. The convention is that a section is called syntax if it causes syntax elements to be read from the bitstream, either directly or indirectly through subprocesses. The remaining sections are called functions.

The specification of these functions makes use of a bitstream position indicator. This bitstream position indicator locates the position of the bit that is going to be read next.

**get_position( )**: Return the value of the bitstream position indicator.

**init_symbol( sz )**: Initialize the arithmetic decode process for the Symbol decoder with a size of sz bytes as specified in section 8.2.2 (TBD).

**exit_symbol( )**: Exit the arithmetic decode process as described in section 8.2.4 (TBD) (this includes reading trailing bits).

## Descriptors ## {#conventions-descriptors}

### General ### {#conventions-descriptors-general}

The following descriptors specify the parsing of syntax elements. Lower case descriptors specify syntax elements that are represented by an integer number of bits in the bitstream; upper case descriptors specify syntax elements that are represented by arithmetic coding.

### f(n) ### {#conventions-descriptors-fn}
### uvlc() ### {#conventions-descriptors-uvlc}
### le(n) ### {#conventions-descriptors-len}
### leb128() ### {#conventions-descriptors-leb128}
### su(n) ### {#conventions-descriptors-sun}
### ns(n) ### {#conventions-descriptors-nsn}
### L(n) ### {#conventions-descriptors-ln}
### S() ### {#conventions-descriptors-s}
### NS(n) ### {#conventions-descriptors-nsn2}

# Syntax structures # {#syntax-structures}

## General ## {#syntax-structures-general}
## Low overhead bitstream format ## {#syntax-structures-low-overhead-format}
## OBU syntax ## {#obu-syntax}
### General OBU syntax ### {#obu-syntax-general}
### OBU header syntax ### {#obu-syntax-obu-header}

Example of SDL-like syntax with AV1 Descriptors

```cpp
class OBUHeader {
  f(1) obu_forbidden_bit;
  f(4) obu_type;
  f(1) obu_extension_flag;
  f(1) obu_has_size_field;
  f(1) obu_reserved_1bit;
  if ( obu_extension_flag == 1 ) {
    OBUExtensionHeader obu_extension_header;
  }
}
```

Example using SDL syntax

```cpp
class OBUHeader {
  bit(1) obu_forbidden_bit;
  unsigned int(4) obu_type;
  bit(1) obu_extension_flag;
  bit(1) obu_has_size_field;
  bit(1) obu_reserved_1bit;
  if ( obu_extension_flag == 1 ) {
    OBUExtensionHeader obu_extension_header;
  }
}
```

AV1 style to specify syntax. 

<table class="syntax">
  <tbody>
    <tr>
      <td>obu_header() {</td>
      <td><strong>Type</strong></td>
    </tr>
    <tr>
      <td><b class="syntax-element">obu_forbidden_bit</b></td>
      <td>f(1)</td>
    </tr>
    <tr>
      <td>&nbsp;&nbsp;&nbsp;&nbsp;<b class="syntax-element">obu_type</b></td>
      <td>f(4)</td>
    </tr>
    <tr>
      <td>&nbsp;&nbsp;&nbsp;&nbsp;<b class="syntax-element">obu_extension_flag</b></td>
      <td>f(1)</td>
    </tr>
    <tr>
      <td>&nbsp;&nbsp;&nbsp;&nbsp;<b class="syntax-element">obu_has_size_field</b></td>
      <td>f(1)</td>
    </tr>
    <tr>
      <td>&nbsp;&nbsp;&nbsp;&nbsp;<b class="syntax-element">obu_reserved_1bit</b></td>
      <td>f(1)</td>
    </tr>
    <tr>
      <td>&nbsp;&nbsp;&nbsp;&nbsp;if ( obu_extension_flag == 1 )</td>
      <td>&nbsp;</td>
    </tr>
    <tr>
      <td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;obu_extension_header()</td>
      <td>&nbsp;</td>
    </tr>
    <tr>
      <td>}</td>
      <td>&nbsp;</td>
    </tr>
  </tbody>
</table>

However, note that edditing the HTML table is not so easy. We could export the following definition to a separate file. e.g. `obu_header.syntax` which would contain this.

```
| --------------------------------------------------------- | ---------------- |
| obu_header() {                                            | **Type**
|     @@obu_forbidden_bit                                   | f(1)
|     @@obu_type                                            | f(4)
|     @@obu_extension_flag                                  | f(1)
|     @@obu_has_size_field                                 | f(1)
|     @@obu_reserved_1bit                                   | f(1)
|     if ( obu_extension_flag == 1 )
|         obu_extension_header()
| }
```

and then we could write a python script that would translate it into HTML. That way it is still easy to work on syntax with minimal changes and the GitHub Actions automation will do the rest.

### OBU extension header syntax ### {#obu-syntax-obu-header-extension}

Example of SDL-like syntax with AV1 Descriptors

```cpp
class OBUExtensionHeader {
  f(3) temporal_id;
  f(2) spatial_id;
  f(3) extension_header_reserved_3bits;
}
```

Example using SDL syntax

```cpp
class OBUExtensionHeader {
  unsigned int(3) temporal_id;
  unsigned int(2) spatial_id;
  bit(3) extension_header_reserved_3bits;
}
```

### Trailing bits syntax ### {#obu-syntax-trailing-bits}
### Byte alignment syntax ### {#obu-syntax-byte-alignment}
## Reserved OBU syntax ## {#reserved-obu-syntax}
## Sequence header OBU syntax ## {#shobu-syntax}
### General sequence header OBU syntax ### {#shobu-syntax-general}
### Color config syntax ### {#color-config-syntax}
