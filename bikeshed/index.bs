<pre class='metadata'>
Title: AV1 Bitstream &amp; Decoding Process Specification (bikeshed experiment)
Status: PD
URL: https://aomediacodec.github.io/av1-spec/
Shortname: av1-spec
Editor: Peter de Rivaz, Argon Design Ltd  
Editor: Jack Haughton, Argon Design Ltd
Editor: Adrian Grange, Google LLC
Editor: Lou Quillio, Google LLC
Abstract: This document defines the bitstream formats and decoding process for the <a href="https://aomedia.org">Alliance for Open Media</a> AV1 video codec.
Date: 2024-03-01
Repository: AOMediaCodec/av1-spec
Group: AOM
!Latest approved version: <a href="https://aomediacodec.github.io/av1-spec/av1-spec.pdf">https://aomediacodec.github.io/av1-spec/av1-spec.pdf</a>
Metadata Order: This version, !*, *
</pre>


# Scope # {#scope}

This document specifies the Alliance for Open Media AV1 bitstream formats and
decoding process.

# Terms and definitions # {#terms_and_definitions}

For the purposes of this document, the following terms and definitions apply:

<dfn>AC coefficient</dfn>

Any transform coefficient whose frequency indices are non-zero in at least one dimension.

<dfn>Altref</dfn>

(Alternative reference frame) A frame that can be used in inter coding.

<dfn>Base layer</dfn>

The layer with spatial_id and temporal_id values equal to 0.

<dfn>Bitstream</dfn>

The sequence of bits generated by encoding a sequence of frames.

<dfn>Bit string</dfn>

An ordered string with limited number of bits. The left most bit is the most significant bit (MSB), the right most bit is the least significant bit (LSB).

<dfn>Block</dfn>

A square or rectangular region of samples.

<dfn>Block scan</dfn>

A specified serial ordering of quantized coefficients.

<dfn>Byte</dfn>

An 8-bit bit string.

<dfn>Byte alignment</dfn>

One bit is byte aligned if the position of the bit is an integer multiple of eight from the position of the first bit in the bitstream.

<dfn>CDEF</dfn>

Constrained Directional Enhancement Filter designed to adaptively filter blocks based on identifying the direction.

<dfn>CDF</dfn>

Cumulative distribution function representing the probability times 32768 that a symbol has value less than or equal to a given level.

<dfn>Chroma</dfn>

A sample value matrix or a single sample value of one of the two color difference signals.  

NOTE: Symbols of chroma are U and V. 

<dfn>Coded frame</dfn>

The representation of one frame before the decoding process.

<dfn>Component</dfn>

One of the three sample value matrices (one luma matrix and two chroma matrices) or its single sample value.

<dfn>Compound prediction</dfn>

A type of inter prediction where sample values are computed by blending together predictions from two reference frames (the frames blended can be the same or different).

<dfn>DC coefficient</dfn>

A transform coefficient whose frequency indices are zero in both dimensions.

<dfn>Decoded frame</dfn>

The frame reconstructed out of the bitstream by the decoder.

<dfn>Decoder</dfn>

One embodiment of the decoding process.

<dfn>Decoding process</dfn>

The process that derives decoded frames from syntax elements, including any processing  steps used prior to and for the film grain synthesis process.

<dfn>Dequantization</dfn>

The process in which transform coefficients are obtained by scaling the quantized coefficients.

<dfn>Encoder</dfn>

One embodiment of the encoding process.

<dfn>Encoding process</dfn>

A process not specified in this Specification that generates the bitstream that conforms to the description provided in this document.

<dfn>Enhancement layer</dfn>

A layer with either spatial_id greater than 0 or temporal_id greater than 0.

<dfn>Flag</dfn>

A binary variable - some variables and syntax elements (e.g. obu_extension_flag) are described using the word flag to highlight that the syntax element can only be equal to 0 or equal to 1.

<dfn>Frame</dfn>

The representation of video signals in the spatial domain, composed of one luma sample matrix (Y) and two chroma sample matrices (U and V).

<dfn>Frame context</dfn>

A set of probabilities used in the decoding process.

<dfn>Golden frame</dfn>

A frame that can be used in inter coding. Typically the golden frame is encoded with higher quality and is used as a reference for multiple inter frames.

<dfn>Inter coding</dfn>

Coding one block or frame using inter prediction.

<dfn>Inter frame</dfn>

A frame compressed by referencing previously decoded frames and which may use intra prediction or inter prediction.

<dfn>Inter prediction</dfn>

The process of deriving the prediction value for the current frame using previously decoded frames.

<dfn>Intra coding</dfn>

Coding one block or frame using intra prediction.

<dfn>Intra frame</dfn>

A frame compressed using only intra prediction which can be independently decoded.

<dfn>Intra prediction</dfn>

The process of deriving the prediction value for the current sample using previously decoded sample values in the same decoded frame.

<dfn>Inverse transform</dfn>

The process in which a transform coefficient matrix is transformed into a spatial sample value matrix.

<dfn>Key frame</dfn>

An Intra frame which resets the decoding process when it is shown.

<dfn>Layer</dfn>

A set of tile group OBUs with identical spatial_id and identical temporal_id values.

<dfn>Level</dfn>

A defined set of constraints on the values for the syntax elements and variables.

<dfn>Loop filter</dfn>

A filtering process applied to the reconstruction intended to reduce the visibility of block edges.

<dfn>Luma</dfn>

A sample value matrix or a single sample value representing the monochrome signal related to the primary colors.  

NOTE: The symbol representing luma is Y. 

<dfn>Mode info</dfn>

Syntax elements sent for a block containing an indication of how a block is to be predicted during the decoding process.

<dfn>Mode info block</dfn>

A luma sample value block of size 4x4 or larger and its two corresponding chroma sample value blocks (if present).

<dfn>Motion vector</dfn>

A two-dimensional vector used for inter prediction which refers the current frame to the reference frame, the value of which provides the coordinate offsets from a location in the current frame to a location in the reference frame.

<dfn>OBU</dfn>

All structures are packetized in "Open Bitstream Units" or OBUs. Each OBU has a header, which provides identifying information for the contained data (payload).

<dfn>Parse</dfn>

The procedure of getting the syntax element from the bitstream.

<dfn>Prediction</dfn>

The implementation of the prediction process consisting of either inter or intra prediction.

<dfn>Prediction process</dfn>

The process of estimating the decoded sample value or data element using a predictor.

<dfn>Prediction value</dfn>

The value, which is the combination of the previously decoded sample values or data elements, used in the decoding process of the next sample value or data element.

<dfn>Profile</dfn>

A subset of syntax, semantics and algorithms defined in a part.

<dfn>Quantization parameter</dfn>

A variable used for scaling the quantized coefficients in the decoding process.

<dfn>Quantized coefficient</dfn>

A transform coefficient before dequantization.

<dfn>Raster scan</dfn>

Maps a two dimensional rectangular raster into a one dimensional raster, in which the entry of the one dimensional raster starts from the first row of the two dimensional raster, and the scanning then goes through the second row and the third row, and so on. Each raster row is scanned in left to right order.

<dfn>Reconstruction</dfn>

Obtaining the addition of the decoded residual and the corresponding prediction values.

<dfn>Reference</dfn>

One of a set of tags, each of which is mapped to a reference frame.

<dfn>Reference frame</dfn>

A storage area for a previously decoded frame and associated information.

<dfn>Reserved</dfn>

A special syntax element value which may be used to extend this part in the future.

<dfn>Residual</dfn>

The differences between the reconstructed samples and the corresponding prediction values.

<dfn>Sample</dfn>

The basic elements that compose the frame.

<dfn>Sample value</dfn>

The value of a sample. This is an integer from 0 to 255 (inclusive) for 8-bit frames, from 0 to 1023 (inclusive) for 10-bit frames, and from 0 to 4095 (inclusive) for 12-bit frames.

<dfn>Segmentation map</dfn>

One 3-bit number per 4x4 block in the frame specifying the segment affiliation of that block. A segmentation map is stored for each reference frame to allow new frames to use a previously coded map.

<dfn>Sequence</dfn>

The highest level syntax structure of coding bitstream, including one or several consecutive coded frames.

<dfn>Superblock</dfn>

The top level of the block quadtree within a tile. All superblocks within a frame are the same size and are square. The superblocks may be 128x128 luma samples or 64x64 luma samples. A superblock may contain 1 or 2 or 4 mode info blocks, or may be bisected in each direction to create 4 sub-blocks, which may themselves be further subpartitioned, forming the block quadtree.

<dfn>Switch Frame</dfn>

An inter frame that can be used as a point to switch between sequences. Switch frames overwrite all the reference frames without forcing the use of intra coding.  The intention is to allow a streaming use case where videos can be encoded in small chunks (say of 1 second duration), each starting with a switch frame.  If the available bandwidth drops, the server can start sending chunks from a lower bitrate encoding instead. When this happens the inter prediction uses the existing higher quality reference frames to decode the switch frame.  This approach allows a bitrate switch without the cost of a full key frame.

<dfn>Syntax element</dfn>

An element of data represented in the bitstream.

<dfn>Temporal delimiter OBU</dfn>

An indication that the following OBUs will have a different presentation/decoding time stamp from the one of the last frame prior to the temporal delimiter.

<dfn>Temporal unit</dfn>

A Temporal unit consists of all the OBUs that are associated with a specific, distinct time instant. It consists of a temporal delimiter OBU, and all the OBUs that follow, up to but not including the next temporal delimiter.

<dfn>Temporal group</dfn>

A set of frames whose temporal prediction structure is used periodically in a video sequence.

<dfn>Tier</dfn>

A specified category of level constraints imposed on the values of the syntax elements in the bitstream.

<dfn>Tile</dfn>

A rectangular region of the frame that can be decoded and encoded independently, although loop-filtering across tile edges is still applied.

<dfn>Transform block</dfn>

A rectangular transform coefficient matrix, used as input to the inverse transform process.

<dfn>Transform coefficient</dfn>

A scalar value, considered to be in a frequency domain, contained in a transform block.

<dfn>Uncompressed header</dfn>

High level description of the frame to be decoded that is encoded without the use of arithmetic encoding.



# Symbols and abbreviated terms # {#symbols_and_abbreviated_terms}

DCT

: Discrete Cosine Transform

ADST

: Asymmetric Discrete Sine Transform

LSB

: Least Significant Bit

MSB

: Most Significant Bit

WHT

: Walsh Hadamard Transform

The specification makes use of a number of constant integers.  Constants that
relate to the semantics of a particular syntax element are defined in
[section 6][].

Additional constants are defined below:


| Symbol name                      | Value     | Description |
| -------------------------------- |:---------:| ----------- |
| `REFS_PER_FRAME`                 | 7         | Number of reference frames that can be used for inter prediction
| `TOTAL_REFS_PER_FRAME`           | 8         | Number of reference frame types (including intra type)
| `BLOCK_SIZE_GROUPS`              | 4         | Number of contexts when decoding `y_mode`
| `BLOCK_SIZES`                    | 22        | Number of different block sizes used
| `BLOCK_INVALID`                  | 22        | Sentinel value to mark partition choices that are not allowed
| `MAX_SB_SIZE`                    | 128       | Maximum size of a superblock in luma samples
| `MI_SIZE`                        | 4         | Smallest size of a mode info block in luma samples
| `MI_SIZE_LOG2`                   | 2         | Base 2 logarithm of smallest size of a mode info block
| `MAX_TILE_WIDTH`                 | 4096      | Maximum width of a tile in units of luma samples
| `MAX_TILE_AREA`                  | 4096 * 2304 | Maximum area of a tile in units of luma samples
| `MAX_TILE_ROWS`                  | 64        | Maximum number of tile rows
| `MAX_TILE_COLS`                  | 64        | Maximum number of tile columns
| `INTRABC_DELAY_PIXELS`           | 256       | Number of horizontal luma samples before intra block copy can be used
| `INTRABC_DELAY_SB64`             | 4         | Number of 64 by 64 blocks before intra block copy can be used
| `NUM_REF_FRAMES`                 | 8         | Number of frames that can be stored for future reference
| `IS_INTER_CONTEXTS`              | 4         | Number of contexts for `is_inter`
| `REF_CONTEXTS`                   | 3         | Number of contexts for `single_ref`, `comp_ref`, `comp_bwdref`, `uni_comp_ref`, `uni_comp_ref_p1` and `uni_comp_ref_p2`
| `MAX_SEGMENTS`                   | 8         | Number of segments allowed in segmentation map
| `SEGMENT_ID_CONTEXTS`            | 3         | Number of contexts for `segment_id`
| `SEG_LVL_ALT_Q`                  | 0         | Index for quantizer segment feature
| `SEG_LVL_ALT_LF_Y_V`             | 1         | Index for vertical luma loop filter segment feature
| `SEG_LVL_REF_FRAME`              | 5         | Index for reference frame segment feature
| `SEG_LVL_SKIP`                   | 6         | Index for skip segment feature
| `SEG_LVL_GLOBALMV`               | 7         | Index for global mv feature
| `SEG_LVL_MAX`                    | 8         | Number of segment features
| `PLANE_TYPES`                    | 2         | Number of different plane types (luma or chroma)
| `TX_SIZE_CONTEXTS`               | 3         | Number of contexts for transform size
| `INTERP_FILTERS`                 | 3         | Number of values for `interp_filter`
| `INTERP_FILTER_CONTEXTS`         | 16        | Number of contexts for `interp_filter`
| `SKIP_MODE_CONTEXTS`             | 3         | Number of contexts for decoding skip_mode
| `SKIP_CONTEXTS`                  | 3         | Number of contexts for decoding skip
| `PARTITION_CONTEXTS`             | 4         | Number of contexts when decoding `partition`
| `TX_SIZES`                       | 5         | Number of square transform sizes
| `TX_SIZES_ALL`                   | 19        | Number of transform sizes (including non-square sizes)
| `TX_MODES`                       | 3         | Number of values for `tx_mode`
| `DCT_DCT`                        | 0         | Inverse transform rows with `DCT` and columns with `DCT`
| `ADST_DCT`                       | 1         | Inverse transform rows with `DCT` and columns with `ADST`
| `DCT_ADST`                       | 2         | Inverse transform rows with `ADST` and columns with `DCT`
| `ADST_ADST`                      | 3         | Inverse transform rows with `ADST` and columns with `ADST`
| `FLIPADST_DCT`                   | 4         | Inverse transform rows with `DCT` and columns with `FLIPADST`
| `DCT_FLIPADST`                   | 5         | Inverse transform rows with `FLIPADST` and columns with `DCT`
| `FLIPADST_FLIPADST`              | 6         | Inverse transform rows with `FLIPADST` and columns with `FLIPADST`
| `ADST_FLIPADST`                  | 7         | Inverse transform rows with `FLIPADST` and columns with `ADST`
| `FLIPADST_ADST`                  | 8         | Inverse transform rows with `ADST` and columns with `FLIPADST`
| `IDTX`                           | 9         | Inverse transform rows with identity and columns with identity
| `V_DCT`                          | 10        | Inverse transform rows with identity and columns with `DCT`
| `H_DCT`                          | 11        | Inverse transform rows with `DCT` and columns with identity
| `V_ADST`                         | 12        | Inverse transform rows with identity and columns with `ADST`
| `H_ADST`                         | 13        | Inverse transform rows with `ADST` and columns with identity
| `V_FLIPADST`                     | 14        | Inverse transform rows with identity and columns with `FLIPADST`
| `H_FLIPADST`                     | 15        | Inverse transform rows with `FLIPADST` and columns with identity
| `TX_TYPES`                       | 16        | Number of inverse transform types
| `MB_MODE_COUNT`                  | 17        | Number of values for `YMode`
| `INTRA_MODES`                    | 13        | Number of values for `y_mode`
| `UV_INTRA_MODES_CFL_NOT_ALLOWED` | 13        | Number of values for `uv_mode` when chroma from luma is not allowed
| `UV_INTRA_MODES_CFL_ALLOWED`     | 14        | Number of values for `uv_mode` when chroma from luma is allowed
| `COMPOUND_MODES`                 | 8         | Number of values for `compound_mode`
| `COMPOUND_MODE_CONTEXTS`         | 8         | Number of contexts for `compound_mode`
| `COMP_NEWMV_CTXS`                | 5         | Number of new mv values used when constructing context for `compound_mode` 
| `NEW_MV_CONTEXTS`                | 6         | Number of contexts for `new_mv`
| `ZERO_MV_CONTEXTS`               | 2         | Number of contexts for `zero_mv`
| `REF_MV_CONTEXTS`                | 6         | Number of contexts for `ref_mv`
| `DRL_MODE_CONTEXTS`              | 3         | Number of contexts for `drl_mode`
| `MV_CONTEXTS`                    | 2         | Number of contexts for decoding motion vectors including one for intra block copy
| `MV_INTRABC_CONTEXT`             | 1         | Motion vector context used for intra block copy
| `MV_JOINTS`                      | 4         | Number of values for `mv_joint`
| `MV_CLASSES`                     | 11        | Number of values for `mv_class`
| `CLASS0_SIZE`                    | 2         | Number of values for `mv_class0_bit`
| `MV_OFFSET_BITS`                 | 10        | Maximum number of bits for decoding motion vectors
| `MAX_LOOP_FILTER`                | 63        | Maximum value used for loop filtering
| `REF_SCALE_SHIFT`                | 14        | Number of bits of precision when scaling reference frames
| `SUBPEL_BITS`                    | 4         | Number of bits of precision when choosing an inter prediction filter kernel
| `SUBPEL_MASK`                    | 15        | `( 1 << SUBPEL_BITS ) - 1`
| `SCALE_SUBPEL_BITS`              | 10        | Number of bits of precision when computing inter prediction locations
| `MV_BORDER`                      | 128       | Value used when clipping motion vectors
| `PALETTE_COLOR_CONTEXTS`         | 5         | Number of values for color contexts
| `PALETTE_MAX_COLOR_CONTEXT_HASH` | 8         | Number of mappings between color context hash and color context
| `PALETTE_BLOCK_SIZE_CONTEXTS`    | 7         | Number of values for palette block size
| `PALETTE_Y_MODE_CONTEXTS`        | 3         | Number of values for palette Y plane mode contexts
| `PALETTE_UV_MODE_CONTEXTS`       | 2         | Number of values for palette U and V plane mode contexts
| `PALETTE_SIZES`                  | 7         | Number of values for palette_size
| `PALETTE_COLORS`                 | 8         | Number of values for palette_color
| `PALETTE_NUM_NEIGHBORS`          | 3         | Number of neighbors considered within palette computation
| `DELTA_Q_SMALL`                  | 3         | Value indicating alternative encoding of quantizer index delta values
| `DELTA_LF_SMALL`                 | 3         | Value indicating alternative encoding of loop filter delta values
| `QM_TOTAL_SIZE`                  | 3344      | Number of values in the quantizer matrix
| `MAX_ANGLE_DELTA`                | 3         | Maximum magnitude of AngleDeltaY and AngleDeltaUV
| `DIRECTIONAL_MODES`              | 8         | Number of directional intra modes
| `ANGLE_STEP`                     | 3         | Number of degrees of step per unit increase in AngleDeltaY or AngleDeltaUV.
| `TX_SET_TYPES_INTRA`             | 3         | Number of intra transform set types
| `TX_SET_TYPES_INTER`             | 4         | Number of inter transform set types
| `WARPEDMODEL_PREC_BITS`          | 16        | Internal precision of warped motion models
| `IDENTITY`                       | 0         | Warp model is just an identity transform
| `TRANSLATION`                    | 1         | Warp model is a pure translation
| `ROTZOOM`                        | 2         | Warp model is a rotation + symmetric zoom + translation
| `AFFINE`                         | 3         | Warp model is a general affine transform
| `GM_ABS_TRANS_BITS`              | 12        | Number of bits encoded for translational components of global motion models, if part of a ROTZOOM or AFFINE model
| `GM_ABS_TRANS_ONLY_BITS`         | 9         | Number of bits encoded for translational components of global motion models, if part of a TRANSLATION model
| `GM_ABS_ALPHA_BITS`              | 12        | Number of bits encoded for non-translational components of global motion models
| `DIV_LUT_PREC_BITS`              | 14        | Number of fractional bits of entries in divisor lookup table
| `DIV_LUT_BITS`                   | 8         | Number of fractional bits for lookup in divisor lookup table
| `DIV_LUT_NUM`                    | 257       | Number of entries in divisor lookup table 
| `MOTION_MODES`                   | 3         | Number of values for motion modes
| `SIMPLE`                         | 0         | Use translation or global motion compensation
| `OBMC`                           | 1         | Use overlapped block motion compensation
| `LOCALWARP`                      | 2         | Use local warp motion compensation
| `LEAST_SQUARES_SAMPLES_MAX`      | 8         | Largest number of samples used when computing a local warp
| `LS_MV_MAX`                      | 256       | Largest motion vector difference to include in local warp computation
| `WARPEDMODEL_TRANS_CLAMP`        | 1\<\<23   | Clamping value used for translation components of warp
| `WARPEDMODEL_NONDIAGAFFINE_CLAMP`| 1\<\<13   | Clamping value used for matrix components of warp
| `WARPEDPIXEL_PREC_SHIFTS`        | 1\<\<6    | Number of phases used in warped filtering
| `WARPEDDIFF_PREC_BITS`           | 10        | Number of extra bits of precision in warped filtering
| `GM_ALPHA_PREC_BITS`             | 15        | Number of fractional bits for sending non-translational warp model coefficients
| `GM_TRANS_PREC_BITS`             | 6         | Number of fractional bits for sending translational warp model coefficients
| `GM_TRANS_ONLY_PREC_BITS`        | 3         | Number of fractional bits used for pure translational warps
| `INTERINTRA_MODES`               | 4         | Number of inter intra modes
| `MASK_MASTER_SIZE`               | 64        | Size of MasterMask array
| `SEGMENT_ID_PREDICTED_CONTEXTS`  | 3         | Number of contexts for `segment_id_predicted`
| `IS_INTER_CONTEXTS`              | 4         | Number of contexts for `is_inter`
| `FWD_REFS`                       | 4         | Number of syntax elements for forward reference frames
| `BWD_REFS`                       | 3         | Number of syntax elements for backward reference frames
| `SINGLE_REFS`                    | 7         | Number of syntax elements for single reference frames
| `UNIDIR_COMP_REFS`               | 4         | Number of syntax elements for unidirectional compound reference frames
| `COMPOUND_TYPES`                 | 2         | Number of values for `compound_type`
| `CFL_JOINT_SIGNS`                | 8         | Number of values for `cfl_alpha_signs`
| `CFL_ALPHABET_SIZE`              | 16        | Number of values for `cfl_alpha_u` and `cfl_alpha_v`
| `COMP_INTER_CONTEXTS`            | 5         | Number of contexts for `comp_mode`
| `COMP_REF_TYPE_CONTEXTS`         | 5         | Number of contexts for `comp_ref_type`
| `CFL_ALPHA_CONTEXTS`             | 6         | Number of contexts for `cfl_alpha_u` and `cfl_alpha_v`
| `INTRA_MODE_CONTEXTS`            | 5         | Number of each of left and above contexts for `intra_frame_y_mode`
| `COMP_GROUP_IDX_CONTEXTS`        | 6         | Number of contexts for `comp_group_idx`
| `COMPOUND_IDX_CONTEXTS`          | 6         | Number of contexts for `compound_idx`
| `INTRA_EDGE_KERNELS`             | 3         | Number of filter kernels for the intra edge filter
| `INTRA_EDGE_TAPS`                | 5         | Number of kernel taps for the intra edge filter
| `FRAME_LF_COUNT`                 | 4         | Number of loop filter strength values
| `MAX_VARTX_DEPTH`                | 2         | Maximum depth for variable transform trees
| `TXFM_PARTITION_CONTEXTS`        | 21        | Number of contexts for txfm_split
| `REF_CAT_LEVEL`                  | 640       | Bonus weight for close motion vectors
| `MAX_REF_MV_STACK_SIZE`          | 8         | Maximum number of motion vectors in the stack
| `MFMV_STACK_SIZE`                | 3         | Stack size for motion field motion vectors
| `MAX_TX_DEPTH`                   | 2         | Maximum times the transform can be split
| `WEDGE_TYPES`                    | 16        | Number of directions for the wedge mask process
| `FILTER_BITS`                    | 7         | Number of bits used in Wiener filter coefficients
| `WIENER_COEFFS`                  | 3         | Number of Wiener filter coefficients to read
| `SGRPROJ_PARAMS_BITS`            | 4         | Number of bits needed to specify self guided filter set
| `SGRPROJ_PRJ_SUBEXP_K`           | 4         | Controls how self guided deltas are read
| `SGRPROJ_PRJ_BITS`               | 7         | Precision bits during self guided restoration
| `SGRPROJ_RST_BITS`               | 4         | Restoration precision bits generated higher than source before projection
| `SGRPROJ_MTABLE_BITS`            | 20        | Precision of mtable division table
| `SGRPROJ_RECIP_BITS`             | 12        | Precision of division by n table
| `SGRPROJ_SGR_BITS`               | 8         | Internal precision bits for core selfguided_restoration
| `EC_PROB_SHIFT`                  | 6         | Number of bits to reduce CDF precision during arithmetic coding
| `EC_MIN_PROB`                    | 4         | Minimum probability assigned to each symbol during arithmetic coding
| `SELECT_SCREEN_CONTENT_TOOLS`    | 2         | Value that indicates the allow_screen_content_tools syntax element is coded
| `SELECT_INTEGER_MV`              | 2         | Value that indicates the force_integer_mv syntax element is coded
| `RESTORATION_TILESIZE_MAX`       | 256       | Maximum size of a loop restoration tile
| `MAX_FRAME_DISTANCE`             | 31        | Maximum distance when computing weighted prediction
| `MAX_OFFSET_WIDTH`               | 8         | Maximum horizontal offset of a projected motion vector
| `MAX_OFFSET_HEIGHT`              | 0         | Maximum vertical offset of a projected motion vector
| `WARP_PARAM_REDUCE_BITS`         | 6         | Rounding bitwidth for the parameters to the shear process
| `NUM_BASE_LEVELS`                | 2         | Number of quantizer base levels
| `COEFF_BASE_RANGE`               | 12        | The quantizer range above NUM_BASE_LEVELS above which the Exp-Golomb coding process is activated
| `BR_CDF_SIZE`                    | 4         | Number of values for `coeff_br`
| `SIG_COEF_CONTEXTS_EOB`          | 4         | Number of contexts for `coeff_base_eob`
| `SIG_COEF_CONTEXTS_2D`           | 26        | Context offset for `coeff_base` for horizontal-only or vertical-only transforms.
| `SIG_COEF_CONTEXTS`              | 42        | Number of contexts for `coeff_base`
| `SIG_REF_DIFF_OFFSET_NUM`        | 5         | Maximum number of context samples to be used in determining the context index for `coeff_base` and `coeff_base_eob`.
| `SUPERRES_NUM`                   | 8         | Numerator for upscaling ratio
| `SUPERRES_DENOM_MIN`             | 9         | Smallest denominator for upscaling ratio
| `SUPERRES_DENOM_BITS`            | 3         | Number of bits sent to specify denominator of upscaling ratio
| `SUPERRES_FILTER_BITS`           | 6         | Number of bits of fractional precision for upscaling filter selection
| `SUPERRES_FILTER_SHIFTS`         | 1 \<\< SUPERRES_FILTER_BITS | Number of phases of upscaling filters
| `SUPERRES_FILTER_TAPS`           | 8         | Number of taps of upscaling filters
| `SUPERRES_FILTER_OFFSET`         | 3         | Sample offset for upscaling filters
| `SUPERRES_SCALE_BITS`            | 14        | Number of fractional bits for computing position in upscaling
| `SUPERRES_SCALE_MASK`            | (1 \<\< 14) - 1 | Mask for computing position in upscaling
| `SUPERRES_EXTRA_BITS`            | 8         | Difference in precision between SUPERRES_SCALE_BITS and SUPERRES_FILTER_BITS
| `TXB_SKIP_CONTEXTS`              | 13        | Number of contexts for `all_zero`
| `EOB_COEF_CONTEXTS`              | 9         | Number of contexts for `eob_extra`
| `DC_SIGN_CONTEXTS`               | 3         | Number of contexts for `dc_sign`
| `LEVEL_CONTEXTS`                 | 21        | Number of contexts for `coeff_br`
| `TX_CLASS_2D`                    | 0         | Transform class for transform types performing non-identity transforms in both directions
| `TX_CLASS_HORIZ`                 | 1         | Transform class for transforms performing only a horizontal non-identity transform
| `TX_CLASS_VERT`                  | 2         | Transform class for transforms performing only a vertical non-identity transform
| `REFMVS_LIMIT`                   | ( 1 \<\< 12 ) - 1 | Largest reference MV component that can be saved
| `INTRA_FILTER_SCALE_BITS`        | 4         | Scaling shift for intra filtering process
| `INTRA_FILTER_MODES`             | 5         | Number of types of intra filtering
| `COEFF_CDF_Q_CTXS`               | 4         | Number of selectable context types for the coeff( ) syntax structure
| `PRIMARY_REF_NONE`               | 7         | Value of `primary_ref_frame` indicating that there is no primary reference frame
| `BUFFER_POOL_MAX_SIZE`           | 10        | Number of frames in buffer pool
{:.table .table-sm .table-bordered .table-striped }

# Conventions # {#conventions}

## General ## {#general}

The mathematical operators and their precedence rules used to describe this
Specification are similar to those used in the C programming language.
However, the operation of integer division with truncation is specifically
defined.

In addition, a length 2 array used to hold a motion vector (indicated
by the variable name ending with the letters `Mv` or `Mvs`) can be accessed
using either array notation (e.g. `Mv[ 0 ]` and `Mv[ 1 ]`), or by just
the name (e.g., `Mv`). The only operations defined when using the name are
assignment and equality/inequality testing. Assignment of an array is
represented using the notation `A = B` and is specified to mean the same
as doing both the individual assignments `A[ 0 ] = B[ 0 ]` and
`A[ 1 ] = B[ 1 ].` Equality testing of 2 motion vectors is represented using the
notation `A == B` and is specified to mean the same as
`(A[ 0 ] == B[ 0 ] && A[ 1 ] == B[ 1 ])`. Inequality testing is defined as
`A != B` and is specified to mean the same as
`(A[ 0 ] != B[ 0 ] || A[ 1 ] != B[ 1 ])`.

When a variable is said to be representable by a signed integer with `x` bits,
it means that the variable is greater than or equal to `-(1 << (x-1))`, and that
the variable is less than or equal to `(1 << (x-1))-1`.

The key words "must", "must not", "required", "shall", "shall not",
"should", "should not", "recommended",  "may", and
"optional" in this document are to be interpreted as described in
RFC 2119.


## Arithmetic operators ## {#arithmetic_operators}

|:--------:| ------- |
| +        | Addition
| –        | Subtraction (as a binary operator) or negation (as a unary prefix operator)
| *        | Multiplication
| /        | Integer division with truncation of the result toward zero. For example, `7/4` and `-7/-4` are truncated to `1` and `-7/4` and `7/-4` are truncated to `-1`.
| a&nbsp;%&nbsp;b  |  Remainder from division of `a` by `b`. Both `a` and `b` are positive integers.
| ÷        | Floating point (arithmetical) division.
| ceil(x)  | The smallest integer that is greater or equal than `x`.
| floor(x) | The largest integer that is smaller or equal than `x`.
{:.table .table-sm .table-bordered .table-nohead }


## Logical operators ## {#logical_operators}

|:--------:| ------- |
| a && b   | Logical AND operation between `a` and `b`
| a \|\| b | Logical OR operation between `a` and `b`
| !        | Logical NOT operation.
{:.table .table-sm .table-bordered .table-nohead }

{% comment %}
Note escaped pipe characters in above syntax table.
{% endcomment %}


## Relational operators ## {#relational_operators}

|:--------:| ------- |
| >        | Greater than
| >=       | Greater than or equal to
| <        | Less than
| <=       | Less than or equal to
| ==       | Equal to
| !=       | Not equal to
{:.table .table-sm .table-bordered .table-nohead }


## Bitwise operators ## {#bitwise_operators}

|:--------:| ------- |
| &        | AND operation
| \|       | OR operation
| ^        | XOR operation
| ~        | Negation operation
| a&nbsp;\>\>&nbsp;b | Shift `a` in 2's complement binary integer representation format to the right by `b` bit positions. This operator is only used with `b` being a non-negative integer. Bits shifted into the MSBs as a result of the right shift have a value equal to the MSB of `a` prior to the shift operation.
| a&nbsp;\<\<&nbsp;b | Shift `a` in 2's complement binary integer representation format to the left by `b` bit positions. This operator is only used with `b` being a non-negative integer. Bits shifted into the LSBs as a result of the left shift have a value equal to `0`.
{:.table .table-sm .table-bordered .table-nohead }

{% comment %}
Note escaped pipe and greater-than characters in above syntax table.
{% endcomment %}


## Assignment ## {#assignment}

|:--------:| ------- |
| =        | Assignment operator
| ++       | Increment, `x++` is equivalent to `x = x + 1`. When this operator is used for an array index, the variable value is obtained before the auto increment operation
| - -       | Decrement, i.e. `x--` is equivalent to `x = x - 1`. When this operator is used for an array index, the variable value is obtained before the auto decrement operation
| +=       | Addition assignment operator, for example `x += 3` corresponds to `x = x + 3`
| -=       | Subtraction assignment operator, for example `x -= 3` corresponds to `x = x - 3`
{:.table .table-sm .table-bordered .table-nohead }


## Mathematical functions ## {#mathematical_functions}

The following mathematical functions (Abs, Clip3, Clip1, Min, Max, Round2
and Round2Signed) are defined as follows:

<img src="assets/images/formula-abs.corrected.png" class="img-fluid" alt="">

<img src="assets/images/formula-clip1.svg.png" class="img-fluid" alt="">

<img src="assets/images/formula-clip3.svg.png" class="img-fluid" alt="">

<img src="assets/images/formula-min.svg.png" class="img-fluid" alt="">

<img src="assets/images/formula-max.svg.png" class="img-fluid" alt="">

<img src="assets/images/formula-round2.svg.png" class="img-fluid" alt="">

<img src="assets/images/formula-round2signed.svg.png" class="img-fluid" alt="">

{% comment %}
<h1>ASCIIMath formula depictions</h1>

"Abs"(x)={[x;,x >= 0],[-x;,x<0]}
"Clip3"(x,y,z)={[x;,z < x],[y;,z>y],[z;,otherwise]}
"Clip1(x)"="Clip3"(0,2^("BitDepth")-1,x)
"Min"(x,y)={[x;,x<=y],[y;,x>y]}
"Max"(x,y)={[x;,x>=y],[y;,x<y]}
"Round2"(x,n)=|__(x+(2^(n-1)))/(2^n)__|
"Round2Signed"(x,n)={["Round2"(x,n);, x >= 0], [-"Round2"(-x,n);, x < 0]}

{% endcomment %}

The definition of Round2 uses standard mathematical power and division
operations, not integer operations. An equivalent definition using integer
operations is:

~~~~~ c
Round2( x, n ) {
  if ( n == 0 )
    return x
  return ( x + ( 1 << (n - 1) ) ) >> n
}
~~~~~

The FloorLog2(x) function is defined to be the floor of the base 2 logarithm of
the input x.

The input x will always be an integer, and will always be greater than or equal
to 1.

This function extracts the location of the most significant bit in x.

An equivalent definition (using the pseudo-code notation introduced in the
following section) is:

~~~~~ c
FloorLog2( x ) {
  s = 0
  while ( x != 0 ) {
    x = x >> 1
    s++
  }
  return s - 1
}
~~~~~

The CeilLog2(x) function is defined to be the ceiling of the base 2 logarithm of
the input x (when x is 0, it is defined to return 0).

The input x will always be an integer, and will always be greater than or equal
to 0.

This function extracts the number of bits needed to code a value in the
range 0 to x-1.

An equivalent definition (using the pseudo-code notation introduced in the
following section) is:

~~~~~ c
CeilLog2( x ) {
  if ( x < 2 )
    return 0
  i = 1
  p = 2
  while ( p < x ) {
    i++
    p = p << 1
  }
  return i
}
~~~~~

## Method of describing bitstream syntax ## {#method_of_describing_bitstream_syntax}

The description style of the syntax is similar to the C programming language.
Syntax elements in the bitstream are represented in bold type. Each syntax
element is described by its name (using only lower case letters with
underscore characters) and a descriptor for its method of coded
representation. The decoding process behaves according to the value of the
syntax element and to the values of previously decoded syntax elements. When a
value of a syntax element is used in the syntax tables or the text, it appears
in regular (i.e. not bold) type. If the value of a syntax element is being
computed (e.g. being written with a default value instead of being coded in
the bitstream), it also appears in regular type (e.g. tile_size_minus_1).

In some cases the syntax tables may use the values of other variables derived
from syntax elements values. Such variables appear in the syntax tables, or
text, named by a mixture of lower case and upper case letter and without any
underscore characters. Variables starting with an upper case letter are
derived for the decoding of the current syntax structure and all depending
syntax structures. These variables may be used in the decoding process for
later syntax structures. Variables starting with a lower case letter are only
used within the process from which they are derived. (Single character variables
are allowed.)

Constant values appear in all upper case letters with underscore characters
(e.g. MI_SIZE).

Constant lookup tables appear as words (with the first letter of each word in
upper case, and remaining letters in lower case) separated with underscore
characters (e.g. Block_Width[...]).

Hexadecimal notation, indicated by prefixing the hexadecimal number by `0x`,
may be used when the number of bits is an integer multiple of 4. For example,
`0x1a` represents a bit string `0001 1010`.

Binary notation is indicated by prefixing the binary number by `0b`. For
example, `0b00011010` represents a bit string `0001 1010`. Binary numbers may
include underscore characters to enhance readability. If present, the
underscore characters appear every 4 binary digits starting from the LSB. For
example, `0b11010` may also be written as `0b1_1010`.

A value equal to 0 represents a FALSE condition in a test statement. The
value TRUE is represented by any value not equal to 0.

The following table lists examples of the syntax specification format. When
`syntax_element` appears (with bold face font), it specifies that this syntax
element is parsed from the bitstream.


| --------------------------------------------------------- | ---------------- |
|                                                           | **Type**
| /* A statement can be a syntax element with associated    |
| descriptor or can be an expression used to specify its    |
| existence, type, and value, as in the following           |
| examples */                                               |
|                                                           |
| @@syntax_element                                          | f(1)
|
| /* A group of statements enclosed in brackets is a
| compound statement and is treated functionally as a single
| statement. */
|
| {
|     statement
|     ...
| }
|
| /* A "while" structure specifies that the statement is
| to be evaluated repeatedly while the condition remains
| true. */
|
| while ( condition )
|     statement
|
| /* A "do .. while" structure executes the statement once,
| and then tests the condition. It repeatedly evaluates the
| statement while the condition remains true. */
|
| do
|     statement
| while ( condition )
|
| /* An "if .. else" structure tests the condition first. If
| it is true, the primary statement is evaluated. Otherwise,
| the alternative statement is evaluated. If the alternative
| statement is unnecessary to be evaluated, the "else" and
| corresponding alternative statement can be omitted. */
|
| if ( condition )
|     primary statement
| else
|     alternative statement
|
| /* A "for" structure evaluates the initial statement at the
| beginning then tests the condition. If it is true, the primary
| and subsequent statements are evaluated until the condition
| becomes false. */
|
| for ( initial statement; condition; subsequent statement )
|     primary statement
|
| /* The return statement in a syntax structure specifies
| that the parsing of the syntax structure will be terminated
| without processing any additional information after this stage.
| When a value immediately follows a return statement, this value
| shall also be returned as the output of this syntax structure. */
|
| return x
{:.syntax }


## Functions ## {#functions}

Bitstream functions used for syntax description are specified in this section.

Other functions are included in the syntax tables. The convention is that a
section is called syntax if it causes syntax elements to be read from the
bitstream, either directly or indirectly through subprocesses. The remaining
sections are called functions.

The specification of these functions makes use of a bitstream position
indicator. This bitstream position indicator locates the position of the bit
that is going to be read next.

**get_position( ):** Return the value of the bitstream position indicator.

**init_symbol( sz ):** Initialize the arithmetic decode process for the Symbol
decoder with a size of sz bytes as specified in [section 8.2.2][].

**exit_symbol( ):** Exit the arithmetic decode process as described in
[section 8.2.4][] (this includes reading trailing bits).


## Descriptors ## {#descriptors}

### General ### {#general}

The following descriptors specify the parsing of syntax elements. Lower case
descriptors specify syntax elements that are represented by an integer
number of bits in the bitstream; upper case descriptors specify syntax elements
that are represented by arithmetic coding.


### f(n) ### {#f(n)}

Unsigned n-bit number appearing directly in the bitstream. The bits are read
from high to low order.  The parsing process specified in [section 8.1][] is
invoked and the syntax element is set equal to the return value.


### uvlc() ### {#uvlc()}

Variable length unsigned number appearing directly in the bitstream.
The parsing process for this descriptor is specified below:

| --------------------------------------------------------- | ---------------- |
| uvlc() {                                                  | **Type**
|     leadingZeros = 0                                      |
|     while ( 1 ) {                                          |
|         @@done                                            | f(1)
|         if ( done )                                       |
|             break                                         |
|         leadingZeros++                                    |
|     }                                                     |
|     if ( leadingZeros >\= 32 ) {                           |
|         return ( 1 \<\< 32 ) - 1                            |
|     }                                                     |
|     @@value                                               | f(leadingZeros)
|     return value + ( 1 \<\< leadingZeros ) - 1
| }
{:.syntax }


### le(n) ### {#le(n)}

Unsigned little-endian n-byte number appearing directly in the bitstream.
The parsing process for this descriptor is specified below:

| --------------------------------------------------------- | ---------------- |
| le(n) {                                                   | **Type**
|     t = 0                                                 |
|     for ( i = 0; i < n; i++) {                             |
|         @@byte                                            | f(8)
|         t += ( byte \<\< ( i * 8 ) )
|     }
|     return t
| }
{:.syntax }

**Note:** This syntax element will only be present when the bitstream position
is byte aligned.
{:.alert .alert-info }


### leb128() ### {#leb128()}

Unsigned integer represented by a variable number of little-endian bytes.

**Note:** This syntax element will only be present when the bitstream position
is byte aligned.
{:.alert .alert-info }

In this encoding, the most significant bit of each byte is equal to 1 to signal
that more bytes should be read, or equal to 0 to signal the end of the encoding.

A variable Leb128Bytes is set equal to the number of bytes read during this
process.

The parsing process for this descriptor is specified below:

| --------------------------------------------------------- | ---------------- |
| leb128() {                                                | **Type**
|     value = 0                                             |
|     Leb128Bytes = 0                                       |
|     for ( i = 0; i < 8; i++ ) {                             |
|         @@leb128_byte                                     | f(8)
|         value \|= ( (leb128_byte & 0x7f) \<\< (i*7) )
|         Leb128Bytes += 1
|         if ( !(leb128_byte & 0x80) ) {
|             break
|         }
|     }
|     return value
| }
{:.syntax }

{% comment %}
Note escaped pipe character in above syntax table.
{% endcomment %}

It is a requirement of bitstream conformance that the value returned from the
leb128 parsing process is less than or equal to (1 \<\< 32) - 1.

**leb128_byte** contains 8 bits read from the bitstream.  The bottom 7 bits are
used to compute the variable value. The most significant bit is used to indicate
that there are more bytes to be read.

It is a requirement of bitstream conformance that the most significant bit of
leb128_byte is equal to 0 if i is equal to 7. (This ensures that this syntax
descriptor never uses more than 8 bytes.)

**Note:** There are multiple ways of encoding the same value depending on how
many leading zero bits are encoded. There is no requirement that this syntax
descriptor uses the most compressed representation. This can be useful for
encoder implementations by allowing a fixed amount of space to be filled in
later when the value becomes known.
{:.alert .alert-info }


### su(n) ### {#su(n)}

Signed integer converted from an n bits unsigned integer in the bitstream.
(The unsigned integer corresponds to the bottom n bits of the signed integer.)
The parsing process for this descriptor is specified below:

| --------------------------------------------------------- | ---------------- |
| su(n) {                                                   | **Type**
|     @@value                                               | f(n)
|     signMask = 1 \<\< (n - 1)
|     if ( value & signMask )
|         value = value - 2 * signMask
|     return value
| }
{:.syntax }


### ns(n) ### {#ns(n)}

Unsigned encoded integer with maximum number of values n (i.e. output in range
0..n-1).

This descriptor is similar to f(CeilLog2(n)), but reduces wastage incurred
when encoding non-power of two value ranges by encoding 1 fewer bits for the
lower part of the value range. For example, when n is equal to 5, the encodings
are as follows (full binary encodings are also presented for comparison):

| Value | Full binary encoding | ns(n) encoding |
|:-----:|:--------------------:|:--------------:|
|     0 |                  000 |             00 |
|     1 |                  001 |             01 |
|     2 |                  010 |             10 |
|     3 |                  011 |            110 |
|     4 |                  100 |            111 |
{:.table .table-sm .table-bordered .table-striped }

The parsing process for this descriptor is specified as:

| --------------------------------------------------------- | ---------------- |
| ns( n ) {                                                 | **Type**
|     w = FloorLog2(n) + 1                                  |
|     m = (1 \<\< w) - n                                      |
|     @@v                                                   | f(w - 1)
|     if ( v < m )                                          |
|         return v                                          |
|     @@extra_bit                                           | f(1)
|     return (v \<\< 1) - m + extra_bit
| }
{:.syntax }

The abbreviation ns stands for non-symmetric. This encoding is non-symmetric
because the values are not all coded with the same number of bits.


### L(n) ### {#l(n)}

Unsigned arithmetic encoded n-bit number encoded as n flags (a "literal"). The
flags are read from high to low order.  The syntax element is set equal to the
return value of read_literal( n ) (see [section 8.2.5][] for a specification of
this process).


### S() ### {#s()}

An arithmetic encoded symbol coded from a small alphabet of at most 16 entries.

The symbol is decoded based on a context sensitive CDF (see [section 8.3][] for
the specification of this process).


### NS(n) ### {#ns(n)}

Unsigned arithmetic encoded integer with maximum number of values n (i.e. output
in range 0..n-1).

This descriptor is the same as ns(n) except the underlying bits are coded
arithmetically.

The parsing process for this descriptor is specified as:

| --------------------------------------------------------- | ---------------- |
| NS( n ) {                                                 | **Type**
|     w = FloorLog2(n) + 1                                  |
|     m = (1 \<\< w) - n                                      |
|     @@v                                                   | L(w - 1)
|     if ( v < m )                                          |
|         return v                                          |
|     @@extra_bit                                           | L(1)
|     return (v \<\< 1) - m + extra_bit
| }
{:.syntax }

# Syntax structures # {#syntax_structures}

## General ## {#general}

This section presents the syntax structures in a tabular form. The meaning of
each of the syntax elements is presented in [Section 6][].

## Low overhead bitstream format ## {#low_overhead_bitstream_format}

This specification defines a low-overhead bitstream format as a sequence of the OBU syntactical elements defined in this section.
When using this format, obu_has_size_field must be equal to 1.
For applications requiring a format where it is easier to skip through frames or temporal units,
a length-delimited bitstream format is defined in Annex B.

Derived specifications, such as container formats enabling storage of AV1 videos together with audio or
subtitles, should indicate which of these formats they rely on.
Other methods of packing OBUs into a bitstream format are also allowed.

## OBU syntax ## {#obu_syntax}

### General OBU syntax ### {#general_obu_syntax}

| --------------------------------------------------------- | ---------------- |
| open_bitstream_unit( sz ) {                               | **Type**
|     obu_header()                                          |
|     if ( obu_has_size_field ) {                           |
|         @@obu_size                                        | leb128()
|     } else {
|         obu_size = sz - 1 - obu_extension_flag
|     }
|     startPosition = get_position( )
|     if ( obu_type != OBU_SEQUENCE_HEADER &&
|          obu_type != OBU_TEMPORAL_DELIMITER &&
|          OperatingPointIdc != 0 &&
|          obu_extension_flag == 1 )
|     {
|         inTemporalLayer = (OperatingPointIdc \>\> temporal_id ) & 1
|         inSpatialLayer = (OperatingPointIdc \>\> ( spatial_id + 8 ) ) & 1
|         if ( !inTemporalLayer \|\| ! inSpatialLayer ) {
|             drop_obu( )
|             return
|         }
|     }
|     if ( obu_type == OBU_SEQUENCE_HEADER )
|         sequence_header_obu( )
|     else if ( obu_type == OBU_TEMPORAL_DELIMITER )
|         temporal_delimiter_obu( )
|     else if ( obu_type == OBU_FRAME_HEADER )
|         frame_header_obu( )
|     else if ( obu_type == OBU_REDUNDANT_FRAME_HEADER )
|         frame_header_obu( )
|     else if ( obu_type == OBU_TILE_GROUP )
|         tile_group_obu( obu_size )
|     else if ( obu_type == OBU_METADATA )
|         metadata_obu( )
|     else if ( obu_type == OBU_FRAME )
|         frame_obu( obu_size )
|     else if ( obu_type == OBU_TILE_LIST )
|         tile_list_obu( )
|     else if ( obu_type == OBU_PADDING )
|         padding_obu( )
|     else
|         reserved_obu( )
|     currentPosition = get_position( )
|     payloadBits = currentPosition - startPosition
|     if ( obu_size > 0 && obu_type != OBU_TILE_GROUP &&
|          obu_type != OBU_TILE_LIST &&
|          obu_type != OBU_FRAME ) {
|         trailing_bits( obu_size * 8 - payloadBits )
|     }
| }
{:.syntax }


### OBU header syntax ### {#obu_header_syntax}

| --------------------------------------------------------- | ---------------- |
| obu_header() {                                            | **Type**
|     @@obu_forbidden_bit                                   | f(1)
|     @@obu_type                                            | f(4)
|     @@obu_extension_flag                                  | f(1)
|     @@obu_has_size_field                                 | f(1)
|     @@obu_reserved_1bit                                   | f(1)
|     if ( obu_extension_flag == 1 )
|         obu_extension_header()
| }
{:.syntax }


### OBU extension header syntax ### {#obu_extension_header_syntax}

| --------------------------------------------------------- | ---------------- |
| obu_extension_header() {                                  | **Type**
|     @@temporal_id                                         | f(3)
|     @@spatial_id                                          | f(2)
|     @@extension_header_reserved_3bits                     | f(3)
| }
{:.syntax }


### Trailing bits syntax ### {#trailing_bits_syntax}

| --------------------------------------------------------- | ---------------- |
| trailing_bits( nbBits ) {                                 | **Type**
|     @@trailing_one_bit                                    | f(1)
|     nbBits\-\-
|     while ( nbBits > 0 ) {
|         @@trailing_zero_bit                               | f(1)
|         nbBits\-\-
|     }
| }
{:.syntax }

### Byte alignment syntax ### {#byte_alignment_syntax}

| --------------------------------------------------------- | ---------------- |
| byte_alignment( ) {                                       | **Type**
|     while ( get_position( ) & 7 )                         |
|         @@zero_bit                                        | f(1)
| }
{:.syntax }


## Reserved OBU syntax ## {#reserved_obu_syntax}

| --------------------------------------------------------- | ---------------- |
| reserved_obu( ) {                                      | **Type**
| }
{:.syntax }

**Note:** Reserved OBUs do not have a defined syntax. The obu_type reserved
values are reserved for future use. Decoders should ignore the entire OBU if
they do not understand the obu_type. Ignoring the OBU can be done based on
obu_size. The last byte of the valid content of the payload data for this OBU type
is considered to be the last byte that is not equal to zero.
This rule is to prevent the dropping of valid bytes by systems that
interpret trailing zero bytes as a continuation of the trailing bits in an OBU.
This implies that when any payload data is present for this OBU type,
at least one byte of the payload data (including the trailing bit) shall not be equal to 0.
{:.alert .alert-info }

## Sequence header OBU syntax ## {#sequence_header_obu_syntax}

### General sequence header OBU syntax ### {#general_sequence_header_obu_syntax}

| --------------------------------------------------------- | ---------------- |
| sequence_header_obu( ) {                                  | **Type**
|     @@seq_profile                                         | f(3)
|     @@still_picture                                       | f(1)
|     @@reduced_still_picture_header                        | f(1)
|     if ( reduced_still_picture_header ) {
|         timing_info_present_flag = 0
|         decoder_model_info_present_flag = 0
|         initial_display_delay_present_flag = 0
|         operating_points_cnt_minus_1 = 0
|         operating_point_idc[ 0 ] = 0
|         @@seq_level_idx[ 0 ]                              | f(5)
|         seq_tier[ 0 ] = 0
|         decoder_model_present_for_this_op[ 0 ] = 0
|         initial_display_delay_present_for_this_op[ 0 ] = 0
|     } else {
|         @@timing_info_present_flag                        | f(1)
|         if ( timing_info_present_flag ) {                 |
|             timing_info( )                                |
|             @@decoder_model_info_present_flag             | f(1)
|             if ( decoder_model_info_present_flag ) {
|                 decoder_model_info( )
|             }
|         } else {
|             decoder_model_info_present_flag = 0
|         }
|         @@initial_display_delay_present_flag              | f(1)
|         @@operating_points_cnt_minus_1                    | f(5)
|         for ( i = 0; i <\= operating_points_cnt_minus_1; i++ ) {
|             @@operating_point_idc[ i ]                    | f(12)
|             @@seq_level_idx[ i ]                          | f(5)
|             if ( seq_level_idx[ i ] > 7 ) {
|                 @@seq_tier[ i ]                           | f(1)
|             } else {
|                 seq_tier[ i ] = 0
|             }
|             if ( decoder_model_info_present_flag ) {
|                 @@decoder_model_present_for_this_op[ i ]   | f(1)
|                 if ( decoder_model_present_for_this_op[ i ] ) {
|                     operating_parameters_info( i )
|                 }
|             } else {
|                 decoder_model_present_for_this_op[ i ] = 0
|             }
|             if ( initial_display_delay_present_flag ) {
|                 @@initial_display_delay_present_for_this_op[ i ] | f(1)
|                 if ( initial_display_delay_present_for_this_op[ i ] ) {
|                     @@initial_display_delay_minus_1[ i ]         | f(4)
|                 }
|             }
|         }
|     }
|     operatingPoint = choose_operating_point( )
|     OperatingPointIdc = operating_point_idc[ operatingPoint ]
|     @@frame_width_bits_minus_1                            | f(4)
|     @@frame_height_bits_minus_1                           | f(4)
|     n = frame_width_bits_minus_1 + 1                      |
|     @@max_frame_width_minus_1                             | f(n)
|     n = frame_height_bits_minus_1 + 1                     |
|     @@max_frame_height_minus_1                            | f(n)
|     if ( reduced_still_picture_header )
|         frame_id_numbers_present_flag = 0
|     else
|         @@frame_id_numbers_present_flag                   | f(1)
|     if ( frame_id_numbers_present_flag ) {                |
|         @@delta_frame_id_length_minus_2                    | f(4)
|         @@additional_frame_id_length_minus_1               | f(3)
|     }                                                     |
|     @@use_128x128_superblock                              | f(1)
|     @@enable_filter_intra                                 | f(1)
|     @@enable_intra_edge_filter                            | f(1)
|     if ( reduced_still_picture_header ) {
|         enable_interintra_compound = 0
|         enable_masked_compound = 0
|         enable_warped_motion = 0
|         enable_dual_filter = 0
|         enable_order_hint = 0
|         enable_jnt_comp = 0
|         enable_ref_frame_mvs = 0
|         seq_force_screen_content_tools = SELECT_SCREEN_CONTENT_TOOLS
|         seq_force_integer_mv = SELECT_INTEGER_MV
|         OrderHintBits = 0
|     } else {
|         @@enable_interintra_compound                          | f(1)
|         @@enable_masked_compound                              | f(1)
|         @@enable_warped_motion                                | f(1)
|         @@enable_dual_filter                                  | f(1)
|         @@enable_order_hint                                   | f(1)
|         if ( enable_order_hint ) {                            |
|             @@enable_jnt_comp                                 | f(1)
|             @@enable_ref_frame_mvs                            | f(1)
|         } else {                                              |
|             enable_jnt_comp = 0                               |
|             enable_ref_frame_mvs = 0                          |
|         }                                                     |
|         @@seq_choose_screen_content_tools                     | f(1)
|         if ( seq_choose_screen_content_tools ) {              |
|             seq_force_screen_content_tools = SELECT_SCREEN_CONTENT_TOOLS |
|         } else {                                              |
|             @@seq_force_screen_content_tools                  | f(1)
|         }                                                     |
|                                                               |
|         if ( seq_force_screen_content_tools > 0 ) {           |
|             @@seq_choose_integer_mv                           | f(1)
|             if ( seq_choose_integer_mv ) {                    |
|                 seq_force_integer_mv = SELECT_INTEGER_MV      |
|             } else {                                          |
|                 @@seq_force_integer_mv                        | f(1)
|             }                                                 |
|         } else {                                              |
|             seq_force_integer_mv = SELECT_INTEGER_MV          |
|         }                                                     |
|         if ( enable_order_hint ) {                            |
|             @@order_hint_bits_minus_1                          | f(3)
|             OrderHintBits = order_hint_bits_minus_1 + 1        |
|         } else {                                              |
|             OrderHintBits = 0                                 |
|         }                                                     |
|     }
|     @@enable_superres                                     | f(1)
|     @@enable_cdef                                         | f(1)
|     @@enable_restoration                                  | f(1)
|     color_config( )                                       |
|     @@film_grain_params_present                           | f(1)
| }
{:.syntax }


### Color config syntax ### {#color_config_syntax}

| --------------------------------------------------------- | ---------------- |
| color_config( ) {                                         | **Type**
|     @@high_bitdepth                                       | f(1)
|     if ( seq_profile == 2 && high_bitdepth ) {
|         @@twelve_bit                                      | f(1)
|         BitDepth = twelve_bit ? 12 : 10
|     } else if ( seq_profile <\= 2 ) {
|         BitDepth = high_bitdepth ? 10 : 8
|     }
|     if ( seq_profile == 1 ) {
|         mono_chrome = 0
|     } else {
|         @@mono_chrome                                     | f(1)
|     }
|     NumPlanes = mono_chrome ? 1 : 3
|     @@color_description_present_flag                      | f(1)
|     if ( color_description_present_flag ) {
|         @@color_primaries                                 | f(8)
|         @@transfer_characteristics                        | f(8)
|         @@matrix_coefficients                             | f(8)
|     } else {
|         color_primaries = CP_UNSPECIFIED
|         transfer_characteristics = TC_UNSPECIFIED
|         matrix_coefficients = MC_UNSPECIFIED
|     }
|     if ( mono_chrome ) {
|         @@color_range                                     | f(1)
|         subsampling_x = 1
|         subsampling_y = 1
|         chroma_sample_position = CSP_UNKNOWN
|         separate_uv_delta_q = 0
|         return
|     } else if ( color_primaries == CP_BT_709 &&
|                 transfer_characteristics == TC_SRGB &&
|                 matrix_coefficients == MC_IDENTITY ) {
|         color_range = 1
|         subsampling_x = 0
|         subsampling_y = 0
|     } else {
|         @@color_range                                     | f(1)
|         if ( seq_profile == 0 ) {
|             subsampling_x = 1
|             subsampling_y = 1
|         } else if ( seq_profile == 1 ) {
|             subsampling_x = 0
|             subsampling_y = 0
|         } else {
|             if ( BitDepth == 12 ) {
|                 @@subsampling_x                           | f(1)
|                 if ( subsampling_x )
|                     @@subsampling_y                       | f(1)
|                 else
|                     subsampling_y = 0
|             } else {
|                 subsampling_x = 1
|                 subsampling_y = 0
|             }
|         }
|         if ( subsampling_x && subsampling_y ) {
|             @@chroma_sample_position                      | f(2)
|         }
|     }
|     @@separate_uv_delta_q                                 | f(1)
| }
{:.syntax }


### Timing info syntax ### {#timing_info_syntax}

| --------------------------------------------------------- | ---------------- |
| timing_info( ) {                                          | **Type**
|     @@num_units_in_display_tick                           | f(32)
|     @@time_scale                                          | f(32)
|     @@equal_picture_interval                              | f(1)
|     if ( equal_picture_interval )
|        @@num_ticks_per_picture_minus_1                     | uvlc()
| }
{:.syntax }

### Decoder model info syntax ### {#decoder_model_info_syntax}

| --------------------------------------------------------- | ---------------- |
| decoder_model_info( ) {                                   | **Type**
|     @@buffer_delay_length_minus_1                         | f(5)
|     @@num_units_in_decoding_tick                          | f(32)
|     @@buffer_removal_time_length_minus_1                  | f(5)
|     @@frame_presentation_time_length_minus_1              | f(5)
| }
{:.syntax }

### Operating parameters info syntax ### {#operating_parameters_info_syntax}

| --------------------------------------------------------- | ---------------- |
| operating_parameters_info( op ) {                         | **Type**
|     n = buffer_delay_length_minus_1 + 1
|     @@decoder_buffer_delay[ op ]                          | f(n)
|     @@encoder_buffer_delay[ op ]                          | f(n)
|     @@low_delay_mode_flag[ op ]                           | f(1)
| }
{:.syntax }


## Temporal delimiter obu syntax ## {#temporal_delimiter_obu_syntax}

| --------------------------------------------------------- | ---------------- |
| temporal_delimiter_obu( ) {                               | **Type**
|     SeenFrameHeader = 0
| }
{:.syntax }

**Note:** The temporal delimiter has an empty payload.
{:.alert .alert-info }


## Padding OBU syntax ## {#padding_obu_syntax}

| --------------------------------------------------------- | ---------------- |
| padding_obu( ) {                                          | **Type**
|     for ( i = 0; i < obu_padding_length; i++ )            |
|         @@obu_padding_byte                                | f(8)
| }
{:.syntax }

**Note:** obu_padding_length is not coded in the bitstream but can be computed
based on obu_size minus the number of trailing bytes.
In practice, though, since this is
padding data meant to be skipped, decoders do not need to determine either
that length nor the number of trailing bytes. They can ignore the entire OBU.
Ignoring the OBU can be done based on obu_size.
The last byte of the valid content of the payload data for this OBU type
is considered to be the last byte that is not equal to zero.
This rule is to prevent the dropping of valid bytes by systems that
interpret trailing zero bytes as a continuation of the trailing bits in an OBU.
This implies that when any payload data is present for this OBU type,
at least one byte of the payload data (including the trailing bit) shall not be equal to 0.
{:.alert .alert-info }

## Metadata OBU syntax ## {#metadata_obu_syntax}

### General metadata OBU syntax ### {#general_metadata_obu_syntax}

| --------------------------------------------------------- | ---------------- |
| metadata_obu( ) {                                         | **Type**
|     @@metadata_type                                       | leb128()
|     if ( metadata_type == METADATA_TYPE_ITUT_T35 )
|         metadata_itut_t35( )
|     else if ( metadata_type == METADATA_TYPE_HDR_CLL )
|         metadata_hdr_cll( )
|     else if ( metadata_type == METADATA_TYPE_HDR_MDCV )
|         metadata_hdr_mdcv( )
|     else if ( metadata_type == METADATA_TYPE_SCALABILITY )
|         metadata_scalability( )
|     else if ( metadata_type == METADATA_TYPE_TIMECODE )
|         metadata_timecode( )
| }
{:.syntax }

**Note:**  The exact syntax of metadata_obu is not defined
in this specification when metadata_type is equal to
a value reserved for future use or a user private value.
Decoders should ignore the entire OBU if they do not understand the metadata_type.
The last byte of the valid content of the data is
considered to be the last byte that is not equal to zero. This rule is to
prevent the dropping of valid bytes by systems that interpret trailing zero
bytes as a padding continuation of the trailing bits in an OBU.
This implies that when any payload data is present for this OBU type,
at least one byte of the payload data (including the trailing bit) shall not be equal to 0.
{:.alert .alert-info }


### Metadata ITUT T35 syntax ### {#metadata_itut_t35_syntax}

| --------------------------------------------------------- | ---------------- |
| metadata_itut_t35( ) {                                    | **Type**
|     @@itu_t_t35_country_code                              | f(8)
|     if ( itu_t_t35_country_code == 0xFF ) {
|         @@itu_t_t35_country_code_extension_byte           | f(8)
|     }
|     @@itu_t_t35_payload_bytes
| }
{:.syntax }

**Note:**  The exact syntax of itu_t_t35_payload_bytes is not defined
in this specification. External
specifications can define the syntax.
Decoders should ignore the entire OBU if they do not understand it.
The last byte of the valid content of the data is
considered to be the last byte that is not equal to zero. This rule is to
prevent the dropping of valid bytes by systems that interpret trailing zero
bytes as a padding continuation of the trailing bits in an OBU.
This implies that when any payload data is present for this OBU type,
at least one byte of the payload data (including the trailing bit) shall not be equal to 0.
{:.alert .alert-info }


### Metadata high dynamic range content light level syntax ### {#metadata_high_dynamic_range_content_light_level_syntax}

| --------------------------------------------------------- | ---------------- |
| metadata_hdr_cll( ) {                                     | **Type**
|     @@max_cll                                             | f(16)
|     @@max_fall                                            | f(16)
| }
{:.syntax }


### Metadata high dynamic range mastering display color volume syntax ### {#metadata_high_dynamic_range_mastering_display_color_volume_syntax}

| --------------------------------------------------------- | ---------------- |
| metadata_hdr_mdcv( ) {                                    | **Type**
|     for ( i = 0; i < 3; i++ ) {                           |
|         @@primary_chromaticity_x[ i ]                     | f(16)
|         @@primary_chromaticity_y[ i ]                     | f(16)
|     }
|     @@white_point_chromaticity_x                          | f(16)
|     @@white_point_chromaticity_y                          | f(16)
|     @@luminance_max                                       | f(32)
|     @@luminance_min                                       | f(32)
| }
{:.syntax }


### Metadata scalability syntax ### {#metadata_scalability_syntax}

| --------------------------------------------------------- | ---------------- |
| metadata_scalability( ) {                                 | **Type**
|     @@scalability_mode_idc                                | f(8)
|     if ( scalability_mode_idc == SCALABILITY_SS )
|         scalability_structure( )
| }
{:.syntax }

### Scalability structure syntax ### {#scalability_structure_syntax}

| --------------------------------------------------------- | ---------------- |
| scalability_structure( ) {                                | **Type**
|     @@spatial_layers_cnt_minus_1                           | f(2)
|     @@spatial_layer_dimensions_present_flag               | f(1)
|     @@spatial_layer_description_present_flag              | f(1)
|     @@temporal_group_description_present_flag             | f(1)
|     @@scalability_structure_reserved_3bits                | f(3)
|     if ( spatial_layer_dimensions_present_flag ) {
|         for ( i = 0; i <\= spatial_layers_cnt_minus_1 ; i++ ) {
|             @@spatial_layer_max_width[ i ]                | f(16)
|             @@spatial_layer_max_height[ i ]               | f(16)
|         }
|     }
|     if ( spatial_layer_description_present_flag ) {
|         for ( i = 0; i <\= spatial_layers_cnt_minus_1; i++ )
|             @@spatial_layer_ref_id[ i ]                   | f(8)
|     }
|     if ( temporal_group_description_present_flag ) {
|         @@temporal_group_size                             | f(8)
|         for ( i = 0; i < temporal_group_size; i++ ) {
|             @@temporal_group_temporal_id[ i ]             | f(3)
|             @@temporal_group_temporal_switching_up_point_flag[ i ]     | f(1)
|             @@temporal_group_spatial_switching_up_point_flag[ i ]      | f(1)
|             @@temporal_group_ref_cnt[ i ]                              | f(3)
|             for ( j = 0; j < temporal_group_ref_cnt[ i ]; j++ ) {
|                 @@temporal_group_ref_pic_diff[ i ][ j ]                | f(8)
|             }
|         }
|     }
| }
{:.syntax }

### Metadata timecode syntax ### {#metadata_timecode_syntax}

| --------------------------------------------------------- | ---------------- |
| metadata_timecode( ) {                                    | **Type**
|     @@counting_type                                       | f(5)
|     @@full_timestamp_flag                                 | f(1)
|     @@discontinuity_flag                                  | f(1)
|     @@cnt_dropped_flag                                    | f(1)
|     @@n_frames                                            | f(9)
|     if ( full_timestamp_flag ) {
|         @@seconds_value                                   | f(6)
|         @@minutes_value                                   | f(6)
|         @@hours_value                                     | f(5)
|     } else {
|         @@seconds_flag                                    | f(1)
|         if ( seconds_flag ) {
|             @@seconds_value                               | f(6)
|             @@minutes_flag                                | f(1)
|             if ( minutes_flag ) {
|                 @@minutes_value                           | f(6)
|                 @@hours_flag                              | f(1)
|                 if ( hours_flag ) {
|                     @@hours_value                         | f(5)
|                 }
|             }
|         }
|     }
|     @@time_offset_length                                  | f(5)
|     if ( time_offset_length > 0 ) {
|         @@time_offset_value                               | f(time_offset_length)
|     }
| }
{:.syntax }

## Frame header OBU syntax ## {#frame_header_obu_syntax}

### General frame header OBU syntax ### {#general_frame_header_obu_syntax}

| --------------------------------------------------------- | ---------------- |
| frame_header_obu( ) {                                     | **Type**
|     if ( SeenFrameHeader == 1 ) {
|         frame_header_copy()
|     } else {
|         SeenFrameHeader = 1
|         uncompressed_header( )
|         if ( show_existing_frame ) {
|             decode_frame_wrapup( )
|             SeenFrameHeader = 0
|         } else {
|             TileNum = 0
|             SeenFrameHeader = 1
|         }
|     }
| }
{:.syntax }

### Uncompressed header syntax ### {#uncompressed_header_syntax}

| --------------------------------------------------------- | ---------------- |
| uncompressed_header( ) {                                  | **Type**
|     if ( frame_id_numbers_present_flag ) {
|         idLen = ( additional_frame_id_length_minus_1 +
|                   delta_frame_id_length_minus_2 + 3 )
|     }
|     allFrames = (1 \<\< NUM_REF_FRAMES) - 1
|     if ( reduced_still_picture_header ) {
|         show_existing_frame = 0
|         frame_type = KEY_FRAME
|         FrameIsIntra = 1
|         show_frame = 1
|         showable_frame = 0
|     } else {
|         @@show_existing_frame                                 | f(1)
|         if ( show_existing_frame == 1 ) {
|             @@frame_to_show_map_idx                           | f(3)
|             if ( decoder_model_info_present_flag && !equal_picture_interval ) {
|                 temporal_point_info( )
|             }
|             refresh_frame_flags = 0
|             if ( frame_id_numbers_present_flag ) {
|                 @@display_frame_id                            | f(idLen)
|             }
|             frame_type = RefFrameType[ frame_to_show_map_idx ]
|             if ( frame_type == KEY_FRAME ) {
|                 refresh_frame_flags = allFrames
|             }
|             if ( film_grain_params_present ) {
|                 load_grain_params( frame_to_show_map_idx )
|             }
|             return
|         }
|         @@frame_type                                          | f(2)
|         FrameIsIntra = (frame_type == INTRA_ONLY_FRAME \|\|
|                         frame_type == KEY_FRAME)
|         @@show_frame                                          | f(1)
|         if ( show_frame && decoder_model_info_present_flag && !equal_picture_interval ) {
|             temporal_point_info( )
|         }
|         if ( show_frame ) {
|             showable_frame = frame_type != KEY_FRAME
|         } else {
|             @@showable_frame                                  | f(1)
|         }
|         if ( frame_type == SWITCH_FRAME \|\|
|              ( frame_type == KEY_FRAME && show_frame ) )
|             error_resilient_mode = 1
|         else
|             @@error_resilient_mode                            | f(1)
|     }
|     if ( frame_type == KEY_FRAME && show_frame ) {
|         for ( i = 0; i < NUM_REF_FRAMES; i++ ) {
|             RefValid[ i ] = 0
|             RefOrderHint[ i ] = 0
|         }
|         for ( i = 0; i < REFS_PER_FRAME; i++ ) {
|             OrderHints[ LAST_FRAME + i ] = 0
|         }
|     }
|     @@disable_cdf_update                                  | f(1)
|     if ( seq_force_screen_content_tools == SELECT_SCREEN_CONTENT_TOOLS ) {
|         @@allow_screen_content_tools                      | f(1)
|     } else {
|         allow_screen_content_tools = seq_force_screen_content_tools
|     }
|     if ( allow_screen_content_tools ) {
|         if ( seq_force_integer_mv == SELECT_INTEGER_MV ) {
|             @@force_integer_mv                            | f(1)
|         } else {
|             force_integer_mv = seq_force_integer_mv
|         }
|     } else {
|         force_integer_mv = 0
|     }
|     if ( FrameIsIntra ) {
|         force_integer_mv = 1
|     }
|     if ( frame_id_numbers_present_flag ) {
|         PrevFrameID = current_frame_id
|         @@current_frame_id                                | f(idLen)
|         mark_ref_frames( idLen )
|     } else {
|         current_frame_id = 0
|     }
|     if ( frame_type == SWITCH_FRAME )
|         frame_size_override_flag = 1
|     else if ( reduced_still_picture_header )
|         frame_size_override_flag = 0
|     else
|         @@frame_size_override_flag                        | f(1)
|     @@order_hint                                          | f(OrderHintBits)
|     OrderHint = order_hint
|     if ( FrameIsIntra \|\| error_resilient_mode ) {
|         primary_ref_frame = PRIMARY_REF_NONE
|     } else {
|         @@primary_ref_frame                               | f(3)
|     }
|     if ( decoder_model_info_present_flag ) {
|         @@buffer_removal_time_present_flag                | f(1)
|         if ( buffer_removal_time_present_flag ) {
|             for ( opNum = 0; opNum <= operating_points_cnt_minus_1; opNum++ ) {
|                 if ( decoder_model_present_for_this_op[ opNum ] ) {
|                     opPtIdc = operating_point_idc[ opNum ]
|                     inTemporalLayer = ( opPtIdc \>\> temporal_id ) & 1
|                     inSpatialLayer = ( opPtIdc \>\> ( spatial_id + 8 ) ) & 1
|                     if ( opPtIdc == 0 \|\| ( inTemporalLayer && inSpatialLayer ) ) {
|                         n = buffer_removal_time_length_minus_1 + 1
|                         @@buffer_removal_time[ opNum ]             | f(n)
|                     }
|                 }
|             }
|         }
|     }
|     allow_high_precision_mv = 0
|     use_ref_frame_mvs = 0
|     allow_intrabc = 0
|     if ( frame_type == SWITCH_FRAME \|\|
|          ( frame_type == KEY_FRAME && show_frame ) ) {
|         refresh_frame_flags = allFrames
|     } else {
|         @@refresh_frame_flags                             | f(8)
|     }
|     if ( !FrameIsIntra \|\| refresh_frame_flags != allFrames ) {
|         if ( error_resilient_mode && enable_order_hint ) {
|             for ( i = 0; i < NUM_REF_FRAMES; i++) {
|                 @@ref_order_hint[ i ]                     | f(OrderHintBits)
|                 if ( ref_order_hint[ i ] != RefOrderHint[ i ] ) {
|                     RefValid[ i ] = 0
|                 }
|             }
|         }
|     }
|     if (  FrameIsIntra ) {
|         frame_size( )
|         render_size( )
|         if ( allow_screen_content_tools && UpscaledWidth == FrameWidth ) {
|             @@allow_intrabc                               | f(1)
|         }
|     } else {
|         if ( !enable_order_hint ) {
|           frame_refs_short_signaling = 0
|         } else {
|           @@frame_refs_short_signaling                    | f(1)
|           if ( frame_refs_short_signaling ) {
|             @@last_frame_idx                              | f(3)
|             @@gold_frame_idx                              | f(3)
|             set_frame_refs()
|           }
|         }
|         for ( i = 0; i < REFS_PER_FRAME; i++ ) {
|             if ( !frame_refs_short_signaling )
|               @@ref_frame_idx[ i ]                        | f(3)
|             if ( frame_id_numbers_present_flag ) {
|                 n = delta_frame_id_length_minus_2 + 2
|                 @@delta_frame_id_minus_1                  | f(n)
|                 DeltaFrameId = delta_frame_id_minus_1 + 1
|                 expectedFrameId[ i ] = ((current_frame_id + (1 \<\< idLen) -
|                                         DeltaFrameId ) % (1 \<\< idLen))
|             }
|         }
|         if ( frame_size_override_flag && !error_resilient_mode ) {
|             frame_size_with_refs( )
|         } else {
|             frame_size( )
|             render_size( )
|         }
|         if ( force_integer_mv ) {
|             allow_high_precision_mv = 0
|         } else {
|             @@allow_high_precision_mv                     | f(1)
|         }
|         read_interpolation_filter( )
|         @@is_motion_mode_switchable                       | f(1)
|         if ( error_resilient_mode \|\| !enable_ref_frame_mvs ) {
|             use_ref_frame_mvs = 0
|         } else {
|             @@use_ref_frame_mvs                           | f(1)
|         }
|         for ( i = 0; i < REFS_PER_FRAME; i++ ) {
|             refFrame = LAST_FRAME + i
|             hint = RefOrderHint[ ref_frame_idx[ i ] ]
|             OrderHints[ refFrame ] = hint
|             if ( !enable_order_hint ) {
|                 RefFrameSignBias[ refFrame ] = 0
|             } else {
|                 RefFrameSignBias[ refFrame ] = get_relative_dist( hint, OrderHint) > 0
|             }
|         }
|     }
|     if ( reduced_still_picture_header \|\| disable_cdf_update )
|         disable_frame_end_update_cdf = 1
|     else
|         @@disable_frame_end_update_cdf                    | f(1)
|     if ( primary_ref_frame == PRIMARY_REF_NONE ) {
|         init_non_coeff_cdfs( )
|         setup_past_independence( )
|     } else {
|         load_cdfs( ref_frame_idx[ primary_ref_frame ] )
|         load_previous( )
|     }
|     if ( use_ref_frame_mvs == 1 )
|         motion_field_estimation( )
|     tile_info( )
|     quantization_params( )
|     segmentation_params( )
|     delta_q_params( )
|     delta_lf_params( )
|     if ( primary_ref_frame == PRIMARY_REF_NONE ) {
|         init_coeff_cdfs( )
|     } else {
|         load_previous_segment_ids( )
|     }
|     CodedLossless = 1
|     for ( segmentId = 0; segmentId < MAX_SEGMENTS; segmentId++ ) {
|         qindex = get_qindex( 1, segmentId )
|         LosslessArray[ segmentId ] = qindex == 0 && DeltaQYDc == 0 &&
|                                      DeltaQUAc == 0 && DeltaQUDc == 0 &&
|                                      DeltaQVAc == 0 && DeltaQVDc == 0
|         if ( !LosslessArray[ segmentId ] )
|             CodedLossless = 0
|         if ( using_qmatrix ) {
|             if ( LosslessArray[ segmentId ] ) {
|                 SegQMLevel[ 0 ][ segmentId ] = 15
|                 SegQMLevel[ 1 ][ segmentId ] = 15
|                 SegQMLevel[ 2 ][ segmentId ] = 15
|             } else {
|                 SegQMLevel[ 0 ][ segmentId ] = qm_y
|                 SegQMLevel[ 1 ][ segmentId ] = qm_u
|                 SegQMLevel[ 2 ][ segmentId ] = qm_v
|             }
|         }
|     }
|     AllLossless = CodedLossless && ( FrameWidth == UpscaledWidth )
|     loop_filter_params( )
|     cdef_params( )
|     lr_params( )
|     read_tx_mode( )
|     frame_reference_mode( )
|     skip_mode_params( )
|     if ( FrameIsIntra \|\|
|          error_resilient_mode \|\|
|          !enable_warped_motion )
|         allow_warped_motion = 0
|     else
|         @@allow_warped_motion                             | f(1)
|     @@reduced_tx_set                                      | f(1)
|     global_motion_params( )
|     film_grain_params( )
| }
{:.syntax }


### Get relative distance function ### {#get_relative_distance_function}

This function computes the distance between
two order hints by sign extending the result of subtracting the values.

| --------------------------------------------------------- | ---------------- |
| get_relative_dist( a, b ) {                               | **Type**
|     if ( !enable_order_hint )
|         return 0
|     diff = a - b
|     m = 1 \<\< (OrderHintBits - 1)
|     diff = (diff & (m - 1)) - (diff & m)
|     return diff
| }
{:.syntax }


### Reference frame marking function ### {#reference_frame_marking_function}

| --------------------------------------------------------- | ---------------- |
| mark_ref_frames( idLen ) {                                      | **Type**
|     diffLen = delta_frame_id_length_minus_2 + 2
|     for ( i = 0; i < NUM_REF_FRAMES; i++ ) {
|         if ( current_frame_id > ( 1 \<\< diffLen ) ) {
|             if ( RefFrameId[ i ] > current_frame_id \|\|
|                  RefFrameId[ i ] < ( current_frame_id - ( 1 \<\< diffLen ) ) )
|                 RefValid[ i ] = 0
|         } else {
|             if ( RefFrameId[ i ] > current_frame_id &&
|                  RefFrameId[ i ] < ( ( 1 \<\< idLen ) +
|                                      current_frame_id -
|                                      ( 1 \<\< diffLen ) ) )
|                 RefValid[ i ] = 0
|         }
|     }
| }
{:.syntax }


### Frame size syntax ### {#frame_size_syntax}

| --------------------------------------------------------- | ---------------- |
| frame_size( ) {                                           | **Type**
|     if ( frame_size_override_flag ) {                       |
|         n = frame_width_bits_minus_1 + 1                  |
|         @@frame_width_minus_1                             | f(n)
|         n = frame_height_bits_minus_1 + 1                 |
|         @@frame_height_minus_1                            | f(n)
|         FrameWidth = frame_width_minus_1 + 1
|         FrameHeight = frame_height_minus_1 + 1
|     } else {
|         FrameWidth = max_frame_width_minus_1 + 1
|         FrameHeight = max_frame_height_minus_1 + 1
|     }
|     superres_params( )
|     compute_image_size( )
| }
{:.syntax }


### Render size syntax ### {#render_size_syntax}

| --------------------------------------------------------- | ---------------- |
| render_size( ) {                                          | **Type**
|     @@render_and_frame_size_different                     | f(1)
|     if ( render_and_frame_size_different == 1 ) {         |
|         @@render_width_minus_1                            | f(16)
|         @@render_height_minus_1                           | f(16)
|         RenderWidth = render_width_minus_1 + 1
|         RenderHeight = render_height_minus_1 + 1
|     } else {
|         RenderWidth = UpscaledWidth
|         RenderHeight = FrameHeight
|     }
| }
{:.syntax }


### Frame size with refs syntax ### {#frame_size_with_refs_syntax}

| --------------------------------------------------------- | ---------------- |
| frame_size_with_refs( ) {                                 | **Type**
|     for ( i = 0; i < REFS_PER_FRAME; i++ ) {              |
|         @@found_ref                                       | f(1)
|         if ( found_ref == 1 ) {
|             UpscaledWidth = RefUpscaledWidth[ ref_frame_idx[ i ] ]
|             FrameWidth = UpscaledWidth
|             FrameHeight = RefFrameHeight[ ref_frame_idx[ i ] ]
|             RenderWidth = RefRenderWidth[ ref_frame_idx[ i ] ]
|             RenderHeight = RefRenderHeight[ ref_frame_idx[ i ] ]
|             break
|         }
|     }
|     if ( found_ref == 0 ) {
|         frame_size( )
|         render_size( )
|     } else {
|         superres_params( )
|         compute_image_size( )
|     }
| }
{:.syntax }


### Superres params syntax ### {#superres_params_syntax}

| --------------------------------------------------------- | ---------------- |
| superres_params() {                                       | **Type**
|   if ( enable_superres )
|     @@use_superres                                        | f(1)
|   else
|     use_superres = 0
|   if ( use_superres ) {                                     |
|     @@coded_denom                                         | f(SUPERRES_DENOM_BITS)
|     SuperresDenom = coded_denom + SUPERRES_DENOM_MIN
|   } else {
|     SuperresDenom = SUPERRES_NUM
|   }
|   UpscaledWidth = FrameWidth
|   FrameWidth = (UpscaledWidth * SUPERRES_NUM +
|                 (SuperresDenom / 2)) / SuperresDenom
| }
{:.syntax }


### Compute image size function ### {#compute_image_size_function}

| --------------------------------------------------------- | ---------------- |
| compute_image_size( ) {                                   | **Type**
|     MiCols = 2 * ( ( FrameWidth + 7 ) \>\> 3 )
|     MiRows = 2 * ( ( FrameHeight + 7 ) \>\> 3 )
| }
{:.syntax }


### Interpolation filter syntax ### {#interpolation_filter_syntax}

| --------------------------------------------------------- | ---------------- |
| read_interpolation_filter( ) {                            | **Type**
|     @@is_filter_switchable                                | f(1)
|     if ( is_filter_switchable == 1 ) {                    |
|         interpolation_filter = SWITCHABLE                 |
|     } else {                                              |
|         @@interpolation_filter                            | f(2)
|     }
| }
{:.syntax }


### Loop filter params syntax ### {#loop_filter_params_syntax}

| --------------------------------------------------------- | ---------------- |
| loop_filter_params( ) {                                   | **Type**
|     if ( CodedLossless \|\| allow_intrabc ) {
|         loop_filter_level[ 0 ] = 0
|         loop_filter_level[ 1 ] = 0
|         loop_filter_ref_deltas[ INTRA_FRAME ] = 1
|         loop_filter_ref_deltas[ LAST_FRAME ] = 0
|         loop_filter_ref_deltas[ LAST2_FRAME ] = 0
|         loop_filter_ref_deltas[ LAST3_FRAME ] = 0
|         loop_filter_ref_deltas[ BWDREF_FRAME ] = 0
|         loop_filter_ref_deltas[ GOLDEN_FRAME ] = -1
|         loop_filter_ref_deltas[ ALTREF_FRAME ] = -1
|         loop_filter_ref_deltas[ ALTREF2_FRAME ] = -1
|         for ( i = 0; i < 2; i++ ) {
|             loop_filter_mode_deltas[ i ] = 0
|         }
|         return
|     }
|     @@loop_filter_level[ 0 ]                              | f(6)
|     @@loop_filter_level[ 1 ]                              | f(6)
|     if ( NumPlanes > 1 ) {
|         if ( loop_filter_level[ 0 ] \|\| loop_filter_level[ 1 ] ) {
|             @@loop_filter_level[ 2 ]                      | f(6)
|             @@loop_filter_level[ 3 ]                      | f(6)
|         }
|     }
|     @@loop_filter_sharpness                               | f(3)
|     @@loop_filter_delta_enabled                           | f(1)
|     if ( loop_filter_delta_enabled == 1 ) {
|         @@loop_filter_delta_update                        | f(1)
|         if ( loop_filter_delta_update == 1 ) {
|             for ( i = 0; i < TOTAL_REFS_PER_FRAME; i++ ) {
|                 @@update_ref_delta                        | f(1)
|                 if ( update_ref_delta == 1 )
|                     @@loop_filter_ref_deltas[ i ]         | su(1+6)
|             }
|             for ( i = 0; i < 2; i++ ) {
|                 @@update_mode_delta                       | f(1)
|                 if ( update_mode_delta == 1 )
|                     @@loop_filter_mode_deltas[ i ]        | su(1+6)
|             }
|         }
|     }
| }
{:.syntax }


### Quantization params syntax ### {#quantization_params_syntax}

| --------------------------------------------------------- | ---------------- |
| quantization_params( ) {                                  | **Type**
|     @@base_q_idx                                          | f(8)
|     DeltaQYDc = read_delta_q( )                           |
|     if ( NumPlanes > 1 ) {                                |
|         if ( separate_uv_delta_q )                        |
|           @@diff_uv_delta                                 | f(1)
|         else
|           diff_uv_delta = 0
|         DeltaQUDc = read_delta_q( )
|         DeltaQUAc = read_delta_q( )
|         if ( diff_uv_delta ) {
|           DeltaQVDc = read_delta_q( )
|           DeltaQVAc = read_delta_q( )
|         } else {
|           DeltaQVDc = DeltaQUDc
|           DeltaQVAc = DeltaQUAc
|         }
|     } else {
|         DeltaQUDc = 0
|         DeltaQUAc = 0
|         DeltaQVDc = 0
|         DeltaQVAc = 0
|     }
|     @@using_qmatrix                                       | f(1)
|     if ( using_qmatrix ) {                                  |
|         @@qm_y                                            | f(4)
|         @@qm_u                                            | f(4)
|         if ( !separate_uv_delta_q )
|             qm_v = qm_u
|         else
|             @@qm_v                                        | f(4)
|     }
| }
{:.syntax }


### Delta quantizer syntax ### {#delta_quantizer_syntax}

| --------------------------------------------------------- | ---------------- |
| read_delta_q( ) {                                         | **Type**
|     @@delta_coded                                         | f(1)
|     if ( delta_coded ) {                                  |
|         @@delta_q                                         | su(1+6)
|     } else {
|         delta_q = 0
|     }
|     return delta_q
| }
{:.syntax }


### Segmentation params syntax ### {#segmentation_params_syntax}

| --------------------------------------------------------- | ---------------- |
| segmentation_params( ) {                                  | **Type**
|     @@segmentation_enabled                                | f(1)
|     if ( segmentation_enabled == 1 ) {
|         if ( primary_ref_frame == PRIMARY_REF_NONE ) {
|             segmentation_update_map = 1
|             segmentation_temporal_update = 0
|             segmentation_update_data = 1
|         } else {
|             @@segmentation_update_map                     | f(1)
|             if ( segmentation_update_map == 1 )           |
|                 @@segmentation_temporal_update            | f(1)
|             @@segmentation_update_data                    | f(1)
|         }                                                 |
|         if ( segmentation_update_data == 1 ) {            |
|             for ( i = 0; i < MAX_SEGMENTS; i++ ) {        |
|                 for ( j = 0; j < SEG_LVL_MAX; j++ ) {     |
|                     @@feature_enabled                     | f(1)
|                     FeatureEnabled[ i ][ j ] = feature_enabled
|                     clippedValue = 0
|                     if ( feature_enabled == 1 ) {
|                         bitsToRead = Segmentation_Feature_Bits[ j ]
|                         limit = Segmentation_Feature_Max[ j ]
|                         if ( Segmentation_Feature_Signed[ j ] == 1 ) {
|                             @@feature_value               | su(1+bitsToRead)
|                             clippedValue = Clip3( -limit, limit, feature_value)
|                         } else {
|                             @@feature_value               | f(bitsToRead)
|                             clippedValue = Clip3( 0, limit, feature_value)
|                         }
|                     }
|                     FeatureData[ i ][ j ] = clippedValue
|                 }
|             }
|         }
|     } else {
|         for ( i = 0; i < MAX_SEGMENTS; i++ ) {
|             for ( j = 0; j < SEG_LVL_MAX; j++ ) {
|                 FeatureEnabled[ i ][ j ] = 0
|                 FeatureData[ i ][ j ] = 0
|             }
|         }
|     }
|     SegIdPreSkip = 0
|     LastActiveSegId = 0
|     for ( i = 0; i < MAX_SEGMENTS; i++ ) {
|         for ( j = 0; j < SEG_LVL_MAX; j++ ) {
|             if ( FeatureEnabled[ i ][ j ] ) {
|                 LastActiveSegId = i
|                 if ( j >\= SEG_LVL_REF_FRAME ) {
|                     SegIdPreSkip = 1
|                 }
|             }
|         }
|     }
| }
{:.syntax }

The constant lookup tables used in this syntax are defined as:

~~~~~ c
Segmentation_Feature_Bits[ SEG_LVL_MAX ]   = { 8, 6, 6, 6, 6, 3, 0, 0 }
Segmentation_Feature_Signed[ SEG_LVL_MAX ] = { 1, 1, 1, 1, 1, 0, 0, 0 }
Segmentation_Feature_Max[ SEG_LVL_MAX ] = {
  255, MAX_LOOP_FILTER, MAX_LOOP_FILTER,
  MAX_LOOP_FILTER, MAX_LOOP_FILTER, 7,
  0, 0 }
~~~~~


### Tile info syntax ### {#tile_info_syntax}

| --------------------------------------------------------- | ---------------- |
| tile_info ( ) {                                           | **Type**
|     sbCols = use_128x128_superblock ? ( ( MiCols + 31 ) \>\> 5 ) : ( ( MiCols + 15 ) \>\> 4 )
|     sbRows = use_128x128_superblock ? ( ( MiRows + 31 ) \>\> 5 ) : ( ( MiRows + 15 ) \>\> 4 )
|     sbShift = use_128x128_superblock ? 5 : 4
|     sbSize = sbShift + 2
|     maxTileWidthSb = MAX_TILE_WIDTH \>\> sbSize
|     maxTileAreaSb = MAX_TILE_AREA \>\> ( 2 * sbSize )
|     minLog2TileCols = tile_log2(maxTileWidthSb, sbCols)
|     maxLog2TileCols = tile_log2(1, Min(sbCols, MAX_TILE_COLS))
|     maxLog2TileRows = tile_log2(1, Min(sbRows, MAX_TILE_ROWS))
|     minLog2Tiles = Max(minLog2TileCols,
|                        tile_log2(maxTileAreaSb, sbRows * sbCols))
|
|     @@uniform_tile_spacing_flag                           | f(1)
|     if ( uniform_tile_spacing_flag ) {                    |
|         TileColsLog2 = minLog2TileCols                    |
|         while ( TileColsLog2 < maxLog2TileCols ) {        |
|             @@increment_tile_cols_log2                    | f(1)
|             if ( increment_tile_cols_log2 == 1 )
|                 TileColsLog2++
|             else
|                 break
|         }
|         tileWidthSb = (sbCols + (1 \<\< TileColsLog2) - 1) \>\> TileColsLog2
|         i = 0
|         for ( startSb = 0; startSb < sbCols; startSb += tileWidthSb ) {
|           MiColStarts[ i ] = startSb \<\< sbShift
|           i += 1
|         }
|         MiColStarts[i] = MiCols
|         TileCols = i
|
|         minLog2TileRows = Max( minLog2Tiles - TileColsLog2, 0)
|         TileRowsLog2 = minLog2TileRows
|         while ( TileRowsLog2 < maxLog2TileRows ) {        |
|             @@increment_tile_rows_log2                    | f(1)
|             if ( increment_tile_rows_log2 == 1 )          |
|                 TileRowsLog2++
|             else
|                 break
|         }
|         tileHeightSb = (sbRows + (1 \<\< TileRowsLog2) - 1) \>\> TileRowsLog2
|         i = 0
|         for ( startSb = 0; startSb < sbRows; startSb += tileHeightSb ) {
|           MiRowStarts[ i ] = startSb \<\< sbShift
|           i += 1
|         }
|         MiRowStarts[i] = MiRows
|         TileRows = i
|     } else {
|         widestTileSb = 0
|         startSb = 0
|         for ( i = 0; startSb < sbCols; i++ ) {
|             MiColStarts[ i ] = startSb \<\< sbShift
|             maxWidth = Min(sbCols - startSb, maxTileWidthSb)
|             @@width_in_sbs_minus_1                        | ns(maxWidth)
|             sizeSb = width_in_sbs_minus_1 + 1             |
|             widestTileSb = Max( sizeSb, widestTileSb )    |
|             startSb += sizeSb
|         }
|         MiColStarts[i] = MiCols
|         TileCols = i
|         TileColsLog2 = tile_log2(1, TileCols)
|
|         if ( minLog2Tiles > 0 )
|             maxTileAreaSb = (sbRows * sbCols) \>\> (minLog2Tiles + 1)
|         else
|             maxTileAreaSb = sbRows * sbCols
|         maxTileHeightSb = Max( maxTileAreaSb / widestTileSb, 1 )
|
|         startSb = 0
|         for ( i = 0; startSb < sbRows; i++ ) {
|             MiRowStarts[ i ] = startSb \<\< sbShift
|             maxHeight = Min(sbRows - startSb, maxTileHeightSb)
|             @@height_in_sbs_minus_1                       | ns(maxHeight)
|             sizeSb = height_in_sbs_minus_1 + 1            |
|             startSb += sizeSb                             |
|         }
|         MiRowStarts[ i ] = MiRows
|         TileRows = i
|         TileRowsLog2 = tile_log2(1, TileRows)
|     }
|     if ( TileColsLog2 > 0 \|\| TileRowsLog2 > 0 ) {         |
|         @@context_update_tile_id                          | f(TileRowsLog2 + TileColsLog2)
|         @@tile_size_bytes_minus_1                         | f(2)
|         TileSizeBytes = tile_size_bytes_minus_1 + 1
|     } else {
|         context_update_tile_id = 0
|     }
| }
{:.syntax }


### Tile size calculation function ### {#tile_size_calculation_function}

tile_log2 returns the smallest value for k such that blkSize \<\< k is greater than or equal to target.

| --------------------------------------------------------- | ---------------- |
| tile_log2( blkSize, target ) {                            | **Type**
|   for ( k = 0; (blkSize \<\< k) < target; k++ ) {
|   }
|   return k
| }
{:.syntax }


### Quantizer index delta parameters syntax ### {#quantizer_index_delta_parameters_syntax}

| --------------------------------------------------------- | ---------------- |
| delta_q_params( ) {                                       | **Type**
|     delta_q_res = 0
|     delta_q_present = 0
|     if ( base_q_idx > 0 ) {
|         @@delta_q_present                                 | f(1)
|     }                                                     |
|     if ( delta_q_present ) {                              |
|         @@delta_q_res                                     | f(2)
|     }
| }
{:.syntax }


### Loop filter delta parameters syntax ### {#loop_filter_delta_parameters_syntax}

| --------------------------------------------------------- | ---------------- |
| delta_lf_params( ) {                                      | **Type**
|     delta_lf_present = 0                                  |
|     delta_lf_res = 0                                      |
|     delta_lf_multi = 0                                    |
|     if ( delta_q_present ) {                              |
|         if ( !allow_intrabc )
|             @@delta_lf_present                            | f(1)
|         if ( delta_lf_present ) {                         |
|             @@delta_lf_res                                | f(2)
|             @@delta_lf_multi                              | f(1)
|         }
|     }
| }
{:.syntax }


### CDEF params syntax ### {#cdef_params_syntax}

| --------------------------------------------------------- | ---------------- |
| cdef_params( ) {                                          | **Type**
|     if ( CodedLossless \|\| allow_intrabc \|\|
|          !enable_cdef) {
|         cdef_bits = 0
|         cdef_y_pri_strength[0] = 0
|         cdef_y_sec_strength[0] = 0
|         cdef_uv_pri_strength[0] = 0
|         cdef_uv_sec_strength[0] = 0
|         CdefDamping = 3
|         return
|     }
|     @@cdef_damping_minus_3                                | f(2)
|     CdefDamping = cdef_damping_minus_3 + 3                |
|     @@cdef_bits                                           | f(2)
|     for ( i = 0; i < (1 \<\< cdef_bits); i++ ) {              |
|         @@cdef_y_pri_strength[i]                          | f(4)
|         @@cdef_y_sec_strength[i]                          | f(2)
|         if ( cdef_y_sec_strength[i] == 3 )
|             cdef_y_sec_strength[i] += 1
|         if ( NumPlanes > 1 ) {
|             @@cdef_uv_pri_strength[i]                     | f(4)
|             @@cdef_uv_sec_strength[i]                     | f(2)
|             if ( cdef_uv_sec_strength[i] == 3 )
|                 cdef_uv_sec_strength[i] += 1
|         }
|     }
| }
{:.syntax }


### Loop restoration params syntax ### {#loop_restoration_params_syntax}

| --------------------------------------------------------- | ---------------- |
| lr_params( ) {                                            | **Type**
|     if ( AllLossless \|\| allow_intrabc \|\|
|          !enable_restoration ) {
|         FrameRestorationType[0] = RESTORE_NONE
|         FrameRestorationType[1] = RESTORE_NONE
|         FrameRestorationType[2] = RESTORE_NONE
|         UsesLr = 0
|         return
|     }
|     UsesLr = 0
|     usesChromaLr = 0
|     for ( i = 0; i < NumPlanes; i++ ) {
|         @@lr_type                                         | f(2)
|         FrameRestorationType[i] = Remap_Lr_Type[lr_type]
|         if ( FrameRestorationType[i] != RESTORE_NONE ) {
|             UsesLr = 1
|             if ( i > 0 ) {
|                 usesChromaLr = 1
|             }
|         }
|     }
|     if ( UsesLr ) {
|         if ( use_128x128_superblock ) {
|             @@lr_unit_shift                               | f(1)
|             lr_unit_shift++
|         } else {
|             @@lr_unit_shift                               | f(1)
|             if ( lr_unit_shift ) {
|                 @@lr_unit_extra_shift                     | f(1)
|                 lr_unit_shift += lr_unit_extra_shift
|             }
|         }
|         LoopRestorationSize[ 0 ] = RESTORATION_TILESIZE_MAX \>\> (2 - lr_unit_shift)
|         if ( subsampling_x && subsampling_y && usesChromaLr ) {
|             @@lr_uv_shift                                 | f(1)
|         } else {
|             lr_uv_shift = 0
|         }
|         LoopRestorationSize[ 1 ] = LoopRestorationSize[ 0 ] \>\> lr_uv_shift
|         LoopRestorationSize[ 2 ] = LoopRestorationSize[ 0 ] \>\> lr_uv_shift
|     }
| }
{:.syntax }

where Remap_Lr_Type is a constant lookup table specified as:

~~~~~ c
Remap_Lr_Type[4] = {
  RESTORE_NONE, RESTORE_SWITCHABLE, RESTORE_WIENER, RESTORE_SGRPROJ
}
~~~~~


### TX mode syntax ### {#tx_mode_syntax}

| --------------------------------------------------------- | ---------------- |
| read_tx_mode( ) {                                         | **Type**
|     if ( CodedLossless == 1 ) {
|         TxMode = ONLY_4X4
|     } else {
|         @@tx_mode_select                                  | f(1)
|         if ( tx_mode_select ) {
|             TxMode = TX_MODE_SELECT
|         } else {
|             TxMode = TX_MODE_LARGEST
|         }
|     }
| }
{:.syntax }


### Skip mode params syntax ### {#skip_mode_params_syntax}

| --------------------------------------------------------- | ---------------- |
| skip_mode_params( ) {                                     | **Type**
|     if ( FrameIsIntra \|\| !reference_select \|\| !enable_order_hint ) {
|         skipModeAllowed = 0
|     } else {
|         forwardIdx = -1
|         backwardIdx = -1
|         for ( i = 0; i < REFS_PER_FRAME; i++ ) {
|             refHint = RefOrderHint[ ref_frame_idx[ i ] ]
|             if ( get_relative_dist( refHint, OrderHint ) < 0 ) {
|                 if ( forwardIdx < 0 \|\|
|                      get_relative_dist( refHint, forwardHint) > 0 ) {
|                     forwardIdx = i
|                     forwardHint = refHint
|                 }
|             } else if ( get_relative_dist( refHint, OrderHint) > 0 ) {
|                 if ( backwardIdx < 0 \|\|
|                      get_relative_dist( refHint, backwardHint) < 0 ) {
|                     backwardIdx = i
|                     backwardHint = refHint
|                 }
|             }
|         }
|         if ( forwardIdx < 0 ) {
|             skipModeAllowed = 0
|         } else if ( backwardIdx >\= 0 ) {
|             skipModeAllowed = 1
|             SkipModeFrame[ 0 ] = LAST_FRAME + Min(forwardIdx, backwardIdx)
|             SkipModeFrame[ 1 ] = LAST_FRAME + Max(forwardIdx, backwardIdx)
|         } else {
|             secondForwardIdx = -1
|             for ( i = 0; i < REFS_PER_FRAME; i++ ) {
|                 refHint = RefOrderHint[ ref_frame_idx[ i ] ]
|                 if ( get_relative_dist( refHint, forwardHint ) < 0 ) {
|                     if ( secondForwardIdx < 0 \|\|
|                          get_relative_dist( refHint, secondForwardHint ) > 0 ) {
|                         secondForwardIdx = i
|                         secondForwardHint = refHint
|                     }
|                 }
|             }
|             if ( secondForwardIdx < 0 ) {
|                 skipModeAllowed = 0
|             } else {
|                 skipModeAllowed = 1
|                 SkipModeFrame[ 0 ] = LAST_FRAME + Min(forwardIdx, secondForwardIdx)
|                 SkipModeFrame[ 1 ] = LAST_FRAME + Max(forwardIdx, secondForwardIdx)
|             }
|         }
|     }
|     if ( skipModeAllowed ) {
|         @@skip_mode_present                               | f(1)
|     } else {
|         skip_mode_present = 0
|     }
| }
{:.syntax }


### Frame reference mode syntax ### {#frame_reference_mode_syntax}

| --------------------------------------------------------- | ---------------- |
| frame_reference_mode( ) {                                 | **Type**
|     if ( FrameIsIntra ) {
|         reference_select = 0
|     } else {
|         @@reference_select                                | f(1)
|     }
| }
{:.syntax }


### Global motion params syntax ### {#global_motion_params_syntax}

| --------------------------------------------------------- | ---------------- |
| global_motion_params( ) {                                 | **Type**
|     for ( ref = LAST_FRAME; ref <= ALTREF_FRAME; ref++ ) {
|         GmType[ ref ] = IDENTITY
|         for ( i = 0; i < 6; i++ ) {
|             gm_params[ ref ][ i ] = ( ( i % 3 == 2 ) ?
|                       1 \<\< WARPEDMODEL_PREC_BITS : 0 )
|         }
|     }
|     if ( FrameIsIntra )
|         return
|     for ( ref = LAST_FRAME; ref <\= ALTREF_FRAME; ref++ ) {
|         @@is_global                                       | f(1)
|         if ( is_global ) {                                  |
|             @@is_rot_zoom                                 | f(1)
|             if ( is_rot_zoom ) {                            |
|                 type = ROTZOOM                            |
|             } else {                                      |
|                 @@is_translation                          | f(1)
|                 type = is_translation ? TRANSLATION : AFFINE
|             }
|         } else {
|             type = IDENTITY
|         }
|         GmType[ref] = type
|
|         if ( type >\= ROTZOOM ) {
|             read_global_param(type,ref,2)
|             read_global_param(type,ref,3)
|             if ( type == AFFINE ) {
|                 read_global_param(type,ref,4)
|                 read_global_param(type,ref,5)
|             } else {
|                 gm_params[ref][4] = -gm_params[ref][3]
|                 gm_params[ref][5] = gm_params[ref][2]
|             }
|         }
|         if ( type >\= TRANSLATION ) {
|             read_global_param(type,ref,0)
|             read_global_param(type,ref,1)
|         }
|     }
| }
{:.syntax }


### Global param syntax ### {#global_param_syntax}

| --------------------------------------------------------- | ---------------- |
| read_global_param( type, ref, idx ) {                     | **Type**
|     absBits = GM_ABS_ALPHA_BITS
|     precBits = GM_ALPHA_PREC_BITS
|     if ( idx < 2 ) {
|         if ( type == TRANSLATION ) {
|             absBits = GM_ABS_TRANS_ONLY_BITS - !allow_high_precision_mv
|             precBits = GM_TRANS_ONLY_PREC_BITS - !allow_high_precision_mv
|         } else {
|             absBits = GM_ABS_TRANS_BITS
|             precBits = GM_TRANS_PREC_BITS
|         }
|     }
|     precDiff = WARPEDMODEL_PREC_BITS - precBits
|     round = (idx % 3) == 2 ? (1 \<\< WARPEDMODEL_PREC_BITS) : 0
|     sub = (idx % 3) == 2 ? (1 \<\< precBits) : 0
|     mx = (1 \<\< absBits)
|     r = (PrevGmParams[ref][idx] \>\> precDiff) - sub
|     gm_params[ref][idx] =
|         (decode_signed_subexp_with_ref( -mx, mx + 1, r )\<\< precDiff) + round
| }
{:.syntax }

**Note:** When force_integer_mv is equal to 1, some fractional bits are still
read for the translation components. However, these fractional bits will be
discarded during the Setup Global MV process.
{:.alert .alert-info }


### Decode signed subexp with ref syntax ### {#decode_signed_subexp_with_ref_syntax}

| --------------------------------------------------------- | ---------------- |
| decode_signed_subexp_with_ref( low, high, r ) {           | **Type**
|     x = decode_unsigned_subexp_with_ref(high - low, r - low)
|     return x + low
| }
{:.syntax }

**Note:** decode_signed_subexp_with_ref will return a value
in the range low to high - 1 (inclusive).
{:.alert .alert-info }

### Decode unsigned subexp with ref syntax ### {#decode_unsigned_subexp_with_ref_syntax}

| --------------------------------------------------------- | ---------------- |
| decode_unsigned_subexp_with_ref( mx, r ) {                | **Type**
|     v = decode_subexp( mx )
|     if ( (r \<\< 1) <\= mx ) {
|         return inverse_recenter(r, v)
|     } else {
|         return mx - 1 - inverse_recenter(mx - 1 - r, v)
|     }
| }
{:.syntax }

**Note:** decode_unsigned_subexp_with_ref will return a value
in the range 0 to mx - 1 (inclusive).
{:.alert .alert-info }

### Decode subexp syntax ### {#decode_subexp_syntax}

| --------------------------------------------------------- | ---------------- |
| decode_subexp( numSyms ) {                                | **Type**
|     i = 0
|     mk = 0
|     k = 3
|     while ( 1 ) {
|         b2 = i ? k + i - 1 : k
|         a = 1 \<\< b2
|         if ( numSyms <\= mk + 3 * a ) {
|             @@subexp_final_bits                           | ns(numSyms - mk)
|             return subexp_final_bits + mk
|         } else {
|             @@subexp_more_bits                            | f(1)
|             if ( subexp_more_bits ) {
|                i++
|                mk += a
|             } else {
|                @@subexp_bits                              | f(b2)
|                return subexp_bits + mk
|             }
|         }
|     }
| }
{:.syntax }


### Inverse recenter function ### {#inverse_recenter_function}

| --------------------------------------------------------- | ---------------- |
| inverse_recenter( r, v ) {                                | **Type**
|   if ( v > 2 * r )
|     return v
|   else if ( v & 1 )
|     return r - ((v + 1) \>\> 1)
|   else
|     return r + (v \>\> 1)
| }
{:.syntax }


### Film grain params syntax ### {#film_grain_params_syntax}

| --------------------------------------------------------- | ---------------- |
| film_grain_params( ) {                                    | **Type**
|     if ( !film_grain_params_present \|\|
|          (!show_frame && !showable_frame) ) {
|         reset_grain_params()
|         return
|     }
|     @@apply_grain                                         | f(1)
|     if ( !apply_grain ) {
|         reset_grain_params()
|         return
|     }
|     @@grain_seed                                          | f(16)
|     if ( frame_type == INTER_FRAME )
|         @@update_grain                                    | f(1)
|     else
|         update_grain = 1
|     if ( !update_grain ) {
|         @@film_grain_params_ref_idx                       | f(3)
|         tempGrainSeed = grain_seed
|         load_grain_params( film_grain_params_ref_idx )
|         grain_seed = tempGrainSeed
|         return
|     }
|     @@num_y_points                                        | f(4)
|     for ( i = 0; i < num_y_points; i++ ) {
|         @@point_y_value[ i ]                              | f(8)
|         @@point_y_scaling[ i ]                            | f(8)
|     }
|     if ( mono_chrome ) {
|         chroma_scaling_from_luma = 0
|     } else {
|         @@chroma_scaling_from_luma                        | f(1)
|     }
|     if ( mono_chrome \|\| chroma_scaling_from_luma \|\|
|          ( subsampling_x == 1 && subsampling_y == 1 &&
|            num_y_points == 0 ) 
|        ) {
|         num_cb_points = 0
|         num_cr_points = 0
|     } else {
|         @@num_cb_points                                   | f(4)
|         for ( i = 0; i < num_cb_points; i++ ) {
|             @@point_cb_value[ i ]                         | f(8)
|             @@point_cb_scaling[ i ]                       | f(8)
|         }
|         @@num_cr_points                                   | f(4)
|         for ( i = 0; i < num_cr_points; i++ ) {
|             @@point_cr_value[ i ]                         | f(8)
|             @@point_cr_scaling[ i ]                       | f(8)
|         }
|     }
|     @@grain_scaling_minus_8                               | f(2)
|     @@ar_coeff_lag                                        | f(2)
|     numPosLuma = 2 * ar_coeff_lag * ( ar_coeff_lag + 1 )
|     if ( num_y_points ) {
|         numPosChroma = numPosLuma + 1
|         for ( i = 0; i < numPosLuma; i++ )
|             @@ar_coeffs_y_plus_128[ i ]                   | f(8)
|     } else {
|         numPosChroma = numPosLuma
|     }
|     if ( chroma_scaling_from_luma \|\| num_cb_points ) {
|         for ( i = 0; i < numPosChroma; i++ )
|             @@ar_coeffs_cb_plus_128[ i ]                  | f(8)
|     }
|     if ( chroma_scaling_from_luma \|\| num_cr_points ) {
|         for ( i = 0; i < numPosChroma; i++ )
|             @@ar_coeffs_cr_plus_128[ i ]                  | f(8)
|     }
|     @@ar_coeff_shift_minus_6                              | f(2)
|     @@grain_scale_shift                                   | f(2)
|     if ( num_cb_points ) {
|         @@cb_mult                                         | f(8)
|         @@cb_luma_mult                                    | f(8)
|         @@cb_offset                                       | f(9)
|     }
|     if ( num_cr_points ) {
|         @@cr_mult                                         | f(8)
|         @@cr_luma_mult                                    | f(8)
|         @@cr_offset                                       | f(9)
|     }
|     @@overlap_flag                                        | f(1)
|     @@clip_to_restricted_range                            | f(1)
| }
{:.syntax }

### Temporal point info syntax ### {#temporal_point_info_syntax}

| --------------------------------------------------------- | ---------------- |
| temporal_point_info( ) {                                  | **Type**
|     n = frame_presentation_time_length_minus_1 + 1
|     @@frame_presentation_time                             | f(n)
| }
{:.syntax }


## Frame OBU syntax ## {#frame_obu_syntax}

| --------------------------------------------------------- | ---------------- |
| frame_obu( sz ) {                                         | **Type**
|     startBitPos = get_position( )
|     frame_header_obu( )
|     byte_alignment( )
|     endBitPos = get_position( )
|     headerBytes = (endBitPos - startBitPos) / 8
|     sz -= headerBytes
|     tile_group_obu( sz )
| }
{:.syntax }


## Tile group OBU syntax ## {#tile_group_obu_syntax}

### General tile group OBU syntax ### {#general_tile_group_obu_syntax}

| --------------------------------------------------------- | ---------------- |
| tile_group_obu( sz ) {                                    | **Type**
|     NumTiles = TileCols * TileRows
|     startBitPos = get_position( )
|     tile_start_and_end_present_flag = 0
|     if ( NumTiles > 1 )
|         @@tile_start_and_end_present_flag                 | f(1)
|     if ( NumTiles == 1 \|\| !tile_start_and_end_present_flag ) {
|         tg_start = 0
|         tg_end = NumTiles - 1
|     } else {
|         tileBits = TileColsLog2 + TileRowsLog2
|         @@tg_start                                        | f(tileBits)
|         @@tg_end                                          | f(tileBits)
|     }
|     byte_alignment( )
|     endBitPos = get_position( )
|     headerBytes = (endBitPos - startBitPos) / 8
|     sz -= headerBytes
|
|     for ( TileNum = tg_start; TileNum <\= tg_end; TileNum++ ) {
|         tileRow = TileNum / TileCols
|         tileCol = TileNum % TileCols
|         lastTile = TileNum == tg_end
|         if ( lastTile ) {
|             tileSize = sz
|         } else {
|             @@tile_size_minus_1                           | le(TileSizeBytes)
|             tileSize = tile_size_minus_1 + 1
|             sz -= tileSize + TileSizeBytes
|         }
|         MiRowStart = MiRowStarts[ tileRow ]
|         MiRowEnd = MiRowStarts[ tileRow + 1 ]
|         MiColStart = MiColStarts[ tileCol ]
|         MiColEnd = MiColStarts[ tileCol + 1 ]
|         CurrentQIndex = base_q_idx
|         init_symbol( tileSize )
|         decode_tile( )
|         exit_symbol( )
|     }
|     if ( tg_end == NumTiles - 1 ) {
|         if ( !disable_frame_end_update_cdf ) {
|             frame_end_update_cdf( )
|         }
|         decode_frame_wrapup( )
|         SeenFrameHeader = 0
|     }
| }
{:.syntax }


### Decode tile syntax ### {#decode_tile_syntax}

| --------------------------------------------------------- | ---------------- |
| decode_tile( ) {                                          | **Type**
|     clear_above_context( )
|     for ( i = 0; i < FRAME_LF_COUNT; i++ )
|         DeltaLF[ i ] = 0
|     for ( plane = 0; plane < NumPlanes; plane++ ) {
|         for ( pass = 0; pass < 2; pass++ ) {
|             RefSgrXqd[ plane ][ pass ] = Sgrproj_Xqd_Mid[ pass ]
|             for ( i = 0; i < WIENER_COEFFS; i++ ) {
|                 RefLrWiener[ plane ][ pass ][ i ] = Wiener_Taps_Mid[ i ]
|             }
|         }
|     }
|     sbSize = use_128x128_superblock ? BLOCK_128X128 : BLOCK_64X64
|     sbSize4 = Num_4x4_Blocks_Wide[ sbSize ]
|     for ( r = MiRowStart; r < MiRowEnd; r += sbSize4 ) {
|         clear_left_context( )
|         for ( c = MiColStart; c < MiColEnd; c += sbSize4 ) {
|             ReadDeltas = delta_q_present
|             clear_cdef( r, c )
|             clear_block_decoded_flags( r, c, sbSize4 )
|             read_lr( r, c, sbSize )
|             decode_partition( r, c, sbSize )
|         }
|     }
| }
{:.syntax }

where Sgrproj_Xqd_Mid and Wiener_Taps_Mid are constant lookup tables specified as:

~~~~~ c
Wiener_Taps_Mid[3] = {  3,  -7,  15 }

Sgrproj_Xqd_Mid[2] = { -32,  31 }
~~~~~


### Clear block decoded flags function ### {#clear_block_decoded_flags_function}

| --------------------------------------------------------- | ---------------- |
| clear_block_decoded_flags( r, c, sbSize4 ) {              | **Type**
|     for ( plane = 0; plane < NumPlanes; plane++ ) {
|         subX = (plane > 0) ? subsampling_x : 0
|         subY = (plane > 0) ? subsampling_y : 0
|         sbWidth4 = ( MiColEnd - c ) \>\> subX
|         sbHeight4 = ( MiRowEnd - r ) \>\> subY
|         for ( y = -1; y <\= ( sbSize4 \>\> subY ); y++ )
|             for ( x = -1; x <\= ( sbSize4 \>\> subX ); x++ ) {
|                 if ( y < 0 && x < sbWidth4 )
|                     BlockDecoded[ plane ][ y ][ x ] = 1
|                 else if ( x < 0 && y < sbHeight4 )
|                     BlockDecoded[ plane ][ y ][ x ] = 1
|                 else
|                     BlockDecoded[ plane ][ y ][ x ] = 0
|             }
|         BlockDecoded[ plane ][ sbSize4 \>\> subY ][ -1 ] = 0
|     }
| }
{:.syntax }


### Decode partition syntax ### {#decode_partition_syntax}

| --------------------------------------------------------- | ---------------- |
| decode_partition( r, c, bSize ) {                         | **Type**
|     if ( r >\= MiRows \|\| c >\= MiCols )
|         return 0
|     AvailU = is_inside( r - 1, c )
|     AvailL = is_inside( r, c - 1 )
|     num4x4 = Num_4x4_Blocks_Wide[ bSize ]
|     halfBlock4x4 = num4x4 \>\> 1
|     quarterBlock4x4 = halfBlock4x4 \>\> 1
|     hasRows = ( r + halfBlock4x4 ) < MiRows
|     hasCols = ( c + halfBlock4x4 ) < MiCols
|     if ( bSize < BLOCK_8X8 ) {
|         partition = PARTITION_NONE
|     } else if ( hasRows && hasCols ) {
|         @@partition                                       | S()
|     } else if ( hasCols ) {
|         @@split_or_horz                                   | S()
|         partition = split_or_horz ? PARTITION_SPLIT : PARTITION_HORZ
|     } else if ( hasRows ) {
|         @@split_or_vert                                   | S()
|         partition = split_or_vert ? PARTITION_SPLIT : PARTITION_VERT
|     } else {
|         partition = PARTITION_SPLIT
|     }
|     subSize = Partition_Subsize[ partition ][ bSize ]
|     splitSize = Partition_Subsize[ PARTITION_SPLIT ][ bSize ]
|     if ( partition == PARTITION_NONE ) {
|         decode_block( r, c, subSize )
|     } else if ( partition == PARTITION_HORZ ) {
|         decode_block( r, c, subSize )
|         if ( hasRows )
|             decode_block( r + halfBlock4x4, c, subSize )
|     } else if ( partition == PARTITION_VERT ) {
|         decode_block( r, c, subSize )
|         if ( hasCols )
|             decode_block( r, c + halfBlock4x4, subSize )
|     } else if ( partition == PARTITION_SPLIT ) {
|         decode_partition( r, c, subSize )
|         decode_partition( r, c + halfBlock4x4, subSize )
|         decode_partition( r + halfBlock4x4, c, subSize )
|         decode_partition( r + halfBlock4x4, c + halfBlock4x4, subSize )
|     } else if ( partition == PARTITION_HORZ_A ) {
|         decode_block( r, c, splitSize )
|         decode_block( r, c + halfBlock4x4, splitSize )
|         decode_block( r + halfBlock4x4, c, subSize )
|     } else if ( partition == PARTITION_HORZ_B ) {
|         decode_block( r, c, subSize )
|         decode_block( r + halfBlock4x4, c, splitSize )
|         decode_block( r + halfBlock4x4, c + halfBlock4x4, splitSize )
|     } else if ( partition == PARTITION_VERT_A ) {
|         decode_block( r, c, splitSize )
|         decode_block( r + halfBlock4x4, c, splitSize )
|         decode_block( r, c + halfBlock4x4, subSize )
|     } else if ( partition == PARTITION_VERT_B ) {
|         decode_block( r, c, subSize )
|         decode_block( r, c + halfBlock4x4, splitSize )
|         decode_block( r + halfBlock4x4, c + halfBlock4x4, splitSize )
|     } else if ( partition == PARTITION_HORZ_4 ) {
|         decode_block( r + quarterBlock4x4 * 0, c, subSize )
|         decode_block( r + quarterBlock4x4 * 1, c, subSize )
|         decode_block( r + quarterBlock4x4 * 2, c, subSize )
|         if ( r + quarterBlock4x4 * 3 < MiRows )
|             decode_block( r + quarterBlock4x4 * 3, c, subSize )
|     } else {
|         decode_block( r, c + quarterBlock4x4 * 0, subSize )
|         decode_block( r, c + quarterBlock4x4 * 1, subSize )
|         decode_block( r, c + quarterBlock4x4 * 2, subSize )
|         if ( c + quarterBlock4x4 * 3 < MiCols )
|             decode_block( r, c + quarterBlock4x4 * 3, subSize )
|     }
| }
{:.syntax }


### Decode block syntax ### {#decode_block_syntax}

| --------------------------------------------------------- | ---------------- |
| decode_block( r, c, subSize ) {                           | **Type**
|     MiRow = r
|     MiCol = c
|     MiSize = subSize
|     bw4 = Num_4x4_Blocks_Wide[ subSize ]
|     bh4 = Num_4x4_Blocks_High[ subSize ]
|     if ( bh4 == 1 && subsampling_y && (MiRow & 1) == 0 )
|         HasChroma = 0
|     else if ( bw4 == 1 && subsampling_x && (MiCol & 1) == 0 )
|         HasChroma = 0
|     else
|         HasChroma = NumPlanes > 1
|     AvailU = is_inside( r - 1, c )
|     AvailL = is_inside( r, c - 1 )
|     AvailUChroma = AvailU
|     AvailLChroma = AvailL
|     if ( HasChroma ) {
|         if ( subsampling_y && bh4 == 1 )
|             AvailUChroma = is_inside( r - 2, c )
|         if ( subsampling_x && bw4 == 1 )
|             AvailLChroma = is_inside( r, c - 2 )
|     } else {
|         AvailUChroma = 0
|         AvailLChroma = 0
|     }
|     mode_info( )
|     palette_tokens( )
|     read_block_tx_size( )
|
|     if ( skip )
|         reset_block_context( bw4, bh4 )
|     isCompound = RefFrame[ 1 ] > INTRA_FRAME
|     for ( y = 0; y < bh4; y++ ) {
|         for ( x = 0; x < bw4; x++ ) {
|             YModes [ r + y ][ c + x ] = YMode
|             if ( RefFrame[ 0 ] == INTRA_FRAME && HasChroma )
|                 UVModes [ r + y ][ c + x ] = UVMode
|             for ( refList = 0; refList < 2; refList++ )
|                 RefFrames[ r + y ][ c + x ][ refList ] = RefFrame[ refList ]
|             if ( is_inter ) {
|                 if ( !use_intrabc ) {
|                   CompGroupIdxs[ r + y ][ c + x ] = comp_group_idx
|                   CompoundIdxs[ r + y ][ c + x ] = compound_idx
|                 }
|                 for ( dir = 0; dir < 2; dir++ ) {
|                     InterpFilters[ r + y ][ c + x ][ dir ] = interp_filter[ dir ]
|                 }
|                 for ( refList = 0; refList < 1 + isCompound; refList++ ) {
|                     Mvs[ r + y ][ c + x ][ refList ] = Mv[ refList ]
|                 }
|             }
|         }
|     }
|     compute_prediction( )
|     residual( )
|     for ( y = 0; y < bh4; y++ ) {
|         for ( x = 0; x < bw4; x++ ) {
|             IsInters[ r + y ][ c + x ] = is_inter
|             SkipModes[ r + y ][ c + x ] = skip_mode
|             Skips[ r + y ][ c + x ] = skip
|             TxSizes[ r + y ][ c + x ] = TxSize
|             MiSizes[ r + y ][ c + x ] = MiSize
|             SegmentIds[ r + y ][ c + x ] = segment_id
|             PaletteSizes[ 0 ][ r + y ][ c + x ] = PaletteSizeY
|             PaletteSizes[ 1 ][ r + y ][ c + x ] = PaletteSizeUV
|             for ( i = 0; i < PaletteSizeY; i++ )
|                 PaletteColors[ 0 ][ r + y ][ c + x ][ i ] = palette_colors_y[ i ]
|             for ( i = 0; i < PaletteSizeUV; i++ )
|                 PaletteColors[ 1 ][ r + y ][ c + x ][ i ] = palette_colors_u[ i ]
|             for ( i = 0; i < FRAME_LF_COUNT; i++ )
|                 DeltaLFs[ r + y ][ c + x ][ i ] = DeltaLF[ i ]
|         }
|     }
| }
{:.syntax }

where reset_block_context( ) is specified as:

~~~~~ c
reset_block_context( bw4, bh4 ) {
    for ( plane = 0; plane < 1 + 2 * HasChroma; plane++ ) {
        subX = (plane > 0) ? subsampling_x : 0
        subY = (plane > 0) ? subsampling_y : 0
        for ( i = MiCol >> subX; i < ( ( MiCol + bw4 ) >> subX ); i++) {
            AboveLevelContext[ plane ][ i ] = 0
            AboveDcContext[ plane ][ i ] = 0
        }
        for ( i = MiRow >> subY; i < ( ( MiRow + bh4 ) >> subY ); i++) {
            LeftLevelContext[ plane ][ i ] = 0
            LeftDcContext[ plane ][ i ] = 0
        }
    }
}
~~~~~


### Mode info syntax ### {#mode_info_syntax}

| --------------------------------------------------------- | ---------------- |
| mode_info( ) {                                            | **Type**
|     if ( FrameIsIntra )
|         intra_frame_mode_info( )
|     else
|         inter_frame_mode_info( )
| }
{:.syntax }


### Intra frame mode info syntax ### {#intra_frame_mode_info_syntax}

| --------------------------------------------------------- | ---------------- |
| intra_frame_mode_info( ) {                                | **Type**
|     skip = 0
|     if ( SegIdPreSkip )
|         intra_segment_id( )
|     skip_mode = 0
|     read_skip( )
|     if ( !SegIdPreSkip )
|         intra_segment_id( )
|     read_cdef( )
|     read_delta_qindex( )
|     read_delta_lf( )
|     ReadDeltas = 0
|     RefFrame[ 0 ] = INTRA_FRAME
|     RefFrame[ 1 ] = NONE
|     if ( allow_intrabc ) {
|         @@use_intrabc                                     | S()
|     } else {
|         use_intrabc = 0
|     }
|     if ( use_intrabc ) {
|         is_inter = 1
|         YMode = DC_PRED
|         UVMode = DC_PRED
|         motion_mode = SIMPLE
|         compound_type = COMPOUND_AVERAGE
|         PaletteSizeY = 0
|         PaletteSizeUV = 0
|         interp_filter[ 0 ] = BILINEAR
|         interp_filter[ 1 ] = BILINEAR
|         find_mv_stack( 0 )
|         assign_mv( 0 )
|     } else {
|         is_inter = 0
|         @@intra_frame_y_mode                              | S()
|         YMode = intra_frame_y_mode
|         intra_angle_info_y( )
|         if ( HasChroma ) {
|             @@uv_mode                                     | S()
|             UVMode = uv_mode
|             if ( UVMode == UV_CFL_PRED ) {
|                 read_cfl_alphas( )
|             }
|             intra_angle_info_uv( )
|         }
|         PaletteSizeY = 0
|         PaletteSizeUV = 0
|         if ( MiSize >\= BLOCK_8X8 &&
|              Block_Width[ MiSize ] <\= 64  &&
|              Block_Height[ MiSize ] <\= 64 &&
|              allow_screen_content_tools ) {
|             palette_mode_info( )
|         }
|         filter_intra_mode_info( )
|     }
| }
{:.syntax }


### Intra segment ID syntax ### {#intra_segment_id_syntax}

| --------------------------------------------------------- | ---------------- |
| intra_segment_id( ) {                                     | **Type**
|     if ( segmentation_enabled )
|         read_segment_id( )
|     else
|         segment_id = 0
|     Lossless = LosslessArray[ segment_id ]
| }
{:.syntax }


### Read segment ID syntax ### {#read_segment_id_syntax}

| --------------------------------------------------------- | ---------------- |
| read_segment_id( ) {                                      | **Type**
|     if ( AvailU && AvailL )
|         prevUL = SegmentIds[ MiRow - 1 ][ MiCol - 1 ]
|     else
|         prevUL = -1
|     if ( AvailU )
|         prevU = SegmentIds[ MiRow - 1 ][ MiCol ]
|     else
|         prevU = -1
|     if ( AvailL )
|         prevL = SegmentIds[ MiRow ][ MiCol - 1 ]
|     else
|         prevL = -1
|     if ( prevU == -1 )
|         pred = (prevL == -1) ? 0 : prevL
|     else if ( prevL == -1 )
|         pred = prevU
|     else
|         pred = (prevUL == prevU) ? prevU : prevL
|     if ( skip ) {
|         segment_id = pred
|     } else {
|         @@segment_id                                      | S()
|         segment_id = neg_deinterleave( segment_id, pred,
|                                        LastActiveSegId + 1 )
|     }
| }
{:.syntax }

where neg_deinterleave is a function defined as:

~~~~~ c
neg_deinterleave(diff, ref, max) {
  if ( !ref )
    return diff
  if ( ref >= (max - 1) )
    return max - diff - 1
  if ( 2 * ref < max ) {
    if ( diff <= 2 * ref ) {
      if ( diff & 1 )
        return ref + ((diff + 1) >> 1)
      else
        return ref - (diff >> 1)
    }
    return diff
  } else {
    if ( diff <= 2 * (max - ref - 1) ) {
      if ( diff & 1 )
        return ref + ((diff + 1) >> 1)
      else
        return ref - (diff >> 1)
    }
    return max - (diff + 1)
  }
}
~~~~~


### Skip mode syntax ### {#skip_mode_syntax}

| --------------------------------------------------------- | ---------------- |
| read_skip_mode() {                                        | **Type**
|     if ( seg_feature_active( SEG_LVL_SKIP ) \|\|
|          seg_feature_active( SEG_LVL_REF_FRAME ) \|\|
|          seg_feature_active( SEG_LVL_GLOBALMV ) \|\|
|          !skip_mode_present \|\|
|          Block_Width[ MiSize ] < 8 \|\|
|          Block_Height[ MiSize ] < 8 ) {
|         skip_mode = 0
|     } else {
|         @@skip_mode                                       | S()
|     }
| }
{:.syntax }


### Skip syntax ### {#skip_syntax}

| --------------------------------------------------------- | ---------------- |
| read_skip() {                                             | **Type**
|     if ( SegIdPreSkip && seg_feature_active( SEG_LVL_SKIP ) ) {
|         skip = 1
|     } else {
|         @@skip                                            | S()
|     }
| }
{:.syntax }


### Quantizer index delta syntax ### {#quantizer_index_delta_syntax}

| --------------------------------------------------------- | ---------------- |
| read_delta_qindex( ) {                                    | **Type**
|     sbSize = use_128x128_superblock ? BLOCK_128X128 : BLOCK_64X64
|     if ( MiSize == sbSize && skip )
|         return
|     if ( ReadDeltas ) {
|         @@delta_q_abs                                     | S()
|         if ( delta_q_abs == DELTA_Q_SMALL ) {
|             @@delta_q_rem_bits                            | L(3)
|             delta_q_rem_bits++
|             @@delta_q_abs_bits                            | L(delta_q_rem_bits)
|             delta_q_abs = delta_q_abs_bits + (1 \<\< delta_q_rem_bits) + 1
|         }
|         if ( delta_q_abs ) {
|             @@delta_q_sign_bit                            | L(1)
|             reducedDeltaQIndex = delta_q_sign_bit ? -delta_q_abs : delta_q_abs
|             CurrentQIndex = Clip3(1, 255,
|                 CurrentQIndex + (reducedDeltaQIndex \<\< delta_q_res))
|         }
|     }
| }
{:.syntax }


### Loop filter delta syntax ### {#loop_filter_delta_syntax}

| --------------------------------------------------------- | ---------------- |
| read_delta_lf( ) {                                        | **Type**
|     sbSize = use_128x128_superblock ? BLOCK_128X128 : BLOCK_64X64
|     if ( MiSize == sbSize && skip )
|         return
|     if ( ReadDeltas && delta_lf_present ) {
|         frameLfCount = 1
|         if ( delta_lf_multi ) {
|             frameLfCount = ( NumPlanes > 1 ) ? FRAME_LF_COUNT : ( FRAME_LF_COUNT - 2 )
|         }
|         for ( i = 0; i < frameLfCount; i++ ) {
|             @@delta_lf_abs                                | S()
|             if ( delta_lf_abs == DELTA_LF_SMALL ) {
|                 @@delta_lf_rem_bits                       | L(3)
|                 n = delta_lf_rem_bits + 1
|                 @@delta_lf_abs_bits                       | L(n)
|                 deltaLfAbs = delta_lf_abs_bits +
|                                ( 1 \<\< n ) + 1
|             } else {
|                 deltaLfAbs = delta_lf_abs
|             }
|             if ( deltaLfAbs ) {
|                 @@delta_lf_sign_bit                       | L(1)
|                 reducedDeltaLfLevel = delta_lf_sign_bit ?
|                                       -deltaLfAbs :
|                                        deltaLfAbs
|                 DeltaLF[ i ] = Clip3( -MAX_LOOP_FILTER, MAX_LOOP_FILTER, DeltaLF[ i ] +
|                                   (reducedDeltaLfLevel \<\< delta_lf_res) )
|             }
|         }
|     }
| }
{:.syntax }


### Segmentation feature active function ### {#segmentation_feature_active_function}

| --------------------------------------------------------- | ---------------- |
| seg_feature_active_idx( idx, feature ) {                  | **Type**
|     return segmentation_enabled && FeatureEnabled[ idx ][ feature ]
| }
|
| seg_feature_active( feature ) {
|     return seg_feature_active_idx( segment_id, feature )
| }
{:.syntax }


### TX size syntax ### {#tx_size_syntax}

| --------------------------------------------------------- | ---------------- |
| read_tx_size( allowSelect ) {                             | **Type**
|     if ( Lossless ) {
|         TxSize = TX_4X4
|         return
|     }
|     maxRectTxSize = Max_Tx_Size_Rect[ MiSize ]
|     maxTxDepth = Max_Tx_Depth[ MiSize ]
|     TxSize = maxRectTxSize
|     if ( MiSize > BLOCK_4X4 && allowSelect && TxMode == TX_MODE_SELECT ) {
|         @@tx_depth                                        | S()
|         for ( i = 0; i < tx_depth; i++ )
|             TxSize = Split_Tx_Size[ TxSize ]
|         }
|     }
| }
{:.syntax }

The Max_Tx_Depth table specifies the maximum transform depth
for each block size:

~~~~~ c
Max_Tx_Depth[ BLOCK_SIZES ] = {
    0, 1, 1, 1,
    2, 2, 2, 3,
    3, 3, 4, 4,
    4, 4, 4, 4,
    2, 2, 3, 3,
    4, 4
}
~~~~~

**Note:** Max_Tx_Depth contains the number of times
the transform must be split to reach a 4x4 transform size.
This number can be greater than MAX_TX_DEPTH.
However, it is impossible to encode a transform depth
greater than MAX_TX_DEPTH because
tx_depth can only encode values in the range 0 to 2
{:.alert .alert-info }

### Block TX size syntax ### {#block_tx_size_syntax}

| --------------------------------------------------------- | ---------------- |
| read_block_tx_size( ) {                                   | **Type**
|     bw4 = Num_4x4_Blocks_Wide[ MiSize ]
|     bh4 = Num_4x4_Blocks_High[ MiSize ]
|     if ( TxMode == TX_MODE_SELECT &&
|           MiSize > BLOCK_4X4 && is_inter &&
|           !skip && !Lossless ) {
|         maxTxSz = Max_Tx_Size_Rect[ MiSize ]
|         txW4 = Tx_Width[ maxTxSz ] / MI_SIZE
|         txH4 = Tx_Height[ maxTxSz ] / MI_SIZE
|         for ( row = MiRow; row < MiRow + bh4; row += txH4 )
|             for ( col = MiCol; col < MiCol + bw4; col += txW4 )
|                 read_var_tx_size( row, col, maxTxSz, 0 )
|     } else {
|         read_tx_size(!skip \|\| !is_inter)
|         for ( row = MiRow; row < MiRow + bh4; row++ )
|             for ( col = MiCol; col < MiCol + bw4; col++ )
|                 InterTxSizes[ row ][ col ] = TxSize
|     }
| }
{:.syntax }


### Var TX size syntax ### {#var_tx_size_syntax}

read_var_tx_size is used to read a transform size tree.

| --------------------------------------------------------- | ---------------- |
| read_var_tx_size( row, col, txSz, depth) {                | **Type**
|     if ( row >\= MiRows \|\| col >\= MiCols )
|         return
|     if ( txSz == TX_4X4 \|\| depth == MAX_VARTX_DEPTH ) {
|         txfm_split = 0
|     } else {
|         @@txfm_split                                      | S()
|     }
|     w4 = Tx_Width[ txSz ] / MI_SIZE
|     h4 = Tx_Height[ txSz ] / MI_SIZE
|     if ( txfm_split ) {
|         subTxSz = Split_Tx_Size[ txSz ]
|         stepW = Tx_Width[ subTxSz ] / MI_SIZE
|         stepH = Tx_Height[ subTxSz ] / MI_SIZE
|         for ( i = 0; i < h4; i += stepH )
|             for ( j = 0; j < w4; j += stepW )
|                 read_var_tx_size( row + i, col + j, subTxSz, depth+1)
|     } else {
|         for ( i = 0; i < h4; i++ )
|             for ( j = 0; j < w4; j++ )
|                 InterTxSizes[ row + i ][ col + j ] = txSz
|         TxSize = txSz
|     }
| }
{:.syntax }


### Inter frame mode info syntax ### {#inter_frame_mode_info_syntax}

| --------------------------------------------------------- | ---------------- |
| inter_frame_mode_info( ) {                                | **Type**
|     use_intrabc = 0
|     LeftRefFrame[ 0 ] = AvailL ? RefFrames[ MiRow ][ MiCol-1 ][ 0 ] : INTRA_FRAME
|     AboveRefFrame[ 0 ] = AvailU ? RefFrames[ MiRow-1 ][ MiCol ][ 0 ] : INTRA_FRAME
|     LeftRefFrame[ 1 ] = AvailL ? RefFrames[ MiRow ][ MiCol-1 ][ 1 ] : NONE
|     AboveRefFrame[ 1 ] = AvailU ? RefFrames[ MiRow-1 ][ MiCol ][ 1 ] : NONE
|     LeftIntra = LeftRefFrame[ 0 ] <\= INTRA_FRAME
|     AboveIntra = AboveRefFrame[ 0 ] <\= INTRA_FRAME
|     LeftSingle = LeftRefFrame[ 1 ] <\= INTRA_FRAME
|     AboveSingle = AboveRefFrame[ 1 ] <\= INTRA_FRAME
|     skip = 0
|     inter_segment_id( 1 )
|     read_skip_mode( )
|     if ( skip_mode )
|         skip = 1
|     else
|         read_skip( )
|     if ( !SegIdPreSkip )
|         inter_segment_id( 0 )
|     Lossless = LosslessArray[ segment_id ]
|     read_cdef( )
|     read_delta_qindex( )
|     read_delta_lf( )
|     ReadDeltas = 0
|     read_is_inter( )
|     if ( is_inter )
|         inter_block_mode_info( )
|     else
|         intra_block_mode_info( )
| }
{:.syntax }


### Inter segment ID syntax ### {#inter_segment_id_syntax}

This is called before (preSkip equal to 1) and after (preSkip equal to 0) the skip syntax element has been read.

| --------------------------------------------------------- | ---------------- |
| inter_segment_id( preSkip ) {                             | **Type**
|     if ( segmentation_enabled ) {
|         predictedSegmentId = get_segment_id( )
|         if ( segmentation_update_map ) {
|             if ( preSkip && !SegIdPreSkip ) {
|                 segment_id = 0
|                 return
|             }
|             if ( !preSkip ) {
|                 if ( skip ) {
|                     seg_id_predicted = 0
|                     for ( i = 0; i < Num_4x4_Blocks_Wide[ MiSize ]; i++ )
|                         AboveSegPredContext[ MiCol + i ] = seg_id_predicted
|                     for ( i = 0; i < Num_4x4_Blocks_High[ MiSize ]; i++ )
|                         LeftSegPredContext[ MiRow + i ] = seg_id_predicted
|                     read_segment_id( )
|                     return
|                 }
|             }
|             if ( segmentation_temporal_update == 1 ) {
|                 @@seg_id_predicted                        | S()
|                 if ( seg_id_predicted )
|                     segment_id = predictedSegmentId
|                 else
|                     read_segment_id( )
|                 for ( i = 0; i < Num_4x4_Blocks_Wide[ MiSize ]; i++ )
|                     AboveSegPredContext[ MiCol + i ] = seg_id_predicted
|                 for ( i = 0; i < Num_4x4_Blocks_High[ MiSize ]; i++ )
|                     LeftSegPredContext[ MiRow + i ] = seg_id_predicted
|             } else {
|                 read_segment_id( )
|             }
|         } else {
|             segment_id = predictedSegmentId
|         }
|     } else {
|         segment_id = 0
|     }
| }
{:.syntax }

### Is inter syntax ### {#is_inter_syntax}

| --------------------------------------------------------- | ---------------- |
| read_is_inter( ) {                                        | **Type**
|     if ( skip_mode ) {
|         is_inter = 1
|     } else if ( seg_feature_active ( SEG_LVL_REF_FRAME ) ) {
|         is_inter = FeatureData[ segment_id ][ SEG_LVL_REF_FRAME ] != INTRA_FRAME
|     } else if ( seg_feature_active ( SEG_LVL_GLOBALMV ) ) {
|         is_inter = 1
|     } else {
|         @@is_inter                                        | S()
|     }
| }
{:.syntax }


### Get segment ID function ### {#get_segment_id_function}

The predicted segment id is the smallest value found in the on-screen region
of the segmentation map covered by the current block.

| --------------------------------------------------------- | ---------------- |
| get_segment_id( ) {                                       | **Type**
|     bw4 = Num_4x4_Blocks_Wide[ MiSize ]
|     bh4 = Num_4x4_Blocks_High[ MiSize ]
|     xMis = Min( MiCols - MiCol, bw4 )
|     yMis = Min( MiRows - MiRow, bh4 )
|     seg = 7
|     for ( y = 0; y < yMis; y++ )
|         for ( x = 0; x < xMis; x++ )
|             seg = Min( seg, PrevSegmentIds[ MiRow + y ][ MiCol + x ] )
|     return seg
| }
{:.syntax }


### Intra block mode info syntax ### {#intra_block_mode_info_syntax}

| --------------------------------------------------------- | ---------------- |
| intra_block_mode_info( ) {                                | **Type**
|     RefFrame[ 0 ] = INTRA_FRAME
|     RefFrame[ 1 ] = NONE
|     @@y_mode                                              | S()
|     YMode = y_mode
|     intra_angle_info_y( )
|     if ( HasChroma ) {
|         @@uv_mode                                         | S()
|         UVMode = uv_mode
|         if ( UVMode == UV_CFL_PRED ) {
|             read_cfl_alphas( )
|         }
|         intra_angle_info_uv( )
|     }
|     PaletteSizeY = 0
|     PaletteSizeUV = 0
|     if ( MiSize >\= BLOCK_8X8 &&
|          Block_Width[ MiSize ] <\= 64  &&
|          Block_Height[ MiSize ] <\= 64 &&
|          allow_screen_content_tools )
|         palette_mode_info( )
|     filter_intra_mode_info( )
| }
{:.syntax }


### Inter block mode info syntax ### {#inter_block_mode_info_syntax}

| --------------------------------------------------------- | ---------------- |
| inter_block_mode_info( ) {                                | **Type**
|     PaletteSizeY = 0
|     PaletteSizeUV = 0
|     read_ref_frames( )
|     isCompound = RefFrame[ 1 ] > INTRA_FRAME
|     find_mv_stack( isCompound )
|     if ( skip_mode ) {
|         YMode = NEAREST_NEARESTMV
|     } else if ( seg_feature_active( SEG_LVL_SKIP ) \|\|
|          seg_feature_active( SEG_LVL_GLOBALMV ) ) {
|         YMode = GLOBALMV
|     } else if ( isCompound ) {
|         @@compound_mode                                   | S()
|         YMode = NEAREST_NEARESTMV + compound_mode
|     } else {
|         @@new_mv                                          | S()
|         if ( new_mv == 0 ) {
|             YMode = NEWMV
|         } else {
|             @@zero_mv                                     | S()
|             if ( zero_mv == 0 ) {
|                 YMode = GLOBALMV
|             } else {
|                 @@ref_mv                                  | S()
|                 YMode = (ref_mv == 0) ? NEARESTMV : NEARMV
|             }
|         }
|     }
|     RefMvIdx = 0
|     if ( YMode == NEWMV \|\| YMode == NEW_NEWMV ) {
|         for ( idx = 0; idx < 2; idx++ ) {
|             if ( NumMvFound > idx + 1 ) {
|                 @@drl_mode                                | S()
|                 if ( drl_mode == 0 ) {
|                   RefMvIdx = idx
|                   break
|                 }
|                 RefMvIdx = idx + 1
|             }
|         }
|     } else if ( has_nearmv( ) ) {
|         RefMvIdx = 1
|         for ( idx = 1; idx < 3; idx++ ) {
|             if ( NumMvFound > idx + 1 ) {
|                 @@drl_mode                                | S()
|                 if ( drl_mode == 0 ) {
|                     RefMvIdx = idx
|                     break
|                 }
|                 RefMvIdx = idx + 1
|             }
|         }
|     }
|     assign_mv( isCompound )
|     read_interintra_mode( isCompound )
|     read_motion_mode( isCompound )
|     read_compound_type( isCompound )
|     if ( interpolation_filter == SWITCHABLE ) {
|         for ( dir = 0; dir < ( enable_dual_filter ? 2 : 1 ); dir++ ) {
|             if ( needs_interp_filter( ) ) {
|                 @@interp_filter[ dir ]                    | S()
|             } else {
|                 interp_filter[ dir ] = EIGHTTAP
|             }
|         }
|         if ( !enable_dual_filter )
|             interp_filter[ 1 ] = interp_filter[ 0 ]
|     } else {
|         for ( dir = 0; dir < 2; dir++ )
|             interp_filter[ dir ] = interpolation_filter
|     }
| }
{:.syntax }

The function has_nearmv is defined as:

~~~~~ c
has_nearmv( ) {
    return (YMode == NEARMV || YMode == NEAR_NEARMV
            || YMode == NEAR_NEWMV || YMode == NEW_NEARMV)
}
~~~~~

The function needs_interp_filter is defined as:

~~~~~ c
needs_interp_filter( ) {
    large = (Min(Block_Width[MiSize], Block_Height[MiSize]) >= 8)
    if ( skip_mode || motion_mode == LOCALWARP ) {
        return 0
    } else if ( large && YMode == GLOBALMV ) {
        return GmType[ RefFrame[ 0 ] ] == TRANSLATION
    } else if ( large && YMode == GLOBAL_GLOBALMV ) {
        return GmType[ RefFrame[ 0 ] ] == TRANSLATION || GmType[ RefFrame[ 1 ] ] == TRANSLATION
    } else {
        return 1
    }
}
~~~~~


### Filter intra mode info syntax ### {#filter_intra_mode_info_syntax}

| --------------------------------------------------------- | ---------------- |
| filter_intra_mode_info( ) {                               | **Type**
|     use_filter_intra = 0
|     if ( enable_filter_intra &&
|          YMode == DC_PRED && PaletteSizeY == 0 &&
|          Max( Block_Width[ MiSize ], Block_Height[ MiSize ] ) <\= 32 ) {
|         @@use_filter_intra                                | S()
|         if ( use_filter_intra ) {
|             @@filter_intra_mode                           | S()
|         }
|     }
| }
{:.syntax }


### Ref frames syntax ### {#ref_frames_syntax}

| --------------------------------------------------------- | ---------------- |
| read_ref_frames( ) {                                      | **Type**
|     if ( skip_mode ) {
|         RefFrame[ 0 ] = SkipModeFrame[ 0 ]
|         RefFrame[ 1 ] = SkipModeFrame[ 1 ]
|     } else if ( seg_feature_active( SEG_LVL_REF_FRAME ) ) {
|         RefFrame[ 0 ] = FeatureData[ segment_id ][ SEG_LVL_REF_FRAME ]
|         RefFrame[ 1 ] = NONE
|     } else if ( seg_feature_active( SEG_LVL_SKIP ) \|\|
|                 seg_feature_active( SEG_LVL_GLOBALMV ) ) {
|         RefFrame[ 0 ] = LAST_FRAME
|         RefFrame[ 1 ] = NONE
|     } else {
|         bw4 = Num_4x4_Blocks_Wide[ MiSize ]
|         bh4 = Num_4x4_Blocks_High[ MiSize ]
|         if ( reference_select && ( Min( bw4, bh4 ) >= 2 ) )
|             @@comp_mode                                   | S()
|         else
|             comp_mode = SINGLE_REFERENCE
|         if ( comp_mode == COMPOUND_REFERENCE ) {
|             @@comp_ref_type                               | S()
|             if ( comp_ref_type == UNIDIR_COMP_REFERENCE ) {
|                 @@uni_comp_ref                            | S()
|                 if ( uni_comp_ref ) {
|                     RefFrame[0] = BWDREF_FRAME
|                     RefFrame[1] = ALTREF_FRAME
|                 } else {
|                     @@uni_comp_ref_p1                     | S()
|                     if ( uni_comp_ref_p1 ) {
|                         @@uni_comp_ref_p2                 | S()
|                         if ( uni_comp_ref_p2 ) {
|                           RefFrame[0] = LAST_FRAME
|                           RefFrame[1] = GOLDEN_FRAME
|                         } else {
|                           RefFrame[0] = LAST_FRAME
|                           RefFrame[1] = LAST3_FRAME
|                         }
|                     } else {
|                         RefFrame[0] = LAST_FRAME
|                         RefFrame[1] = LAST2_FRAME
|                     }
|                 }
|             } else {
|                 @@comp_ref                                | S()
|                 if ( comp_ref == 0 ) {
|                     @@comp_ref_p1                         | S()
|                     RefFrame[ 0 ] = comp_ref_p1 ?
|                                     LAST2_FRAME : LAST_FRAME
|                 } else {
|                     @@comp_ref_p2                         | S()
|                     RefFrame[ 0 ] = comp_ref_p2 ?
|                                     GOLDEN_FRAME : LAST3_FRAME
|                 }
|                 @@comp_bwdref                             | S()
|                 if ( comp_bwdref == 0 ) {
|                     @@comp_bwdref_p1                      | S()
|                     RefFrame[ 1 ] = comp_bwdref_p1 ?
|                                      ALTREF2_FRAME : BWDREF_FRAME
|                 } else {
|                     RefFrame[ 1 ] = ALTREF_FRAME
|                 }
|             }
|         } else {
|             @@single_ref_p1                               | S()
|             if ( single_ref_p1 ) {
|                 @@single_ref_p2                           | S()
|                 if ( single_ref_p2 == 0 ) {
|                     @@single_ref_p6                       | S()
|                     RefFrame[ 0 ] = single_ref_p6 ?
|                                      ALTREF2_FRAME : BWDREF_FRAME
|                 } else {
|                     RefFrame[ 0 ] = ALTREF_FRAME
|                 }
|             } else {
|                 @@single_ref_p3                           | S()
|                 if ( single_ref_p3 ) {
|                     @@single_ref_p5                       | S()
|                     RefFrame[ 0 ] = single_ref_p5 ?
|                                      GOLDEN_FRAME : LAST3_FRAME
|                 } else {
|                     @@single_ref_p4                       | S()
|                     RefFrame[ 0 ] = single_ref_p4 ?
|                                      LAST2_FRAME : LAST_FRAME
|                 }
|             }
|             RefFrame[ 1 ] = NONE
|         }
|     }
| }
{:.syntax }


### Assign MV syntax ### {#assign_mv_syntax}

| --------------------------------------------------------- | ---------------- |
| assign_mv( isCompound ) {                                 | **Type**
|     for ( i = 0; i < 1 + isCompound; i++ ) {
|         if ( use_intrabc ) {
|             compMode = NEWMV
|         } else {
|             compMode = get_mode( i )
|         }
|         if ( use_intrabc ) {
|             PredMv[ 0 ] = RefStackMv[ 0 ][ 0 ]
|             if ( PredMv[ 0 ][ 0 ] == 0 && PredMv[ 0 ][ 1 ] == 0 ) {
|                 PredMv[ 0 ] = RefStackMv[ 1 ][ 0 ]
|             }
|             if ( PredMv[ 0 ][ 0 ] == 0 && PredMv[ 0 ][ 1 ] == 0 ) {
|                 sbSize = use_128x128_superblock ? BLOCK_128X128 : BLOCK_64X64
|                 sbSize4 = Num_4x4_Blocks_High[ sbSize ]
|                 if ( MiRow - sbSize4 < MiRowStart ) {
|                     PredMv[ 0 ][ 0 ] = 0
|                     PredMv[ 0 ][ 1 ] = -(sbSize4 * MI_SIZE + INTRABC_DELAY_PIXELS) * 8
|                 } else {
|                     PredMv[ 0 ][ 0 ] = -(sbSize4 * MI_SIZE * 8)
|                     PredMv[ 0 ][ 1 ] = 0
|                 }
|             }
|         } else if ( compMode == GLOBALMV ) {
|             PredMv[ i ] = GlobalMvs[ i ]
|         } else {
|             pos = ( compMode == NEARESTMV ) ? 0 : RefMvIdx
|             if ( compMode == NEWMV && NumMvFound <\= 1 )
|                 pos = 0
|             PredMv[ i ] = RefStackMv[ pos ][ i ]
|         }
|         if ( compMode == NEWMV ) {
|             read_mv( i )
|         } else {
|             Mv[ i ] = PredMv[ i ]
|         }
|     }
| }
{:.syntax }


### Read motion mode syntax ### {#read_motion_mode_syntax}

| --------------------------------------------------------- | ---------------- |
| read_motion_mode( isCompound ) {                          | **Type**
|     if ( skip_mode ) {
|         motion_mode = SIMPLE
|         return
|     }
|     if ( !is_motion_mode_switchable ) {
|         motion_mode = SIMPLE
|         return
|     }
|     if ( Min( Block_Width[ MiSize ],
|               Block_Height[ MiSize ] ) < 8 ) {
|         motion_mode = SIMPLE
|         return
|     }
|     if ( !force_integer_mv &&
|          ( YMode == GLOBALMV \|\| YMode == GLOBAL_GLOBALMV ) ) {
|         if ( GmType[ RefFrame[ 0 ] ] > TRANSLATION ) {
|             motion_mode = SIMPLE
|             return
|         }
|     }
|     if ( isCompound \|\| RefFrame[ 1 ] == INTRA_FRAME \|\| !has_overlappable_candidates( ) ) {
|         motion_mode = SIMPLE
|         return
|     }
|     find_warp_samples()
|     if ( force_integer_mv \|\| NumSamples == 0 \|\|
|          !allow_warped_motion \|\| is_scaled( RefFrame[0] ) ) {
|         @@use_obmc                                        | S()
|         motion_mode = use_obmc ? OBMC : SIMPLE
|     } else {
|         @@motion_mode                                     | S()
|     }
| }
{:.syntax }

where is_scaled is a function that determines whether a
reference frame uses scaling and is specified as:

~~~~~ c
is_scaled( refFrame ) {
  refIdx = ref_frame_idx[ refFrame - LAST_FRAME ]
  xScale = ( ( RefUpscaledWidth[ refIdx ] << REF_SCALE_SHIFT ) + ( FrameWidth / 2 ) ) / FrameWidth
  yScale = ( ( RefFrameHeight[ refIdx ] << REF_SCALE_SHIFT ) + ( FrameHeight / 2 ) ) / FrameHeight
  noScale = 1 << REF_SCALE_SHIFT
  return xScale != noScale || yScale != noScale
}
~~~~~


### Read inter intra syntax ### {#read_inter_intra_syntax}

| --------------------------------------------------------- | ---------------- |
| read_interintra_mode( isCompound ) {                      | **Type**
|     if ( !skip_mode && enable_interintra_compound && !isCompound &&
|          MiSize >\= BLOCK_8X8 && MiSize <\= BLOCK_32X32) {
|         @@interintra                                      | S()
|         if ( interintra ) {
|             @@interintra_mode                             | S()
|             RefFrame[1] = INTRA_FRAME
|             AngleDeltaY = 0
|             AngleDeltaUV = 0
|             use_filter_intra = 0
|             @@wedge_interintra                        | S()
|             if ( wedge_interintra ) {
|                 @@wedge_index                         | S()
|                 wedge_sign = 0
|             }
|         }
|     } else {
|         interintra = 0
|     }
| }
{:.syntax }


### Read compound type syntax ### {#read_compound_type_syntax}

| --------------------------------------------------------- | ---------------- |
| read_compound_type( isCompound ) {                        | **Type**
|     comp_group_idx = 0
|     compound_idx = 1
|     if ( skip_mode ) {
|         compound_type = COMPOUND_AVERAGE
|         return
|     }
|     if ( isCompound ) {
|         n = Wedge_Bits[ MiSize ]
|         if ( enable_masked_compound ) {
|               @@comp_group_idx                            | S()
|         }
|         if ( comp_group_idx == 0 ) {
|             if ( enable_jnt_comp ) {
|                 @@compound_idx                            | S()
|                 compound_type = compound_idx ? COMPOUND_AVERAGE :
|                                                COMPOUND_DISTANCE
|             } else {
|                 compound_type = COMPOUND_AVERAGE
|             }
|         } else {
|             if ( n == 0 ) {
|                 compound_type = COMPOUND_DIFFWTD
|             } else {
|                 @@compound_type                           | S()
|             }
|         }
|         if ( compound_type == COMPOUND_WEDGE ) {
|             @@wedge_index                                 | S()
|             @@wedge_sign                                  | L(1)
|         } else if ( compound_type == COMPOUND_DIFFWTD ) {
|             @@mask_type                                   | L(1)
|         }
|     } else {
|         if ( interintra ) {
|             compound_type = wedge_interintra ? COMPOUND_WEDGE : COMPOUND_INTRA
|         } else {
|             compound_type = COMPOUND_AVERAGE
|         }
|     }
| }
{:.syntax }


### Get mode function ### {#get_mode_function}

| --------------------------------------------------------- | ---------------- |
| get_mode( refList ) {                                     | **Type**
|     if ( refList == 0 ) {
|         if ( YMode < NEAREST_NEARESTMV )
|             compMode = YMode
|         else if ( YMode == NEW_NEWMV \|\| YMode == NEW_NEARESTMV \|\| YMode == NEW_NEARMV )
|             compMode = NEWMV
|         else if ( YMode == NEAREST_NEARESTMV \|\| YMode == NEAREST_NEWMV )
|             compMode = NEARESTMV
|         else if ( YMode == NEAR_NEARMV \|\| YMode == NEAR_NEWMV )
|             compMode = NEARMV
|         else
|             compMode = GLOBALMV
|     } else {
|         if ( YMode == NEW_NEWMV \|\| YMode == NEAREST_NEWMV \|\| YMode == NEAR_NEWMV )
|             compMode = NEWMV
|         else if ( YMode == NEAREST_NEARESTMV \|\| YMode == NEW_NEARESTMV )
|             compMode = NEARESTMV
|         else if ( YMode == NEAR_NEARMV \|\| YMode == NEW_NEARMV )
|             compMode = NEARMV
|         else
|             compMode = GLOBALMV
|     }
|     return compMode
| }
{:.syntax }


### MV syntax ### {#mv_syntax}

| --------------------------------------------------------- | ---------------- |
| read_mv( ref ) {                                          | **Type**
|     diffMv[ 0 ] = 0
|     diffMv[ 1 ] = 0
|     if ( use_intrabc ) {
|         MvCtx = MV_INTRABC_CONTEXT
|     } else {
|         MvCtx = 0
|     }
|     @@mv_joint                                            | S()
|     if ( mv_joint == MV_JOINT_HZVNZ \|\| mv_joint == MV_JOINT_HNZVNZ )
|         diffMv[ 0 ] = read_mv_component( 0 )
|     if ( mv_joint == MV_JOINT_HNZVZ \|\| mv_joint == MV_JOINT_HNZVNZ )
|         diffMv[ 1 ] = read_mv_component( 1 )
|     Mv[ ref ][ 0 ] = PredMv[ ref ][ 0 ] + diffMv[ 0 ]
|     Mv[ ref ][ 1 ] = PredMv[ ref ][ 1 ] + diffMv[ 1 ]
| }
{:.syntax }


### MV component syntax ### {#mv_component_syntax}

| --------------------------------------------------------- | ---------------- |
| read_mv_component( comp ) {                               | **Type**
|     @@mv_sign                                             | S()
|     @@mv_class                                            | S()
|     if ( mv_class == MV_CLASS_0 ) {
|         @@mv_class0_bit                                   | S()
|         if ( force_integer_mv )
|             mv_class0_fr = 3
|         else
|             @@mv_class0_fr                                | S()
|         if ( allow_high_precision_mv )
|             @@mv_class0_hp                                | S()
|         else
|             mv_class0_hp = 1
|         mag = ( ( mv_class0_bit \<\< 3 ) \|
|                 ( mv_class0_fr \<\< 1 ) \|
|                   mv_class0_hp ) + 1
|     } else {
|         d = 0
|         for ( i = 0; i < mv_class; i++ ) {
|             @@mv_bit                                      | S()
|             d \|= mv_bit \<\< i
|         }
|         mag = CLASS0_SIZE \<\< ( mv_class + 2 )
|         if ( force_integer_mv )
|             mv_fr = 3
|         else
|             @@mv_fr                                       | S()
|         if ( allow_high_precision_mv )
|             @@mv_hp                                       | S()
|         else
|             mv_hp = 1
|         mag += ( ( d \<\< 3 ) \| ( mv_fr \<\< 1 ) \| mv_hp ) + 1
|     }
|     return mv_sign ? -mag : mag
| }
{:.syntax }

### Compute prediction syntax ### {#compute_prediction_syntax}

| --------------------------------------------------------- | ---------------- |
| compute_prediction() {                                    | **Type**
|     sbMask = use_128x128_superblock ? 31 : 15
|     subBlockMiRow = MiRow & sbMask
|     subBlockMiCol = MiCol & sbMask
|     for ( plane = 0; plane < 1 + HasChroma * 2; plane++ ) {
|         planeSz = get_plane_residual_size( MiSize, plane )
|         num4x4W = Num_4x4_Blocks_Wide[ planeSz ]
|         num4x4H = Num_4x4_Blocks_High[ planeSz ]
|         log2W = MI_SIZE_LOG2 + Mi_Width_Log2[ planeSz ]
|         log2H = MI_SIZE_LOG2 + Mi_Height_Log2[ planeSz ]
|         subX = (plane > 0) ? subsampling_x : 0
|         subY = (plane > 0) ? subsampling_y : 0
|         baseX = (MiCol \>\> subX) * MI_SIZE
|         baseY = (MiRow \>\> subY) * MI_SIZE
|         candRow = (MiRow \>\> subY) \<\< subY
|         candCol = (MiCol \>\> subX) \<\< subX
| 
|         IsInterIntra = ( is_inter && RefFrame[ 1 ] == INTRA_FRAME )
|         if ( IsInterIntra ) {
|             if ( interintra_mode == II_DC_PRED ) mode = DC_PRED
|             else if ( interintra_mode == II_V_PRED ) mode = V_PRED
|             else if ( interintra_mode == II_H_PRED ) mode = H_PRED
|             else mode = SMOOTH_PRED
|             predict_intra( plane, baseX, baseY,
|                            plane == 0 ? AvailL : AvailLChroma,
|                            plane == 0 ? AvailU : AvailUChroma,
|                            BlockDecoded[ plane ]
|                                        [ ( subBlockMiRow \>\> subY ) - 1 ]
|                                        [ ( subBlockMiCol \>\> subX ) + num4x4W ],
|                            BlockDecoded[ plane ]
|                                        [ ( subBlockMiRow \>\> subY ) + num4x4H ]
|                                        [ ( subBlockMiCol \>\> subX ) - 1 ],
|                            mode,
|                            log2W, log2H )
|         }
|         if ( is_inter ) {
|             predW = Block_Width[ MiSize ] \>\> subX
|             predH = Block_Height[ MiSize ] \>\> subY
|             someUseIntra = 0
|             for ( r = 0; r < (num4x4H \<\< subY); r++ )
|                 for ( c = 0; c < (num4x4W \<\< subX); c++ )
|                     if ( RefFrames[ candRow + r ][ candCol + c ][ 0 ] == INTRA_FRAME )
|                         someUseIntra = 1
|             if ( someUseIntra ) {
|                 predW = num4x4W * 4
|                 predH = num4x4H * 4
|                 candRow = MiRow
|                 candCol = MiCol
|             }
|             r = 0
|             for ( y = 0; y < num4x4H * 4; y += predH ) {
|                 c = 0
|                 for ( x = 0; x < num4x4W * 4; x += predW ) {
|                     predict_inter( plane, baseX + x, baseY + y,
|                                    predW, predH,
|                                    candRow + r, candCol + c)
|                     c++
|                 }
|                 r++
|             }
|         }
|     }
| }
{:.syntax }

### Residual syntax ### {#residual_syntax}

| --------------------------------------------------------- | ---------------- |
| residual( ) {                                             | **Type**
|     sbMask = use_128x128_superblock ? 31 : 15
|
|     widthChunks = Max( 1, Block_Width[ MiSize ] \>\> 6 )
|     heightChunks = Max( 1, Block_Height[ MiSize ] \>\> 6 )
|
|     miSizeChunk = ( widthChunks > 1 \|\| heightChunks > 1 ) ? BLOCK_64X64 : MiSize
|
|     for ( chunkY = 0; chunkY < heightChunks; chunkY++ ) {
|         for ( chunkX = 0; chunkX < widthChunks; chunkX++ ) {
|             miRowChunk = MiRow + ( chunkY \<\< 4 )
|             miColChunk = MiCol + ( chunkX \<\< 4 )
|             subBlockMiRow = miRowChunk & sbMask
|             subBlockMiCol = miColChunk & sbMask
|
|             for ( plane = 0; plane < 1 + HasChroma * 2; plane++ ) {
|                 txSz = Lossless ? TX_4X4 : get_tx_size( plane, TxSize )
|                 stepX = Tx_Width[ txSz ] \>\> 2
|                 stepY = Tx_Height[ txSz ] \>\> 2
|                 planeSz = get_plane_residual_size( miSizeChunk, plane )
|                 num4x4W = Num_4x4_Blocks_Wide[ planeSz ]
|                 num4x4H = Num_4x4_Blocks_High[ planeSz ]
|                 subX = (plane > 0) ? subsampling_x : 0
|                 subY = (plane > 0) ? subsampling_y : 0
|                 baseX = (miColChunk \>\> subX) * MI_SIZE
|                 baseY = (miRowChunk \>\> subY) * MI_SIZE
|                 if ( is_inter && !Lossless && !plane ) {
|                     transform_tree( baseX, baseY, num4x4W * 4, num4x4H * 4 )
|                 } else {
|                     baseXBlock = (MiCol \>\> subX) * MI_SIZE
|                     baseYBlock = (MiRow \>\> subY) * MI_SIZE
|                     for ( y = 0; y < num4x4H; y += stepY )
|                         for ( x = 0; x < num4x4W; x += stepX )
|                             transform_block( plane, baseXBlock, baseYBlock, txSz,
|                                              x + ( ( chunkX \<\< 4 ) \>\> subX ),
|                                              y + ( ( chunkY \<\< 4 ) \>\> subY ) )
|                 }
|             }
|         }
|     }
| }
{:.syntax }


### Transform block syntax ### {#transform_block_syntax}

| --------------------------------------------------------- | ---------------- |
| transform_block(plane, baseX, baseY, txSz, x, y) {        | **Type**
|     startX = baseX + 4 * x
|     startY = baseY + 4 * y
|     subX = (plane > 0) ? subsampling_x : 0
|     subY = (plane > 0) ? subsampling_y : 0
|     row = ( startY \<\< subY ) \>\> MI_SIZE_LOG2
|     col = ( startX \<\< subX ) \>\> MI_SIZE_LOG2
|     sbMask = use_128x128_superblock ? 31 : 15
|     subBlockMiRow = row & sbMask
|     subBlockMiCol = col & sbMask
|     stepX = Tx_Width[ txSz ] \>\> MI_SIZE_LOG2
|     stepY = Tx_Height[ txSz ] \>\> MI_SIZE_LOG2
|     maxX = (MiCols * MI_SIZE) \>\> subX
|     maxY = (MiRows * MI_SIZE) \>\> subY
|     if ( startX >\= maxX \|\| startY >\= maxY ) {
|         return
|     }
|     if ( !is_inter ) {
|         if ( ( ( plane == 0 ) && PaletteSizeY ) \|\|
|              ( ( plane != 0 ) && PaletteSizeUV ) ) {
|             predict_palette( plane, startX, startY, x, y, txSz )
|         } else {
|             isCfl = (plane > 0 && UVMode == UV_CFL_PRED)
|             if ( plane == 0 ) {
|                 mode = YMode
|             } else {
|                 mode = ( isCfl ) ? DC_PRED : UVMode
|             }
|             log2W = Tx_Width_Log2[ txSz ]
|             log2H = Tx_Height_Log2[ txSz ]
|             predict_intra( plane, startX, startY,
|                            ( plane == 0 ? AvailL : AvailLChroma ) \|\| x > 0,
|                            ( plane == 0 ? AvailU : AvailUChroma ) \|\| y > 0,
|                            BlockDecoded[ plane ]
|                                        [ ( subBlockMiRow \>\> subY ) - 1 ]
|                                        [ ( subBlockMiCol \>\> subX ) + stepX ],
|                            BlockDecoded[ plane ]
|                                        [ ( subBlockMiRow \>\> subY ) + stepY ]
|                                        [ ( subBlockMiCol \>\> subX ) - 1 ],
|                            mode,
|                            log2W, log2H )
|             if ( isCfl ) {
|                 predict_chroma_from_luma( plane, startX, startY, txSz )
|             }
|         }
|
|         if ( plane == 0 ) {
|             MaxLumaW = startX + stepX * 4
|             MaxLumaH = startY + stepY * 4
|         }
|     }
|     if ( !skip ) {
|         eob = coeffs( plane, startX, startY, txSz )
|         if ( eob > 0 )
|             reconstruct( plane, startX, startY, txSz )
|     }
|     for ( i = 0; i < stepY; i++ ) {
|         for ( j = 0; j < stepX; j++ ) {
|             LoopfilterTxSizes[ plane ]
|                              [ (row \>\> subY) + i ]
|                              [ (col \>\> subX) + j ] = txSz
|             BlockDecoded[ plane ]
|                         [ ( subBlockMiRow \>\> subY ) + i ]
|                         [ ( subBlockMiCol \>\> subX ) + j ] = 1
|         }
|     }
| }
{:.syntax }

### Transform tree syntax ### {#transform_tree_syntax}

transform_tree is used to read a number of transform blocks arranged in a transform tree.

| --------------------------------------------------------- | ---------------- |
| transform_tree( startX, startY, w, h ) {           | **Type**
|     maxX = MiCols * MI_SIZE
|     maxY = MiRows * MI_SIZE
|     if ( startX >\= maxX \|\| startY >\= maxY ) {
|         return
|     }
|     row = startY \>\> MI_SIZE_LOG2
|     col = startX \>\> MI_SIZE_LOG2
|     lumaTxSz = InterTxSizes[ row ][ col ]
|     lumaW = Tx_Width[ lumaTxSz ]
|     lumaH = Tx_Height[ lumaTxSz ]
|     if ( w <= lumaW && h <= lumaH ) {
|         txSz = find_tx_size( w, h )
|         transform_block( 0, startX, startY, txSz, 0, 0 )
|     } else {
|         if ( w > h ) {
|             transform_tree( startX, startY, w/2, h )
|             transform_tree( startX + w / 2, startY, w/2, h )
|         } else if ( w < h ) {
|             transform_tree( startX, startY, w, h/2 )
|             transform_tree( startX, startY + h/2, w, h/2 )
|         } else {
|             transform_tree( startX, startY, w/2, h/2 )
|             transform_tree( startX + w/2, startY, w/2, h/2 )
|             transform_tree( startX, startY + h/2, w/2, h/2 )
|             transform_tree( startX + w/2, startY + h/2, w/2, h/2 )
|         }
|     }
| }
{:.syntax }

where find_tx_size finds the transform size matching the given dimensions and is defined as:

~~~~~ c
find_tx_size( w, h ) {
    for ( txSz = 0; txSz < TX_SIZES_ALL; txSz++ )
        if ( Tx_Width[ txSz ] == w && Tx_Height[ txSz ] == h )
            break
    return txSz
}
~~~~~


### Get TX size function ### {#get_tx_size_function}

| --------------------------------------------------------- | ---------------- |
| get_tx_size( plane, txSz ) {                              | **Type**
|     if ( plane == 0 )
|         return txSz
|     uvTx = Max_Tx_Size_Rect[ get_plane_residual_size( MiSize, plane ) ]
|     if ( Tx_Width[ uvTx ] == 64 \|\| Tx_Height[ uvTx ] == 64 ){
|         if ( Tx_Width[ uvTx ] == 16 ) {
|             return TX_16X32
|         }
|         if ( Tx_Height[ uvTx ] == 16 ) {
|             return TX_32X16
|         }
|         return TX_32X32
|     }
|     return uvTx
| }
{:.syntax }


### Get plane residual size function ### {#get_plane_residual_size_function}

The get_plane_residual_size returns the size of a residual block for the
specified plane. (The residual block will always have width and height at least
equal to 4.)

| --------------------------------------------------------- | ---------------- |
| get_plane_residual_size( subsize, plane ) {               | **Type**
|     subx = plane > 0 ? subsampling_x : 0
|     suby = plane > 0 ? subsampling_y : 0
|     return Subsampled_Size[ subsize ][ subx ][ suby ]
| }
{:.syntax }

The Subsampled_Size table is defined as:

~~~~~ c
Subsampled_Size[ BLOCK_SIZES ][ 2 ][ 2 ] = {
  { { BLOCK_4X4,    BLOCK_4X4},      {BLOCK_4X4,     BLOCK_4X4} },
  { { BLOCK_4X8,    BLOCK_4X4},      {BLOCK_INVALID, BLOCK_4X4} },
  { { BLOCK_8X4,    BLOCK_INVALID},  {BLOCK_4X4,     BLOCK_4X4} },
  { { BLOCK_8X8,    BLOCK_8X4},      {BLOCK_4X8,     BLOCK_4X4} },
  { {BLOCK_8X16,    BLOCK_8X8},      {BLOCK_INVALID, BLOCK_4X8} },
  { {BLOCK_16X8,    BLOCK_INVALID},  {BLOCK_8X8,     BLOCK_8X4} },
  { {BLOCK_16X16,   BLOCK_16X8},     {BLOCK_8X16,    BLOCK_8X8} },
  { {BLOCK_16X32,   BLOCK_16X16},    {BLOCK_INVALID, BLOCK_8X16} },
  { {BLOCK_32X16,   BLOCK_INVALID},  {BLOCK_16X16,   BLOCK_16X8} },
  { {BLOCK_32X32,   BLOCK_32X16},    {BLOCK_16X32,   BLOCK_16X16} },
  { {BLOCK_32X64,   BLOCK_32X32},    {BLOCK_INVALID, BLOCK_16X32} },
  { {BLOCK_64X32,   BLOCK_INVALID},  {BLOCK_32X32,   BLOCK_32X16} },
  { {BLOCK_64X64,   BLOCK_64X32},    {BLOCK_32X64,   BLOCK_32X32} },
  { {BLOCK_64X128,  BLOCK_64X64},    {BLOCK_INVALID, BLOCK_32X64} },
  { {BLOCK_128X64,  BLOCK_INVALID},  {BLOCK_64X64,   BLOCK_64X32} },
  { {BLOCK_128X128, BLOCK_128X64},   {BLOCK_64X128,  BLOCK_64X64} },
  { {BLOCK_4X16,    BLOCK_4X8},      {BLOCK_INVALID, BLOCK_4X8} },
  { {BLOCK_16X4,    BLOCK_INVALID},  {BLOCK_8X4,     BLOCK_8X4} },
  { {BLOCK_8X32,    BLOCK_8X16},     {BLOCK_INVALID, BLOCK_4X16} },
  { {BLOCK_32X8,    BLOCK_INVALID},  {BLOCK_16X8,    BLOCK_16X4} },
  { {BLOCK_16X64,   BLOCK_16X32},    {BLOCK_INVALID, BLOCK_8X32} },
  { {BLOCK_64X16,   BLOCK_INVALID},  {BLOCK_32X16,   BLOCK_32X8} },
}
~~~~~


### Coefficients syntax ### {#coefficients_syntax}

| --------------------------------------------------------- | ---------------- |
| coeffs( plane, startX, startY, txSz ) {                   | **Type**
|     x4 = startX \>\> 2
|     y4 = startY \>\> 2
|     w4 = Tx_Width[ txSz ] \>\> 2
|     h4 = Tx_Height[ txSz ] \>\> 2
|
|     txSzCtx = ( Tx_Size_Sqr[txSz] + Tx_Size_Sqr_Up[txSz] + 1 ) \>\> 1
|     ptype = plane > 0
|     segEob = ( txSz == TX_16X64 \|\| txSz == TX_64X16 ) ? 512 :
|                 Min( 1024, Tx_Width[ txSz ] * Tx_Height[ txSz ] )
|
|     for ( c = 0; c < segEob; c++ )
|         Quant[c] = 0
|     for ( i = 0; i < 64; i++ )
|         for ( j = 0; j < 64; j++ )
|             Dequant[ i ][ j ] = 0
|
|     eob = 0
|     culLevel = 0
|     dcCategory = 0
|
|     @@all_zero                                            | S()
|     if ( all_zero ) {
|         c = 0
|         if ( plane == 0 ) {
|             for ( i = 0; i < w4; i++ ) {
|                 for ( j = 0; j < h4; j++ ) {
|                     TxTypes[ y4 + j ][ x4 + i ] = DCT_DCT
|                 }
|             }
|         }
|     } else {
|         if ( plane == 0 )
|             transform_type( x4, y4, txSz )
|         PlaneTxType = compute_tx_type( plane, txSz, x4, y4 )
|         scan = get_scan( txSz )
|
|         eobMultisize = Min( Tx_Width_Log2[ txSz ], 5) + Min( Tx_Height_Log2[ txSz ], 5) - 4
|         if ( eobMultisize == 0 ) {
|             @@eob_pt_16                                   | S()
|             eobPt = eob_pt_16 + 1
|         } else if ( eobMultisize == 1 ) {
|             @@eob_pt_32                                   | S()
|             eobPt = eob_pt_32 + 1
|         } else if ( eobMultisize == 2 ) {
|             @@eob_pt_64                                   | S()
|             eobPt = eob_pt_64 + 1
|         } else if ( eobMultisize == 3 ) {
|             @@eob_pt_128                                  | S()
|             eobPt = eob_pt_128 + 1
|         } else if ( eobMultisize == 4 ) {
|             @@eob_pt_256                                  | S()
|             eobPt = eob_pt_256 + 1
|         } else if ( eobMultisize == 5 ) {
|             @@eob_pt_512                                  | S()
|             eobPt = eob_pt_512 + 1
|         } else {
|             @@eob_pt_1024                                 | S()
|             eobPt = eob_pt_1024 + 1
|         }
|
|         eob = ( eobPt < 2 ) ? eobPt : ( ( 1 \<\< ( eobPt - 2 ) ) + 1 )
|         eobShift = Max( -1, eobPt - 3 )
|         if ( eobShift >\= 0 ) {
|             @@eob_extra                                   | S()
|             if ( eob_extra ) {
|                 eob += ( 1 \<\< eobShift )
|             }
|
|             for ( i = 1; i < Max( 0, eobPt - 2 ); i++ ) {
|                 eobShift = Max( 0, eobPt - 2 ) - 1 - i
|                 @@eob_extra_bit                           | L(1)
|                 if ( eob_extra_bit ) {
|                     eob += ( 1 \<\< eobShift )
|                 }
|             }
|         }
|         for ( c = eob - 1; c >\= 0; c\-\- ) {
|             pos = scan[ c ]
|             if ( c == ( eob - 1 ) ) {
|                 @@coeff_base_eob                          | S()
|                 level = coeff_base_eob + 1
|             } else {
|                 @@coeff_base                              | S()
|                 level = coeff_base
|             }
|
|             if ( level > NUM_BASE_LEVELS ) {
|                 for ( idx = 0;
|                       idx < COEFF_BASE_RANGE / ( BR_CDF_SIZE - 1 );
|                       idx++ ) {
|                     @@coeff_br                            | S()
|                     level += coeff_br
|                     if ( coeff_br < ( BR_CDF_SIZE - 1 ) )
|                         break
|                 }
|             }
|             Quant[ pos ] = level
|         }
|
|         for ( c = 0; c < eob; c++ ) {
|             pos = scan[ c ]
|             if ( Quant[ pos ] != 0 ) {
|                 if ( c == 0 ) {
|                     @@dc_sign                             | S()
|                     sign = dc_sign
|                 } else {
|                     @@sign_bit                            | L(1)
|                     sign = sign_bit
|                 }
|             } else {
|                 sign = 0
|             }
|             if ( Quant[ pos ] >
|                 ( NUM_BASE_LEVELS + COEFF_BASE_RANGE ) ) {
|                 length = 0
|                 do {
|                     length++
|                     @@golomb_length_bit                   | L(1)
|                 } while ( !golomb_length_bit )
|                 x = 1
|                 for ( i = length - 2; i >\= 0; i\-\- ) {
|                     @@golomb_data_bit                     | L(1)
|                     x = ( x \<\< 1 ) \| golomb_data_bit
|                 }
|                Quant[ pos ] = x + COEFF_BASE_RANGE + NUM_BASE_LEVELS
|             }
|             if ( pos == 0 && Quant[ pos ] > 0 ) {
|                 dcCategory = sign ? 1 : 2
|             }
|             Quant[ pos ] = Quant[ pos ] & 0xFFFFF
|             culLevel += Quant[ pos ]
|             if ( sign )
|                 Quant[ pos ] = - Quant[ pos ]
|         }
|         culLevel = Min( 63, culLevel )
|     }
|
|     for ( i = 0; i < w4; i++ ) {
|         AboveLevelContext[ plane ][ x4 + i ] = culLevel
|         AboveDcContext[ plane ][ x4 + i ] = dcCategory
|     }
|     for ( i = 0; i < h4; i++ ) {
|         LeftLevelContext[ plane ][ y4 + i ] = culLevel
|         LeftDcContext[ plane ][ y4 + i ] = dcCategory
|     }
|
|     return eob
| }
{:.syntax }


### Compute transform type function ### {#compute_transform_type_function}

| --------------------------------------------------------- | ---------------- |
| compute_tx_type( plane, txSz, blockX, blockY ) {          | **Type**
|     txSzSqrUp = Tx_Size_Sqr_Up[ txSz ]
|
|     if ( Lossless \|\| txSzSqrUp > TX_32X32 )
|         return DCT_DCT
|
|     txSet = get_tx_set( txSz )
|
|     if ( plane == 0 ) {
|         return TxTypes[ blockY ][ blockX ]
|     }
|
|     if ( is_inter ) {
|         x4 = Max( MiCol, blockX \<\< subsampling_x )
|         y4 = Max( MiRow, blockY \<\< subsampling_y )
|         txType = TxTypes[ y4 ][ x4 ]
|         if ( !is_tx_type_in_set( txSet, txType ) )
|             return DCT_DCT
|         return txType
|     }
|
|     txType = Mode_To_Txfm[ UVMode ]
|     if ( !is_tx_type_in_set( txSet, txType ) )
|         return DCT_DCT
|     return txType
| }
|
| is_tx_type_in_set( txSet, txType ) {
|     return is_inter ? Tx_Type_In_Set_Inter[ txSet ][ txType ] :
|                       Tx_Type_In_Set_Intra[ txSet ][ txType ]
| }
{:.syntax }

where the tables Tx_Type_In_Set_Inter and Tx_Type_In_Set_Intra are specified as follows:

~~~~~ c
Tx_Type_In_Set_Intra[ TX_SET_TYPES_INTRA ][ TX_TYPES ] = {
  {
    1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  },
  {
    1, 1, 1, 1, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0,
  },
  {
    1, 1, 1, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0,
  }
}

Tx_Type_In_Set_Inter[ TX_SET_TYPES_INTER ][ TX_TYPES ] = {
  {
    1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  },
  {
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
  },
  {
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0,
  },
  {
    1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0,
  }
}
~~~~~


### Get scan function ### {#get_scan_function}

| --------------------------------------------------------- | ---------------- |
| get_mrow_scan( txSz ) {                                   | **Type**
|     if ( txSz == TX_4X4 )
|         return Mrow_Scan_4x4
|     else if ( txSz == TX_4X8 )
|         return Mrow_Scan_4x8
|     else if ( txSz == TX_8X4 )
|         return Mrow_Scan_8x4
|     else if ( txSz == TX_8X8 )
|         return Mrow_Scan_8x8
|     else if ( txSz == TX_8X16 )
|         return Mrow_Scan_8x16
|     else if ( txSz == TX_16X8 )
|         return Mrow_Scan_16x8
|     else if ( txSz == TX_16X16 )
|         return Mrow_Scan_16x16
|     else if ( txSz == TX_4X16 )
|         return Mrow_Scan_4x16
|     return Mrow_Scan_16x4
| }
|
| get_mcol_scan( txSz ) {
|     if ( txSz == TX_4X4 )
|         return Mcol_Scan_4x4
|     else if ( txSz == TX_4X8 )
|         return Mcol_Scan_4x8
|     else if ( txSz == TX_8X4 )
|         return Mcol_Scan_8x4
|     else if ( txSz == TX_8X8 )
|         return Mcol_Scan_8x8
|     else if ( txSz == TX_8X16 )
|         return Mcol_Scan_8x16
|     else if ( txSz == TX_16X8 )
|         return Mcol_Scan_16x8
|     else if ( txSz == TX_16X16 )
|         return Mcol_Scan_16x16
|     else if ( txSz == TX_4X16 )
|         return Mcol_Scan_4x16
|     return Mcol_Scan_16x4
| }
|
| get_default_scan( txSz ) {
|     if ( txSz == TX_4X4 )
|         return Default_Scan_4x4
|     else if ( txSz == TX_4X8 )
|         return Default_Scan_4x8
|     else if ( txSz == TX_8X4 )
|         return Default_Scan_8x4
|     else if ( txSz == TX_8X8 )
|         return Default_Scan_8x8
|     else if ( txSz == TX_8X16 )
|         return Default_Scan_8x16
|     else if ( txSz == TX_16X8 )
|         return Default_Scan_16x8
|     else if ( txSz == TX_16X16 )
|         return Default_Scan_16x16
|     else if ( txSz == TX_16X32 )
|         return Default_Scan_16x32
|     else if ( txSz == TX_32X16 )
|         return Default_Scan_32x16
|     else if ( txSz == TX_4X16 )
|         return Default_Scan_4x16
|     else if ( txSz == TX_16X4 )
|         return Default_Scan_16x4
|     else if ( txSz == TX_8X32 )
|         return Default_Scan_8x32
|     else if ( txSz == TX_32X8 )
|         return Default_Scan_32x8
|     return Default_Scan_32x32
| }
|
| get_scan( txSz ) {
|     if ( txSz == TX_16X64 ) {
|         return Default_Scan_16x32
|     }
|     if ( txSz == TX_64X16 ) {
|         return Default_Scan_32x16
|     }
|     if ( Tx_Size_Sqr_Up[ txSz ] == TX_64X64 ) {
|         return Default_Scan_32x32
|     }
|
|     if ( PlaneTxType == IDTX ) {
|         return get_default_scan( txSz )
|     }
|
|     preferRow = ( PlaneTxType == V_DCT \|\|
|                   PlaneTxType == V_ADST \|\|
|                   PlaneTxType == V_FLIPADST )
|
|     preferCol = ( PlaneTxType == H_DCT \|\|
|                   PlaneTxType == H_ADST \|\|
|                   PlaneTxType == H_FLIPADST )
|
|     if ( preferRow ) {
|         return get_mrow_scan( txSz )
|     } else if ( preferCol ) {
|         return get_mcol_scan( txSz )
|     }
|     return get_default_scan( txSz )
| }
{:.syntax }


### Intra angle info luma syntax ### {#intra_angle_info_luma_syntax}

| --------------------------------------------------------- | ---------------- |
| intra_angle_info_y( ) {                                   | **Type**
|     AngleDeltaY = 0
|     if ( MiSize >\= BLOCK_8X8 ) {
|         if ( is_directional_mode( YMode ) ) {
|             @@angle_delta_y                               | S()
|             AngleDeltaY = angle_delta_y - MAX_ANGLE_DELTA
|         }
|     }
| }
{:.syntax }


### Intra angle info chroma syntax ### {#intra_angle_info_chroma_syntax}

| --------------------------------------------------------- | ---------------- |
| intra_angle_info_uv( ) {                                  | **Type**
|     AngleDeltaUV = 0
|     if ( MiSize >\= BLOCK_8X8 ) {
|         if ( is_directional_mode( UVMode ) ) {
|             @@angle_delta_uv                              | S()
|             AngleDeltaUV = angle_delta_uv - MAX_ANGLE_DELTA
|         }
|     }
| }
{:.syntax }


### Is directional mode function ### {#is_directional_mode_function}

| --------------------------------------------------------- | ---------------- |
| is_directional_mode( mode ) {                             | **Type**
|     if ( ( mode >\= V_PRED ) && ( mode <\= D67_PRED ) ) {
|         return 1
|     }
|     return 0
| }
{:.syntax }


### Read CFL alphas syntax ### {#read_cfl_alphas_syntax}

| --------------------------------------------------------- | ---------------- |
| read_cfl_alphas() {                                       | **Type**
|     @@cfl_alpha_signs                                     | S()
|     signU = (cfl_alpha_signs + 1 ) / 3
|     signV = (cfl_alpha_signs + 1 ) % 3
|     if ( signU != CFL_SIGN_ZERO ) {
|         @@cfl_alpha_u                                     | S()
|         CflAlphaU = 1 + cfl_alpha_u
|         if ( signU == CFL_SIGN_NEG )
|             CflAlphaU = -CflAlphaU
|     } else {
|       CflAlphaU = 0
|     }
|     if ( signV != CFL_SIGN_ZERO ) {
|         @@cfl_alpha_v                                     | S()
|         CflAlphaV = 1 + cfl_alpha_v
|         if ( signV == CFL_SIGN_NEG )
|             CflAlphaV = -CflAlphaV
|     } else {
|       CflAlphaV = 0
|     }
{:.syntax }


### Palette mode info syntax ### {#palette_mode_info_syntax}

| --------------------------------------------------------- | ---------------- |
| palette_mode_info( ) {                                    | **Type**
|     bsizeCtx = Mi_Width_Log2[ MiSize ] + Mi_Height_Log2[ MiSize ] - 2
|     if ( YMode == DC_PRED ) {
|         @@has_palette_y                                   | S()
|         if ( has_palette_y ) {
|             @@palette_size_y_minus_2                      | S()
|             PaletteSizeY = palette_size_y_minus_2 + 2
|             cacheN = get_palette_cache( 0 )
|             idx = 0
|             for ( i = 0; i < cacheN && idx < PaletteSizeY; i++ ) {
|                 @@use_palette_color_cache_y               | L(1)
|                 if ( use_palette_color_cache_y ) {
|                     palette_colors_y[ idx ] = PaletteCache[ i ]
|                     idx++
|                 }
|             }
|             if ( idx < PaletteSizeY ) {
|                 @@palette_colors_y[ idx ]                 | L(BitDepth)
|                 idx++
|             }
|             if ( idx < PaletteSizeY ) {
|                 minBits = BitDepth - 3
|                 @@palette_num_extra_bits_y                | L(2)
|                 paletteBits = minBits + palette_num_extra_bits_y
|             }
|             while ( idx < PaletteSizeY ) {
|                 @@palette_delta_y                         | L(paletteBits)
|                 palette_delta_y++
|                 palette_colors_y[ idx ] =
|                           Clip1( palette_colors_y[ idx - 1 ] +
|                                  palette_delta_y )
|                 range = ( 1 \<\< BitDepth ) - palette_colors_y[ idx ] - 1
|                 paletteBits = Min( paletteBits, CeilLog2( range ) )
|                 idx++
|             }
|             sort( palette_colors_y, 0, PaletteSizeY - 1 )
|         }
|     }
|     if ( HasChroma && UVMode == DC_PRED ) {
|         @@has_palette_uv                                  | S()
|         if ( has_palette_uv ) {
|             @@palette_size_uv_minus_2                     | S()
|             PaletteSizeUV = palette_size_uv_minus_2 + 2
|             cacheN = get_palette_cache( 1 )
|             idx = 0
|             for ( i = 0; i < cacheN && idx < PaletteSizeUV; i++ ) {
|                 @@use_palette_color_cache_u               | L(1)
|                 if ( use_palette_color_cache_u ) {
|                     palette_colors_u[ idx ] = PaletteCache[ i ]
|                     idx++
|                 }
|             }
|             if ( idx < PaletteSizeUV ) {
|                 @@palette_colors_u[ idx ]                 | L(BitDepth)
|                 idx++
|             }
|             if ( idx < PaletteSizeUV ) {
|                 minBits = BitDepth - 3
|                 @@palette_num_extra_bits_u                | L(2)
|                 paletteBits = minBits + palette_num_extra_bits_u
|             }
|             while ( idx < PaletteSizeUV ) {
|                 @@palette_delta_u                         | L(paletteBits)
|                 palette_colors_u[ idx ] =
|                           Clip1( palette_colors_u[ idx - 1 ] +
|                                  palette_delta_u )
|                 range = ( 1 \<\< BitDepth ) - palette_colors_u[ idx ]
|                 paletteBits = Min( paletteBits, CeilLog2( range ) )
|                 idx++
|             }
|             sort( palette_colors_u, 0, PaletteSizeUV - 1 )
|
|             @@delta_encode_palette_colors_v               | L(1)
|             if ( delta_encode_palette_colors_v ) {
|                 minBits = BitDepth - 4
|                 maxVal = 1 \<\< BitDepth
|                 @@palette_num_extra_bits_v                | L(2)
|                 paletteBits = minBits + palette_num_extra_bits_v
|                 @@palette_colors_v[ 0 ]                   | L(BitDepth)
|                 for ( idx = 1; idx < PaletteSizeUV; idx++ ) {
|                     @@palette_delta_v                     | L(paletteBits)
|                     if ( palette_delta_v ) {
|                         @@palette_delta_sign_bit_v        | L(1)
|                         if ( palette_delta_sign_bit_v ) {
|                             palette_delta_v = -palette_delta_v
|                         }
|                     }
|                     val = palette_colors_v[ idx - 1 ] + palette_delta_v
|                     if ( val < 0 ) val += maxVal
|                     if ( val >\= maxVal ) val -= maxVal
|                     palette_colors_v[ idx ] = Clip1( val )
|                 }
|             } else {
|                 for ( idx = 0; idx < PaletteSizeUV; idx++ ) {
|                     @@palette_colors_v[ idx ]             | L(BitDepth)
|                 }
|             }
|         }
|     }
| }
{:.syntax }

The function sort( arr, i1, i2 ) sorts a subarray of the array arr in-place into
ascending order. The subarray to be sorted is between indices i1 and i2
inclusive.

**Note:** The palette colors are generated in ascending order. The palette cache
is also in ascending order. This means that the sort function can be replaced in
implementations by a merge of two sorted lists.
{:.alert .alert-info }

where the function get_palette_cache, which merges the above and left palettes
to form a cache, is specified as follows:

| --------------------------------------------------------- | ---------------- |
| get_palette_cache( plane ) {                              | **Type**
|     aboveN = 0
|     if ( ( MiRow * MI_SIZE ) % 64 ) {
|         aboveN = PaletteSizes[ plane ][ MiRow - 1 ][ MiCol ]
|     }
|     leftN = 0
|     if ( AvailL ) {
|         leftN = PaletteSizes[ plane ][ MiRow ][ MiCol - 1 ]
|     }
|     aboveIdx = 0
|     leftIdx = 0
|     n = 0
|     while ( aboveIdx < aboveN  && leftIdx < leftN ) {
|         aboveC = PaletteColors[ plane ][ MiRow - 1 ][ MiCol ][ aboveIdx ]
|         leftC = PaletteColors[ plane ][ MiRow ][ MiCol - 1 ][ leftIdx ]
|         if ( leftC < aboveC ) {
|             if ( n == 0 \|\| leftC != PaletteCache[ n - 1 ] ) {
|                 PaletteCache[ n ] = leftC
|                 n++
|             }
|             leftIdx++
|         } else {
|             if ( n == 0 \|\| aboveC != PaletteCache[ n - 1 ] ) {
|                 PaletteCache[ n ] = aboveC
|                 n++
|             }
|             aboveIdx++
|             if ( leftC == aboveC ) {
|                 leftIdx++
|             }
|         }
|     }
|     while ( aboveIdx < aboveN ) {
|         val = PaletteColors[ plane ][ MiRow - 1 ][ MiCol ][ aboveIdx ]
|         aboveIdx++
|         if ( n == 0 \|\| val != PaletteCache[ n - 1 ] ) {
|             PaletteCache[ n ] = val
|             n++
|         }
|     }
|     while ( leftIdx < leftN ) {
|         val = PaletteColors[ plane ][ MiRow ][ MiCol - 1 ][ leftIdx ]
|         leftIdx++
|         if ( n == 0 \|\| val != PaletteCache[ n - 1 ] ) {
|             PaletteCache[ n ] = val
|             n++
|         }
|     }
|     return n
| }
{:.syntax }

**Note:** get_palette_cache is equivalent to sorting the available palette
colors from above and left together and removing any duplicates.
{:.alert .alert-info }


### Transform type syntax ### {#transform_type_syntax}

| --------------------------------------------------------- | ---------------- |
| transform_type( x4, y4, txSz ) {                          | **Type**
|     set = get_tx_set( txSz )
|
|     if ( set > 0 &&
|          ( segmentation_enabled ? get_qindex( 1, segment_id ) : base_q_idx ) > 0 ) {
|         if ( is_inter ) {
|             @@inter_tx_type                               | S()
|             if ( set == TX_SET_INTER_1 )
|                 TxType = Tx_Type_Inter_Inv_Set1[ inter_tx_type ]
|             else if ( set == TX_SET_INTER_2 )
|                 TxType = Tx_Type_Inter_Inv_Set2[ inter_tx_type ]
|             else
|                 TxType = Tx_Type_Inter_Inv_Set3[ inter_tx_type ]
|         } else {
|             @@intra_tx_type                               | S()
|             if ( set == TX_SET_INTRA_1 )
|                 TxType = Tx_Type_Intra_Inv_Set1[ intra_tx_type ]
|             else
|                 TxType = Tx_Type_Intra_Inv_Set2[ intra_tx_type ]
|         }
|     } else {
|         TxType = DCT_DCT
|     }
|     for ( i = 0; i < ( Tx_Width[ txSz ] \>\> 2 ); i++ ) {
|         for ( j = 0; j < ( Tx_Height[ txSz ] \>\> 2 ); j++ ) {
|             TxTypes[ y4 + j ][ x4 + i ] = TxType
|         }
|     }
| }
{:.syntax }

where the inversion tables used in the function are specified as follows:

~~~~~ c
Tx_Type_Intra_Inv_Set1[ 7 ]  = { IDTX, DCT_DCT, V_DCT, H_DCT, ADST_ADST, ADST_DCT, DCT_ADST }
Tx_Type_Intra_Inv_Set2[ 5 ]  = { IDTX, DCT_DCT, ADST_ADST, ADST_DCT, DCT_ADST }
Tx_Type_Inter_Inv_Set1[ 16 ] = { IDTX, V_DCT, H_DCT, V_ADST, H_ADST, V_FLIPADST, H_FLIPADST,
                                DCT_DCT, ADST_DCT, DCT_ADST, FLIPADST_DCT, DCT_FLIPADST, ADST_ADST,
                                FLIPADST_FLIPADST, ADST_FLIPADST, FLIPADST_ADST }
Tx_Type_Inter_Inv_Set2[ 12 ] = { IDTX, V_DCT, H_DCT, DCT_DCT, ADST_DCT, DCT_ADST, FLIPADST_DCT,
                                 DCT_FLIPADST, ADST_ADST, FLIPADST_FLIPADST, ADST_FLIPADST,
                                 FLIPADST_ADST }
Tx_Type_Inter_Inv_Set3[ 2 ]  = { IDTX, DCT_DCT }
~~~~~


### Get transform set function ### {#get_transform_set_function}

| --------------------------------------------------------- | ---------------- |
| get_tx_set( txSz ) {                                      | **Type**
|     txSzSqr = Tx_Size_Sqr[ txSz ]
|     txSzSqrUp = Tx_Size_Sqr_Up[ txSz ]
|     if ( txSzSqrUp > TX_32X32 )
|         return TX_SET_DCTONLY
|     if ( is_inter ) {
|         if ( reduced_tx_set \|\| txSzSqrUp == TX_32X32 ) return TX_SET_INTER_3
|         else if ( txSzSqr == TX_16X16 ) return TX_SET_INTER_2
|         return TX_SET_INTER_1
|     } else {
|         if ( txSzSqrUp == TX_32X32 ) return TX_SET_DCTONLY
|         else if ( reduced_tx_set ) return TX_SET_INTRA_2
|         else if ( txSzSqr == TX_16X16 ) return TX_SET_INTRA_2
|         return TX_SET_INTRA_1
|     }
| }
{:.syntax }


### Palette tokens syntax ### {#palette_tokens_syntax}

| --------------------------------------------------------- | ---------------- |
| palette_tokens( ) {                                       | **Type**
|     blockHeight = Block_Height[ MiSize ]
|     blockWidth = Block_Width[ MiSize ]
|     onscreenHeight = Min( blockHeight, (MiRows - MiRow) * MI_SIZE )
|     onscreenWidth = Min( blockWidth, (MiCols - MiCol) * MI_SIZE )
|
|     if ( PaletteSizeY ) {
|         @@color_index_map_y                               | NS(PaletteSizeY)
|         ColorMapY[0][0] = color_index_map_y
|         for ( i = 1; i < onscreenHeight + onscreenWidth - 1; i++ ) {
|             for ( j = Min( i, onscreenWidth - 1 );
|                       j >\= Max( 0, i - onscreenHeight + 1 ); j\-\- ) {
|                 get_palette_color_context(
|                     ColorMapY, ( i - j ), j, PaletteSizeY )
|                 @@palette_color_idx_y                     | S()
|                 ColorMapY[ i - j ][ j ] = ColorOrder[ palette_color_idx_y ]
|             }
|         }
|         for ( i = 0; i < onscreenHeight; i++ ) {
|             for ( j = onscreenWidth; j < blockWidth; j++ ) {
|                 ColorMapY[ i ][ j ] = ColorMapY[ i ][ onscreenWidth - 1 ]
|             }
|         }
|         for ( i = onscreenHeight; i < blockHeight; i++ ) {
|             for ( j = 0; j < blockWidth; j++ ) {
|                 ColorMapY[ i ][ j ] = ColorMapY[ onscreenHeight - 1 ][ j ]
|             }
|         }
|     }
|
|     if ( PaletteSizeUV ) {
|         @@color_index_map_uv                              | NS(PaletteSizeUV)
|         ColorMapUV[0][0] = color_index_map_uv
|         blockHeight = blockHeight \>\> subsampling_y
|         blockWidth = blockWidth \>\> subsampling_x
|         onscreenHeight = onscreenHeight \>\> subsampling_y
|         onscreenWidth = onscreenWidth \>\> subsampling_x
|         if ( blockWidth < 4 ) {
|             blockWidth += 2
|             onscreenWidth += 2
|         }
|         if ( blockHeight < 4 ) {
|             blockHeight += 2
|             onscreenHeight += 2
|         }
|
|         for ( i = 1; i < onscreenHeight + onscreenWidth - 1; i++ ) {
|             for ( j = Min( i, onscreenWidth - 1 );
|                       j >\= Max( 0, i - onscreenHeight + 1 ); j\-\- ) {
|                 get_palette_color_context(
|                     ColorMapUV, ( i - j ), j, PaletteSizeUV )
|                 @@palette_color_idx_uv                    | S()
|                 ColorMapUV[ i - j ][ j ] = ColorOrder[ palette_color_idx_uv ]
|             }
|         }
|         for ( i = 0; i < onscreenHeight; i++ ) {
|             for ( j = onscreenWidth; j < blockWidth; j++ ) {
|                 ColorMapUV[ i ][ j ] = ColorMapUV[ i ][ onscreenWidth - 1 ]
|             }
|         }
|         for ( i = onscreenHeight; i < blockHeight; i++ ) {
|             for ( j = 0; j < blockWidth; j++ ) {
|                 ColorMapUV[ i ][ j ] = ColorMapUV[ onscreenHeight - 1 ][ j ]
|             }
|         }
|     }
| }
{:.syntax }


### Palette color context function ### {#palette_color_context_function}

| --------------------------------------------------------- | ---------------- |
| get_palette_color_context( colorMap, r, c, n ) {          | **Type**
|     for ( i = 0; i < PALETTE_COLORS; i++ ) {
|         scores[ i ] = 0
|         ColorOrder[i] = i
|     }
|     if ( c > 0 ) {
|         neighbor = colorMap[ r ][ c - 1 ]
|         scores[ neighbor ] += 2
|     }
|     if ( ( r > 0 ) && ( c > 0 ) ) {
|         neighbor = colorMap[ r - 1 ][ c - 1 ]
|         scores[ neighbor ] += 1
|     }
|     if ( r > 0 ) {
|         neighbor = colorMap[ r - 1 ][ c ]
|         scores[ neighbor ] += 2
|     }
|     for ( i = 0; i < PALETTE_NUM_NEIGHBORS; i++ ) {
|         maxScore = scores[ i ]
|         maxIdx = i
|         for ( j = i + 1; j < n; j++ ) {
|             if ( scores[ j ] > maxScore ) {
|                 maxScore = scores[ j ]
|                 maxIdx = j
|             }
|         }
|         if ( maxIdx != i ) {
|             maxScore = scores[ maxIdx ]
|             maxColorOrder = ColorOrder[ maxIdx ]
|             for ( k = maxIdx; k > i; k\-\- ) {
|                 scores[ k ] = scores[ k - 1 ]
|                 ColorOrder[ k ] = ColorOrder[ k - 1 ]
|             }
|             scores[ i ] = maxScore
|             ColorOrder[ i ] = maxColorOrder
|         }
|     }
|     ColorContextHash = 0
|     for ( i = 0; i < PALETTE_NUM_NEIGHBORS; i++ ) {
|         ColorContextHash += scores[ i ] * Palette_Color_Hash_Multipliers[ i ]
|     }
| }
{:.syntax }


### Is inside function ### {#is_inside_function}

is_inside determines whether a candidate position is inside the current tile.

| --------------------------------------------------------- | ---------------- |
| is_inside( candidateR, candidateC ) {                     | **Type**
|     return ( candidateC >\= MiColStart &&
|              candidateC < MiColEnd &&
|              candidateR >\= MiRowStart &&
|              candidateR < MiRowEnd )
| }
{:.syntax }


### Is inside filter region function ### {#is_inside_filter_region_function}

is_inside_filter_region determines whether a candidate position is inside the region that is being used for CDEF filtering.

| --------------------------------------------------------- | ---------------- |
| is_inside_filter_region( candidateR, candidateC ) {       | **Type**
|     colStart = 0
|     colEnd = MiCols
|     rowStart = 0
|     rowEnd = MiRows
|     return (candidateC >\= colStart &&
|             candidateC < colEnd &&
|             candidateR >\= rowStart &&
|             candidateR < rowEnd)
| }
{:.syntax }


### Clamp MV row function ### {#clamp_mv_row_function}

| --------------------------------------------------------- | ---------------- |
| clamp_mv_row( mvec, border ) {                            | **Type**
|     bh4 = Num_4x4_Blocks_High[ MiSize ]
|     mbToTopEdge = -((MiRow * MI_SIZE) * 8)
|     mbToBottomEdge = ((MiRows - bh4 - MiRow) * MI_SIZE) * 8
|     return Clip3( mbToTopEdge - border, mbToBottomEdge + border, mvec )
| }
{:.syntax }


### Clamp MV col function ### {#clamp_mv_col_function}

| --------------------------------------------------------- | ---------------- |
| clamp_mv_col( mvec, border ) {                            | **Type**
|     bw4 = Num_4x4_Blocks_Wide[ MiSize ]
|     mbToLeftEdge = -((MiCol * MI_SIZE) * 8)
|     mbToRightEdge = ((MiCols - bw4 - MiCol) * MI_SIZE) * 8
|     return Clip3( mbToLeftEdge - border, mbToRightEdge + border, mvec )
| }
{:.syntax }


### Clear CDEF function ### {#clear_cdef_function}

| --------------------------------------------------------- | ---------------- |
| clear_cdef( r, c ) {                                      | **Type**
|     cdef_idx[ r ][ c ] = -1
|     if ( use_128x128_superblock ) {
|         cdefSize4 = Num_4x4_Blocks_Wide[ BLOCK_64X64 ]
|         cdef_idx[ r ][ c + cdefSize4 ] = -1
|         cdef_idx[ r + cdefSize4][ c ] = -1
|         cdef_idx[ r + cdefSize4][ c + cdefSize4 ] = -1
|     }
| }
{:.syntax }


### Read CDEF syntax ### {#read_cdef_syntax}

| --------------------------------------------------------- | ---------------- |
| read_cdef( ) {                                            | **Type**
|     if ( skip \|\| CodedLossless \|\| !enable_cdef \|\| allow_intrabc) {
|         return
|     }
|     cdefSize4 = Num_4x4_Blocks_Wide[ BLOCK_64X64 ]
|     cdefMask4 = ~(cdefSize4 - 1)
|     r = MiRow & cdefMask4
|     c = MiCol & cdefMask4
|     if ( cdef_idx[ r ][ c ] == -1 ) {
|         @@cdef_idx[ r ][ c ]                              | L(cdef_bits)
|         w4 = Num_4x4_Blocks_Wide[ MiSize ]
|         h4 = Num_4x4_Blocks_High[ MiSize ]
|         for ( i = r; i < r + h4 ; i += cdefSize4 ) {
|             for ( j = c; j < c + w4 ; j += cdefSize4 ) {
|                 cdef_idx[ i ][ j ] = cdef_idx[ r ][ c ]
|             }
|         }
|     }
| }
{:.syntax }


### Read loop restoration syntax ### {#read_loop_restoration_syntax}

| --------------------------------------------------------- | ---------------- |
| read_lr( r, c, bSize ) {                                  | **Type**
|     if ( allow_intrabc ) {
|         return
|     }
|     w = Num_4x4_Blocks_Wide[ bSize ]
|     h = Num_4x4_Blocks_High[ bSize ]
|     for ( plane = 0; plane < NumPlanes; plane++ ) {
|         if ( FrameRestorationType[ plane ] != RESTORE_NONE ) {
|             subX = (plane == 0) ? 0 : subsampling_x
|             subY = (plane == 0) ? 0 : subsampling_y
|             unitSize = LoopRestorationSize[ plane ]
|             unitRows = count_units_in_frame( unitSize, Round2( FrameHeight, subY) )
|             unitCols = count_units_in_frame( unitSize, Round2( UpscaledWidth, subX) )
|             unitRowStart = ( r * ( MI_SIZE \>\> subY) +
|                                       unitSize - 1 ) / unitSize
|             unitRowEnd = Min( unitRows, ( (r + h) * ( MI_SIZE \>\> subY) +
|                                       unitSize - 1 ) / unitSize)
|             if ( use_superres ) {
|                 numerator = (MI_SIZE \>\> subX) * SuperresDenom
|                 denominator = unitSize * SUPERRES_NUM
|             } else {
|                 numerator = MI_SIZE \>\> subX
|                 denominator = unitSize
|             }
|             unitColStart = ( c * numerator + denominator - 1 ) / denominator
|             unitColEnd = Min( unitCols, ( (c + w) * numerator +
|                               denominator - 1 ) / denominator)
|             for ( unitRow = unitRowStart; unitRow < unitRowEnd; unitRow++ ) {
|                 for ( unitCol = unitColStart; unitCol < unitColEnd; unitCol++ ) {
|                     read_lr_unit(plane, unitRow, unitCol)
|                 }
|             }
|         }
|     }
| }
{:.syntax }

where count_units_in_frame is a function specified as:

~~~~~ c
count_units_in_frame(unitSize, frameSize) {
    return Max((frameSize + (unitSize >> 1)) / unitSize, 1)
}
~~~~~


### Read loop restoration unit syntax ### {#read_loop_restoration_unit_syntax}

| --------------------------------------------------------- | ---------------- |
| read_lr_unit(plane, unitRow, unitCol) {                 | **Type**
|     if ( FrameRestorationType[ plane ] == RESTORE_WIENER ) {
|         @@use_wiener                                      | S()
|         restoration_type = use_wiener ? RESTORE_WIENER : RESTORE_NONE
|     } else if ( FrameRestorationType[ plane ] == RESTORE_SGRPROJ ) {
|         @@use_sgrproj                                     | S()
|         restoration_type = use_sgrproj ? RESTORE_SGRPROJ : RESTORE_NONE
|     } else {
|         @@restoration_type                                | S()
|     }
|     LrType[ plane ][ unitRow ][ unitCol ] = restoration_type
|     if ( restoration_type == RESTORE_WIENER ) {
|         for ( pass = 0; pass < 2; pass++ ) {
|             if ( plane ) {
|                 firstCoeff = 1
|                 LrWiener[ plane ]
|                         [ unitRow ][ unitCol ][ pass ][0] = 0
|             } else {
|                 firstCoeff = 0
|             }
|             for ( j = firstCoeff; j < 3; j++ ) {
|                 min = Wiener_Taps_Min[ j ]
|                 max = Wiener_Taps_Max[ j ]
|                 k = Wiener_Taps_K[ j ]
|                 v = decode_signed_subexp_with_ref_bool(
|                         min, max + 1, k, RefLrWiener[ plane ][ pass ][ j ] )
|                 LrWiener[ plane ]
|                         [ unitRow ][ unitCol ][ pass ][ j ] = v
|                 RefLrWiener[ plane ][ pass ][ j ] = v
|             }
|         }
|     } else if ( restoration_type == RESTORE_SGRPROJ ) {
|         @@lr_sgr_set                                      | L(SGRPROJ_PARAMS_BITS)
|         LrSgrSet[ plane ][ unitRow ][ unitCol ] = lr_sgr_set
|         for ( i = 0; i < 2; i++ ) {
|             radius = Sgr_Params[ lr_sgr_set ][ i * 2 ]
|             min = Sgrproj_Xqd_Min[i]
|             max = Sgrproj_Xqd_Max[i]
|             if ( radius ) {
|               v = decode_signed_subexp_with_ref_bool(
|                      min, max + 1, SGRPROJ_PRJ_SUBEXP_K,
|                      RefSgrXqd[ plane ][ i ])
|             } else {
|               v = 0
|               if ( i == 1 ) {
|                 v = Clip3( min, max, (1 \<\< SGRPROJ_PRJ_BITS) -
|                            RefSgrXqd[ plane ][ 0 ] )
|               }
|             }
|             LrSgrXqd[ plane ][ unitRow ][ unitCol ][ i ] = v
|             RefSgrXqd[ plane ][ i ] = v
|         }
|     }
| }
{:.syntax }

where Wiener_Taps_Min, Wiener_Taps_Max, ,Wiener_Taps_K, Sgrproj_Xqd_Min, and
Sgrproj_Xqd_Max are constant lookup tables:

~~~~~ c
Wiener_Taps_Min[3] = { -5, -23, -17 }
Wiener_Taps_Max[3] = { 10,   8,  46 }
Wiener_Taps_K[3] = { 1, 2, 3 }

Sgrproj_Xqd_Min[2] = { -96, -32 }
Sgrproj_Xqd_Max[2] = {  31,  95 }
~~~~~

Sgr_Params is a constant lookup table defined in [section 7.17.3][] and
decode_signed_subexp_with_ref_bool is a function specified as follows:

| --------------------------------------------------------- | ---------------- |
| decode_signed_subexp_with_ref_bool( low, high, k, r ) {   | **Type**
|     x = decode_unsigned_subexp_with_ref_bool(high - low, k, r - low)
|     return x + low
| }
|
| decode_unsigned_subexp_with_ref_bool( mx, k, r ) {
|     v = decode_subexp_bool( mx, k )
|     if ( (r \<\< 1) <\= mx ) {
|         return inverse_recenter(r, v)
|     } else {
|         return mx - 1 - inverse_recenter(mx - 1 - r, v)
|     }
| }
|
| decode_subexp_bool( numSyms, k ) {
|     i = 0
|     mk = 0
|     while ( 1 ) {
|         b2 = i ? k + i - 1 : k
|         a = 1 \<\< b2
|         if ( numSyms <\= mk + 3 * a ) {
|             @@subexp_unif_bools                           | NS(numSyms - mk)
|             return subexp_unif_bools + mk
|         } else {
|             @@subexp_more_bools                           | L(1)
|             if ( subexp_more_bools ) {
|                i++
|                mk += a
|             } else {
|                @@subexp_bools                             | L(b2)
|                return subexp_bools + mk
|             }
|         }
|     }
| }
{:.syntax }

**Note:** The decode_signed_subexp_with_ref_bool function is the same as the
decode_signed_subexp_with_ref function except that the bits used to represent
the symbol are arithmetic coded instead of being read directly from the
bitstream.
{:.alert .alert-info }

## Tile list OBU syntax ## {#tile_list_obu_syntax}

### General tile list OBU syntax ### {#general_tile_list_obu_syntax}

| --------------------------------------------------------- | ---------------- |
| tile_list_obu( ) {                                        | **Type**
|     @@output_frame_width_in_tiles_minus_1                 | f(8)
|     @@output_frame_height_in_tiles_minus_1                | f(8)
|     @@tile_count_minus_1                                  | f(16)
|     for ( tile = 0; tile <= tile_count_minus_1; tile++ )
|         tile_list_entry( )
| }
{:.syntax }

### Tile list entry syntax ### {#tile_list_entry_syntax}

| --------------------------------------------------------- | ---------------- |
| tile_list_entry( ) {                                      | **Type**
|     @@anchor_frame_idx                                    | f(8)
|     @@anchor_tile_row                                     | f(8)
|     @@anchor_tile_col                                     | f(8)
|     @@tile_data_size_minus_1                              | f(16)
|     N = 8 * (tile_data_size_minus_1 + 1)
|     @@coded_tile_data                                     | f(N)
| }
{:.syntax }

# Syntax structures semantics # {#syntax_structures_semantics}

## General ## {#general}

This section specifies the meaning of the syntax elements read in the syntax
structures.

Important variables and function calls are also described.

## OBU semantics ## {#obu_semantics}

### General OBU semantics ### {#general_obu_semantics}

An ordered series of OBUs is presented to the decoding process. Each OBU is
given to the decoding process as a string of bytes along with a variable sz that
identifies the total number of bytes in the OBU.

If the syntax element obu_has_size_field (in the OBU header) is equal to 1,
then the variable sz will be unused and does not have to be provided.

**obu_size** contains the size in bytes of the OBU not including the bytes within obu_header or the obu_size syntax element.

Methods of framing the OBUs (i.e. of identifying the series of OBUs and their size
and payload data) in a delivery or container format may be established in a manner
outside the scope of this Specification. One simple method is described in Annex
B.

OBU data starts on the first (most significant) bit and ends on the last bit of the given bytes. The
payload of an OBU lies between the first bit of the given bytes and the last bit
before the first trailing bit. Trailing bits are always present, unless the OBU
consists of only the header. Trailing bits achieve byte alignment when the payload
of an OBU is not byte aligned. The trailing bits may also used for additional byte
padding, and if used are taken into account in the sz value. In all cases, the pattern
used for the trailing bits guarantees that all OBUs (except header-only OBUs) end
with the same pattern: one bit set to one, optionally followed by zeros.

**Note:** As a validity check for malformed encoded data and for operation in
environments in which losses and errors can occur, decoders may detect an error
if the end of the parsed data is not directly followed by the correct trailing bits
pattern or if the parsing of the OBU header and payload leads to the consumption
of bits within the trailing bits (except for tile group data which is allowed to read
a small distance into the trailing bits as described in [section 8.2.4][]).
{:.alert .alert-info }

**drop_obu( )** is a function call that indicates when the decoding process should
ignore an OBU because it is not contained in the selected operating point.
When an OBU is not in the selected operating point
the contents have no effect on the decoding process.

When this function is called, the bitstream position indicator should be
advanced by obu_size * 8 bits.

### OBU header semantics ### {#obu_header_semantics}

OBUs are structured with a header and a payload.
The header identifies the type of the payload using the obu_type header parameter.

**obu_forbidden_bit** must be set to 0.

**Note:** This ensures that MPEG2 transport is
possible by preventing emulation of MPEG2 transport stream ids.
{:.alert .alert-info }

**obu_type** specifies the type of data structure contained in the OBU payload:

| obu_type | Name of obu_type       | Layer-specific
| -------- | ----------------       | ------------
| 0        | Reserved               | -
| 1        | OBU_SEQUENCE_HEADER.   | N
| 2        | OBU_TEMPORAL_DELIMITER | N
| 3        | OBU_FRAME_HEADER       | Y
| 4        | OBU_TILE_GROUP         | Y
| 5        | OBU_METADATA           | See Table in Section 6.7.1
| 6        | OBU_FRAME              | Y
| 7        | OBU_REDUNDANT_FRAME_HEADER | Y
| 8        | OBU_TILE_LIST          | N
| 9-14     | Reserved               | -
| 15       | OBU_PADDING            | Either
{:.table .table-sm .table-bordered }

Reserved units are for future use and shall be ignored by AV1 decoder.

The column “Layer-specific” indicates if the corresponding OBU type is considered to be associated with
a specific layer  ("Y"), or not ("N"). OBUs that are not layer-specific must have the obu_extension_flag set to 0. 

Metadata OBU types may or may not be layer-specific, depending on the metadata type. The table in Section 6.7.1 specifies which types of metadata OBUs are layer-specific and which are not.

Padding OBUs may or may not be layer-specific. If the obu_extension_flag is set to 1 they are layer-specific, whereas when the obu_extension_flag is set to 0 they are not.   

**obu_extension_flag** indicates if the optional obu_extension_header is present.

**obu_has_size_field** equal to 1 indicates that the obu_size syntax element
will be present.  obu_has_size_field equal to 0 indicates that the obu_size
syntax element will not be present.

**obu_reserved_1bit** must be set to 0. The value is ignored by a decoder.

### OBU extension header semantics ### {#obu_extension_header_semantics}

**temporal_id** specifies the temporal level of the data contained in the OBU.
In layer-specific OBUs, when temporal_id is not present it is inferred to be equal to 0.

**spatial_id** specifies the spatial level of the data contained in the OBU.
In layer-specific OBUs, when spatial_id is not present it is inferred to be equal to 0.

**Note:** The term "spatial" refers to the fact that
the enhancement here occurs in the spatial dimension: either as an increase in spatial resolution, or an
increase in spatial fidelity (increased SNR).
{:.alert .alert-info }

Tile group OBU data associated with spatial_id and temporal_id equal to 0 are referred to as the
base layer, whereas tile group OBU data that are associated with spatial_id greater than 0 or
temporal_id greater than 0 are referred to as enhancement layer(s).

Coded video data of a temporal level with temporal_id T and spatial level with spatial_id S
are only allowed to reference previously coded video data of temporal_id T' and spatial_id S',
where T' <= T and S' <= S.

**extension_header_reserved_3bits** must be set to 0. The value is ignored by a decoder.

### Trailing bits semantics ### {#trailing_bits_semantics}

**Note:** Tile group OBUs, tile List OBUs, and frame OBUs do end with trailing bits,
but for these cases, the trailing bits are consumed by the exit_symbol process.
{:.alert .alert-info }

**trailing_one_bit** shall be equal to 1.

When the syntax element trailing_one_bit is read, it is a requirement that nbBits is greater than zero.

**trailing_zero_bit** shall be equal to 0 and is inserted into the bitstream to align
the bit position to a multiple of 8 bits and add optional zero padding bytes to the OBU.

### Byte alignment semantics ### {#byte_alignment_semantics}

**zero_bit** shall be equal to 0 and is inserted into the bitstream to align
the bit position to a multiple of 8 bits.

## Reserved OBU semantics ## {#reserved_obu_semantics}

The reserved OBU allows the extension of this specification with additional OBU
types in a way that allows older decoders to ignore them.

## Sequence header OBU semantics ## {#sequence_header_obu_semantics}

### General sequence header OBU semantics ### {#general_sequence_header_obu_semantics}

**seq_profile** specifies the features that can be used in the coded video sequence.

| seq_profile | Bit depth | Monochrome support      | Chroma subsampling
| ----------- | --------- | ----------------------- | ------------------
| 0           | 8 or 10   | Yes                     | YUV 4:2:0
| 1           | 8 or 10   | No                      | YUV 4:4:4
| 2           | 8 or 10   | Yes                     | YUV 4:2:2
| 2           | 12        | Yes                     | YUV 4:2:0, YUV 4:2:2, YUV 4:4:4
{:.table .table-sm .table-bordered }

It is a requirement of bitstream conformance that seq_profile is not greater than 2 (values 3 to 7 are reserved).

Monochrome can only be signaled when seq_profile is equal to 0 or 2.

AV1 profiles are defined in Annex A.

**still_picture** equal to 1 specifies that the coded video sequence contains only one coded frame.
still_picture equal to 0 specifies that the coded video sequence contains one or more coded frames.

**reduced_still_picture_header** specifies that the syntax elements not needed by a still picture are omitted.

If reduced_still_picture_header is equal to 1, it is a requirement of bitstream conformance that still_picture is equal to 1.

**Note:** It is allowed to have still_picture equal to 1 and reduced_still_picture_header equal to 0.
This allows a video frame to be converted to a still picture by changing a single bit.
{:.alert .alert-info }

**timing_info_present_flag** specifies whether timing info is present in the coded video sequence.

**decoder_model_info_present_flag** specifies whether decoder model information is present in the coded video sequence.

**initial_display_delay_present_flag** specifies whether initial display delay information is present in the coded video sequence.

**operating_points_cnt_minus_1** indicates the number of operating points minus 1 present in the coded video sequence.

An operating point specifies which spatial and temporal layers should be decoded.

**operating_point_idc[ i ]** contains a bitmask that indicates which spatial and temporal layers should be decoded for operating point i.
Bit k is equal to 1 if temporal layer k should be decoded (for k between 0 and 7).
Bit j+8 is equal to 1 if spatial layer j should be decoded (for j between 0 and 3).

However, if operating_point_idc[ i ] is equal to 0 then the coded video sequence
has no scalability information in OBU extension headers and the operating
point applies to the entire coded video sequence.  This means that all OBUs must be decoded.

It is a requirement of bitstream conformance that operating_point_idc[ i ] is not equal to operating_point_idc[ j ] for j = 0..(i - 1).

**Note:** This constraint means it is not allowed for two operating points to have the same value of operating_point_idc.
{:.alert .alert-info }

If operating_point_idc[ op ] is not equal to 0 for any value of op from 0 to operating_points_cnt_minus_1, it is a requirement of bitstream conformance that obu_extension_flag is equal to 1 for all layer-specific OBUs in the coded video sequence.

**seq_level_idx[ i ]** specifies the level that the coded video sequence conforms to when operating point i is selected.

**Note:** Encoders should select the lowest level that is satisfied by the operating point
to maximize the number of decoders that can decode the stream, but this is not a requirement of bitstream conformance.
{:.alert .alert-info }

**seq_tier[ i ]** specifies the tier that the coded video sequence conforms to when operating point i is selected.

**decoder_model_present_for_this_op[ i ]** equal to one indicates that there is a decoder model
associated with operating point i.
decoder_model_present_for_this_op[ i ] equal to zero indicates that there is not a decoder model
associated with operating point i.

**initial_display_delay_present_for_this_op[ i ]** equal to 1 indicates that initial_display_delay_minus_1 is
specified for operating point i.
initial_display_delay_present_for_this_op[ i ] equal to 0 indicates that initial_display_delay_minus_1
is not specified for operating point i.

**initial_display_delay_minus_1[ i ]** plus 1 specifies, for operating point i, the number of
decoded frames that should be present in the buffer pool before the first presentable frame is displayed.
This will ensure that all presentable frames in the sequence can be decoded at or before the time
that they are scheduled for display.
If not signaled then initial_display_delay_minus_1[ i ] = BUFFER_POOL_MAX_SIZE - 1.

**choose_operating_point( )** is a function call that indicates that the operating point should be selected.

The implementation of this function depends on the
capabilities of the chosen implementation.
The order of operating points indicates the preferred order for producing an output: a decoder should
select the earliest operating point in the list that meets its decoding capabilities as expressed by the level
associated with each operating point.

A decoder must return a value from choose_operating_point between 0 and operating_points_cnt_minus_1, or abandon the decoding process
if no level within the decoder's capabilities can be found.

**Note:** To help with conformance testing, decoders may allow the operating point to be explicitly signaled by external means.
{:.alert .alert-info }

**Note:** A decoder may need to change the operating point selection when a new coded video sequence begins.
{:.alert .alert-info }

**OperatingPointIdc** specifies the value of operating_point_idc for the selected operating point.

It is a requirement of bitstream conformance that if OperatingPointIdc is equal to 0, then
obu_extension_flag is equal to 0 for all OBUs that follow this sequence header until the next sequence header.

**frame_width_bits_minus_1** specifies the number of bits minus 1 used for transmitting the frame width syntax elements.

**frame_height_bits_minus_1** specifies the number of bits minus 1 used for transmitting the frame height syntax elements.

**max_frame_width_minus_1** specifies the maximum frame width minus 1 for the frames represented by this sequence header.

**max_frame_height_minus_1** specifies the maximum frame height minus 1 for the frames represented by this sequence header.

**frame_id_numbers_present_flag** specifies whether frame id numbers are present in the coded video sequence.

**Note:** The frame id numbers (represented in display_frame_id, current_frame_id, and RefFrameId[ i ]) are not needed by the decoding process,
but allow decoders to spot when frames have been missed and take an appropriate action.
{:.alert .alert-info }

**additional_frame_id_length_minus_1** is used to calculate the number of bits used to encode the display_frame_id or current_frame_id syntax element.

**delta_frame_id_length_minus_2** specifies the number of bits minus 2 used to encode delta_frame_id_minus_1 syntax elements.

**use_128x128_superblock**, when equal to 1, indicates that superblocks contain
128x128 luma samples. When equal to 0, it indicates that superblocks contain 64x64
luma samples. (The number of contained chroma samples depends on subsampling_x and subsampling_y.)

**enable_filter_intra** equal to 1 specifies that the use_filter_intra syntax element
may be present.
enable_filter_intra equal to 0 specifies that the use_filter_intra syntax element
will not be present.

**enable_intra_edge_filter** specifies whether the intra edge filtering process
should be enabled.

**enable_interintra_compound** equal to 1 specifies that the mode info for inter
blocks may contain the syntax element interintra. enable_interintra_compound
equal to 0 specifies that the syntax element interintra will not be present.

**enable_masked_compound** equal to 1 specifies that the mode info for inter
blocks may contain the syntax element compound_type. enable_masked_compound equal
to 0 specifies that the syntax element compound_type will not be present.

**enable_warped_motion** equal to 1 indicates that the allow_warped_motion
syntax element may be present.
enable_warped_motion equal to 0 indicates that the allow_warped_motion
syntax element will not be present.

**enable_order_hint** equal to 1 indicates that tools based on the values of
order hints may be used. enable_order_hint equal to 0 indicates that
tools based on order hints are disabled.

**enable_dual_filter** equal to 1 indicates that the inter prediction filter
type may be specified independently in the horizontal and vertical directions.
If the flag is equal to 0, only one filter type may be specified, which is
then used in both directions.

**enable_jnt_comp** equal to 1 indicates that the distance weights process
may be used for inter prediction.

**enable_ref_frame_mvs** equal to 1 indicates that the use_ref_frame_mvs
syntax element may be present.
enable_ref_frame_mvs equal to 0 indicates that the use_ref_frame_mvs
syntax element will not be present.

**seq_choose_screen_content_tools** equal to 0 indicates that the seq_force_screen_content_tools syntax element
will be present.  seq_choose_screen_content_tools equal to 1 indicates that seq_force_screen_content_tools
should be set equal to SELECT_SCREEN_CONTENT_TOOLS.

**seq_force_screen_content_tools** equal to SELECT_SCREEN_CONTENT_TOOLS indicates that the allow_screen_content_tools
syntax element will be present in the frame header.  Otherwise,
seq_force_screen_content_tools contains the value for allow_screen_content_tools.

**seq_choose_integer_mv** equal to 0 indicates that the seq_force_integer_mv syntax element
will be present.  seq_choose_integer_mv equal to 1 indicates that seq_force_integer_mv should be set
equal to SELECT_INTEGER_MV.

**seq_force_integer_mv** equal to SELECT_INTEGER_MV indicates that the force_integer_mv syntax element
will be present in the frame header (providing allow_screen_content_tools is equal to 1).  Otherwise, seq_force_integer_mv
contains the value for force_integer_mv.

**order_hint_bits_minus_1** is used to compute OrderHintBits.

**OrderHintBits** specifies the number of bits used for the order_hint syntax element.

**enable_superres** equal to 1 specifies that the use_superres syntax element will be present in the uncompressed header.
enable_superres equal to 0 specifies that the use_superres syntax element will not be present
(instead use_superres will be set to 0 in the uncompressed header without being read).

**Note:** It is allowed to set enable_superres equal to 1 even when use_superres is not
equal to 1 for any frame in the coded video sequence.
{:.alert .alert-info }

**enable_cdef** equal to 1 specifies that cdef filtering may be enabled.
enable_cdef equal to 0 specifies that cdef filtering is disabled.

**Note:** It is allowed to set enable_cdef equal to 1 even when cdef filtering is not
used on any frame in the coded video sequence.
{:.alert .alert-info }

**enable_restoration** equal to 1 specifies that loop restoration filtering may be enabled.
enable_restoration equal to 0 specifies that loop restoration filtering is disabled.

**Note:** It is allowed to set enable_restoration equal to 1 even when loop restoration is not
used on any frame in the coded video sequence.
{:.alert .alert-info }

**film_grain_params_present** specifies whether film grain parameters are present in the coded video sequence.

### Color config semantics ### {#color_config_semantics}

**high_bitdepth** and **twelve_bit** are syntax elements which, together with seq_profile,
determine the bit depth.

**mono_chrome** equal to 1 indicates that the video does not contain U and V color planes.
mono_chrome equal to 0 indicates that the video contains Y, U, and V color planes.

**color_description_present_flag** equal to 1 specifies that color_primaries,
transfer_characteristics, and matrix_coefficients are present.
color_description_present_flag
equal to 0 specifies that color_primaries, transfer_characteristics and matrix_coefficients are
not present.

**color_primaries** is an integer that is defined by the "Color primaries" section of
ISO/IEC 23091-4/ITU-T H.273.

| color_primaries | Name of color primaries | Description
|:-----------:|:-------------------:| -----------
| 1           | CP_BT_709           | BT.709
| 2           | CP_UNSPECIFIED      | Unspecified
| 4           | CP_BT_470_M         | BT.470 System M (historical)
| 5           | CP_BT_470_B_G       | BT.470 System B, G (historical)
| 6           | CP_BT_601           | BT.601
| 7           | CP_SMPTE_240        | SMPTE 240
| 8           | CP_GENERIC_FILM     | Generic film (color filters using illuminant C)
| 9           | CP_BT_2020          | BT.2020, BT.2100
| 10          | CP_XYZ              | SMPTE 428 (CIE 1921 XYZ)
| 11          | CP_SMPTE_431        | SMPTE RP 431-2
| 12          | CP_SMPTE_432        | SMPTE EG 432-1
| 22          | CP_EBU_3213         | EBU Tech. 3213-E
{:.table .table-sm .table-bordered }

**transfer_characteristics** is an integer that is defined by the "Transfer characteristics"
section of ISO/IEC 23091-4/ITU-T H.273.

| transfer_characteristics | Name of transfer characteristics | Description
|:-----------:|:-------------------:| -----------
| 0           | TC_RESERVED_0   | For future use
| 1           | TC_BT_709       | BT.709
| 2           | TC_UNSPECIFIED  | Unspecified
| 3           | TC_RESERVED_3   | For future use
| 4           | TC_BT_470_M     | BT.470 System M (historical)
| 5           | TC_BT_470_B_G   | BT.470 System B, G (historical)
| 6           | TC_BT_601       | BT.601
| 7           | TC_SMPTE_240    | SMPTE 240 M
| 8           | TC_LINEAR       | Linear
| 9           | TC_LOG_100      | Logarithmic (100 : 1 range)
| 10          | TC_LOG_100_SQRT10  | Logarithmic (100 * Sqrt(10) : 1 range)
| 11          | TC_IEC_61966   | IEC 61966-2-4
| 12          | TC_BT_1361     | BT.1361
| 13          | TC_SRGB        | sRGB or sYCC
| 14          | TC_BT_2020_10_BIT  | BT.2020 10-bit systems
| 15          | TC_BT_2020_12_BIT  | BT.2020 12-bit systems
| 16          | TC_SMPTE_2084      | SMPTE ST 2084, ITU BT.2100 PQ
| 17          | TC_SMPTE_428       | SMPTE ST 428
| 18          | TC_HLG             | BT.2100 HLG, ARIB STD-B67
{:.table .table-sm .table-bordered }

**matrix_coefficients** is an integer that is defined by the "Matrix coefficients" section of
ISO/IEC 23091-4/ITU-T H.273.

| matrix_coefficients | Name of matrix coefficients | Description
|:-----------:|:-------------------:| -----------
| 0           | MC_IDENTITY      |  Identity matrix
| 1           | MC_BT_709        |  BT.709
| 2           | MC_UNSPECIFIED   |  Unspecified
| 3           | MC_RESERVED_3    |  For future use
| 4           | MC_FCC           |  US FCC 73.628
| 5           | MC_BT_470_B_G    |  BT.470 System B, G (historical)
| 6           | MC_BT_601        |  BT.601
| 7           | MC_SMPTE_240     |  SMPTE 240 M
| 8           | MC_SMPTE_YCGCO   |  YCgCo
| 9           | MC_BT_2020_NCL   |  BT.2020 non-constant luminance, BT.2100 YCbCr
| 10          | MC_BT_2020_CL    |  BT.2020 constant luminance
| 11          | MC_SMPTE_2085    |  SMPTE ST 2085 YDzDx
| 12          | MC_CHROMAT_NCL   |  Chromaticity-derived non-constant luminance
| 13          | MC_CHROMAT_CL    |  Chromaticity-derived constant luminance
| 14          | MC_ICTCP         |  BT.2100 ICtCp
{:.table .table-sm .table-bordered }

**color_range** is a binary value that is associated with the VideoFullRangeFlag variable specified in ISO/IEC 23091-4/ITU-T H.273.
color range equal to 0 shall be referred to as the studio swing representation and
color range equal to 1 shall be referred to as the full swing representation for all intents relating to this specification.


**Note:** Note that this specification does not enforce the range
when signaled as Studio swing. Therefore the application
should perform additional clamping and color conversion operations according to
the specified range.
{:.alert .alert-info }

**subsampling_x**, **subsampling_y** specify the chroma subsampling format:


| subsampling_x | subsampling_y | mono_chrome | Description
| ------------- | ------------- | ----------- | -----------
| 0             | 0             | 0           | YUV 4:4:4
| 1             | 0             | 0           | YUV 4:2:2
| 1             | 1             | 0           | YUV 4:2:0
| 1             | 1             | 1           | Monochrome 4:0:0
{:.table .table-sm .table-bordered }

If matrix_coefficients is equal to MC_IDENTITY, it is a requirement of bitstream conformance
that subsampling_x is equal to 0 and subsampling_y is equal to 0.


**chroma_sample_position** specifies the sample position for subsampled streams:

| chroma_sample_position | Name of chroma sample position| Description
|:----------------------:|:------------------------------: -----------
| 0                      | CSP_UNKNOWN                   | Unknown (in this case the source video transfer function must be signaled outside the AV1 bitstream)
| 1                      | CSP_VERTICAL                  | Horizontally co-located with (0, 0) luma sample, vertical position in the middle between two luma samples
| 2                      | CSP_COLOCATED                 | co-located with (0, 0) luma sample
| 3                      | CSP_RESERVED                  |
{:.table .table-sm .table-bordered }

**separate_uv_delta_q** equal to 1 indicates that the U and V planes may have separate delta quantizer values.
separate_uv_delta_q equal to 0 indicates that the U and V planes will share the same delta quantizer value.

### Timing info semantics ### {#timing_info_semantics}

**num_units_in_display_tick** is the number of time units of a clock operating at the frequency
time_scale Hz that corresponds to one increment of a clock tick counter.
A display clock tick, in seconds, is equal to num_units_in_display_tick divided by time_scale:

~~~~~ c
DispCT = num_units_in_display_tick ÷ time_scale
~~~~~

**Note:** The ÷ operator represents standard mathematical division (in contrast to the / operator which represents integer division).
{:.alert .alert-info }

It is a requirement of bitstream conformance that num_units_in_display_tick is greater than 0.

**time_scale** is the number of time units that pass in one second.

It is a requirement of bitstream conformance that time_scale is greater than 0.

**equal_picture_interval** equal to 1 indicates that pictures should be displayed according
to their output order with the number of ticks between two consecutive pictures (without
dropping frames) specified by num_ticks_per_picture_minus_1 + 1.
equal_picture_interval equal to 0 indicates that the interval between two consecutive
pictures is not specified.

**num_ticks_per_picture_minus_1** plus 1 specifies the number of clock ticks
corresponding to output time between two consecutive pictures in the output order.

It is a requirement of bitstream conformance that the
value of num_ticks_per_picture_minus_1 shall be in the range of 0 to (1 \<\< 32) − 2, inclusive.

**Note:** The frame rate, when specified explicitly, applies to the top temporal layer of the
bitstream. If bitstream is expected to be manipulated, e.g. by intermediate network
elements, then the resulting frame rate may not match the specified one. In this case, an
encoder is advised to use explicit time codes or some mechanisms that convey picture
timing information outside the bitstream.
{:.alert .alert-info }

### Decoder model info semantics ### {#decoder_model_info_semantics}

**buffer_delay_length_minus_1** plus 1 specifies the length of the
decoder_buffer_delay and the encoder_buffer_delay syntax elements, in bits.

**num_units_in_decoding_tick** is the number of time units of a decoding clock operating
at the frequency time_scale Hz that corresponds to one increment of a clock tick counter:

~~~~~ c
DecCT = num_units_in_decoding_tick ÷ time_scale
~~~~~

**Note:** The ÷ operator represents standard mathematical division (in contrast to the / operator which represents integer division).
{:.alert .alert-info }

num_units_in_decoding_tick shall be greater than 0.
DecCT represents the expected time to decode a single frame or a common divisor of the expected times
to decode frames of different sizes and dimensions present in the coded video sequence.

**buffer_removal_time_length_minus_1** plus 1 specifies the length of the buffer_removal_time syntax element, in bits.

**frame_presentation_time_length_minus_1** plus 1 specifies the length of the frame_presentation_time syntax element, in bits.

### Operating parameters info semantics ### {#operating_parameters_info_semantics}

**decoder_buffer_delay[ op ]** specifies the time interval between the arrival of the first bit
in the smoothing buffer and the subsequent removal of the data that belongs to the
first coded frame for operating point op, measured in units of 1/90000 seconds.
The length of decoder_buffer_delay is specified by buffer_delay_length_minus_1 + 1, in bits.

**encoder_buffer_delay[ op ]** specifies, in combination with decoder_buffer_delay[ op ] syntax element,
the first bit arrival time of frames to be decoded to the smoothing buffer.
encoder_buffer_delay is measured in units of 1/90000 seconds.

For a video sequence that includes one or more random access points the sum of decoder_buffer_delay
and encoder_buffer_delay shall be kept constant.

**low_delay_mode_flag[ op ]** equal to 1 indicates that the smoothing buffer operates in low-delay mode for operating point op.
In low-delay mode late decode times and buffer underflow are both permitted.
low_delay_mode_flag[ op ] equal to 0 indicates that the smoothing buffer operates in strict mode,
where buffer underflow is not allowed.

## Temporal delimiter OBU semantics ## {#temporal_delimiter_obu_semantics}

**SeenFrameHeader** is a variable used to mark whether the frame header for the current frame has been received.
It is initialized to zero.

## Padding OBU semantics ## {#padding_obu_semantics}

Multiple padding units can be present, each padding with an arbitrary number of bytes.

**obu_padding_byte** is a padding byte.  Padding bytes may have arbitrary values and have no effect on the decoding process.

## Metadata OBU semantics ## {#metadata_obu_semantics}

### General metadata OBU semantics ### {#general_metadata_obu_semantics}

Metadata OBUs may or may not have an OBU extension header. If there is no extension header, the metadata OBU’s layer scope is all operating points in the coded video sequence, starting from the point the metadata OBU appears in the bitstream. If there is an extension header, the metadata OBU’s layer scope is for the specific layer identified in the OBU extension header, starting from the point it appears in the bitstream.  Specific metadata OBU types may have additional constraints on the presence and use of the OBU extension header. The metadata_type table below indicates which metadata OBU types are layer-specific and thus include an OBU extension header.

**metadata_type** indicates the type of metadata:

| metadata_type  | Name of metadata_type       | Layer-specific
| -------------- | --------------------------- | --------------
| 0              | Reserved for AOM use        | -
| 1              | METADATA_TYPE_HDR_CLL       | N
| 2              | METADATA_TYPE_HDR_MDCV      | N
| 3              | METADATA_TYPE_SCALABILITY   | N
| 4              | METADATA_TYPE_ITUT_T35      | payload-specific
| 5              | METADATA_TYPE_TIMECODE      | N
| 6-31           | Unregistered user private   | -
| 32 and greater | Reserved for AOM use        | -
{:.table .table-sm .table-bordered }

The semantics of the column “Layer-specific” and its values are defined in Section 6.2.2. 

### Metadata ITUT T35 semantics ### {#metadata_itut_t35_semantics}

**itu_t_t35_country_code** shall be a byte having a value specified as a country code by Annex A
of Recommendation ITU-T T.35.

**itu_t_t35_country_code_extension_byte** shall be a byte having a value specified as a country
code by Annex B of Recommendation ITU-T T.35.

**itu_t_t35_payload_bytes** shall be bytes containing data registered as specified in
Recommendation ITU-T T.35.

The ITU-T T.35 terminal provider code and terminal provider oriented code shall be contained in
the first one or more bytes of the itu_t_t35_payload_bytes, in the format specified by the
Administration that issued the terminal provider code. Any remaining bytes in
itu_t_t35_payload_bytes data shall be data having syntax and semantics as specified by the
entity identified by the ITU-T T.35 country code and terminal provider code.

### Metadata high dynamic range content light level semantics ### {#metadata_high_dynamic_range_content_light_level_semantics}

**max_cll** specifies the maximum content light level as specified in CEA-861.3, Appendix A.

**max_fall** specifies the maximum frame-average light level as specified in CEA-861.3, Appendix A.

### Metadata high dynamic range mastering display color volume semantics ### {#metadata_high_dynamic_range_mastering_display_color_volume_semantics}

**primary_chromaticity_x[ i ]** specifies a 0.16 fixed-point X chromaticity coordinate as defined by CIE 1931, where i = 0,1,2 specifies Red, Green, Blue respectively.

**primary_chromaticity_y[ i ]** specifies a 0.16 fixed-point Y chromaticity coordinate as defined by CIE 1931, where i = 0,1,2 specifies Red, Green, Blue respectively.

**white_point_chromaticity_x** specifies a 0.16 fixed-point white X chromaticity coordinate as defined by CIE 1931.

**white_point_chromaticity_y** specifies a 0.16 fixed-point white Y chromaticity coordinate as defined by CIE 1931.

**luminance_max** is a 24.8 fixed-point maximum luminance, represented in candelas per square meter.

**luminance_min** is a 18.14 fixed-point minimum luminance, represented in candelas per square meter.

### Metadata scalability semantics ### {#metadata_scalability_semantics}

**Note:** The scalability metadata OBU is intended for use by intermediate processing entities that may
perform selective layer elimination.  Its presence allows these entities to know the structure of the
original coded video sequence without having to decode individual frames. If the received bitstream has been modified by an intermediate processing entity, then some of the layers and/or individual frames may be absent from the bitstream.
{:.alert .alert-info }

If scalability metadata is present it should be placed between the first sequence header and the first frame header of a coded video sequence. The information present in a scalability metadata OBU applies to the entire coded video sequence in which it is contained, and only that sequence. Redundant copies of a scalability metadata OBU may occur in any temporal unit of a coded video sequence.

**scalability_mode_idc** indicates the picture prediction structure of the coded video sequence.

| scalability_mode_idc | Name of scalability_mode_idc |
| -------------------- | ---------------------------- |
| 0                    | SCALABILITY_L1T2
| 1                    | SCALABILITY_L1T3
| 2                    | SCALABILITY_L2T1
| 3                    | SCALABILITY_L2T2
| 4                    | SCALABILITY_L2T3
| 5                    | SCALABILITY_S2T1
| 6                    | SCALABILITY_S2T2
| 7                    | SCALABILITY_S2T3
| 8                    | SCALABILITY_L2T1h
| 9                    | SCALABILITY_L2T2h
| 10                   | SCALABILITY_L2T3h
| 11                   | SCALABILITY_S2T1h
| 12                   | SCALABILITY_S2T2h
| 13                   | SCALABILITY_S2T3h
| 14                   | SCALABILITY_SS
| 15                   | SCALABILITY_L3T1
| 16                   | SCALABILITY_L3T2
| 17                   | SCALABILITY_L3T3
| 18                   | SCALABILITY_S3T1
| 19                   | SCALABILITY_S3T2
| 20                   | SCALABILITY_S3T3
| 21                   | SCALABILITY_L3T2_KEY
| 22                   | SCALABILITY_L3T3_KEY
| 23                   | SCALABILITY_L4T5_KEY
| 24                   | SCALABILITY_L4T7_KEY
| 25                   | SCALABILITY_L3T2_KEY_SHIFT
| 26                   | SCALABILITY_L3T3_KEY_SHIFT
| 27                   | SCALABILITY_L4T5_KEY_SHIFT
| 28                   | SCALABILITY_L4T7_KEY_SHIFT
| 29-255               | reserved
{:.table .table-sm .table-bordered }

The scalability metadata provides two mechanisms for describing the underlying picture prediction structure
of the bitstream:

  1. Selection among a set of preconfigured structures, or modes, covering a number of cases that have found wide use in applications.
  2. A facility for specifying picture prediction structures to accommodate a variety of special cases.

The preconfigured modes are described below.  The mechanism for describing alternative structures is
described in scalability_structure() below.

All predefined modes follow a dyadic, hierarchical picture prediction structure.  They support up to seven
temporal layers, in combinations with up to four spatial layers.  The second spatial layer may have
twice or one and a half times the resolution of the base layer in each dimension, depending on the mode.
There is also support for a spatial layer that uses no inter-layer prediction (i.e., the second spatial
layer does not use its corresponding base layer as a reference) and a spatial layer that uses inter-layer prediction only at key frames.
The following table lists the predefined scalability structures.

| Name of scalability_mode_idc | Spatial Layers | Resolution Ratio | Temporal Layers | Inter-layer dependency
| ---------------------------- | -------------- | ---------------- | --------------- | ----------------------
| SCALABILITY_L1T2             | 1              |                  | 2               |
| SCALABILITY_L1T3             | 1              |                  | 3               |
| SCALABILITY_L2T1             | 2              | 2:1              | 1               | Yes
| SCALABILITY_L2T2             | 2              | 2:1              | 2               | Yes
| SCALABILITY_L2T3             | 2              | 2:1              | 3               | Yes
| SCALABILITY_S2T1             | 2              | 2:1              | 1               | No
| SCALABILITY_S2T2             | 2              | 2:1              | 2               | No
| SCALABILITY_S2T3             | 2              | 2:1              | 3               | No
| SCALABILITY_L2T1h            | 2              | 1.5:1            | 1               | Yes
| SCALABILITY_L2T2h            | 2              | 1.5:1            | 2               | Yes
| SCALABILITY_L2T3h            | 2              | 1.5:1            | 3               | Yes
| SCALABILITY_S2T1h            | 2              | 1.5:1            | 1               | No
| SCALABILITY_S2T2h            | 2              | 1.5:1            | 2               | No
| SCALABILITY_S2T3h            | 2              | 1.5:1            | 3               | No
| SCALABILITY_L3T1             | 3              | 2:1              | 1               | Yes
| SCALABILITY_L3T2             | 3              | 2:1              | 2               | Yes
| SCALABILITY_L3T3             | 3              | 2:1              | 3               | Yes
| SCALABILITY_S3T1             | 3              | 2:1              | 1               | No
| SCALABILITY_S3T2             | 3              | 2:1              | 2               | No
| SCALABILITY_S3T3             | 3              | 2:1              | 3               | No
| SCALABILITY_L3T2_KEY         | 3              | 2:1              | 2               | Yes
| SCALABILITY_L3T3_KEY         | 3              | 2:1              | 3               | Yes
| SCALABILITY_L4T5_KEY         | 4              | 2:1              | 5               | Yes
| SCALABILITY_L4T7_KEY         | 4              | 2:1              | 7               | Yes
| SCALABILITY_L3T2_KEY_SHIFT   | 3              | 2:1              | 2               | Yes
| SCALABILITY_L3T3_KEY_SHIFT   | 3              | 2:1              | 3               | Yes
| SCALABILITY_L4T5_KEY_SHIFT   | 4              | 2:1              | 5               | Yes
| SCALABILITY_L4T7_KEY_SHIFT   | 4              | 2:1              | 7               | Yes
{:.table .table-sm .table-bordered }

The following figures show the picture prediction structures for certain modes:

<figure class="figure center-block">
  <img alt="" src="assets/images/scalability_L1T2.png" class="figure-img img-fluid">
  <figcaption class="figure-caption">L1T2</figcaption>
</figure>

<figure class="figure center-block">
  <img alt="" src="assets/images/scalability_L1T3.png" class="figure-img img-fluid">
  <figcaption class="figure-caption">L1T3</figcaption>
</figure>

<figure class="figure center-block">
  <img alt="" src="assets/images/scalability_L2T1.png" class="figure-img img-fluid">
  <figcaption class="figure-caption">L2T1</figcaption>
</figure>

<figure class="figure center-block">
  <img alt="" src="assets/images/scalability_L2T2.png" class="figure-img img-fluid">
  <figcaption class="figure-caption">L2T2</figcaption>
</figure>

<figure class="figure center-block">
  <img alt="" src="assets/images/scalability_L2T3.png" class="figure-img img-fluid">
  <figcaption class="figure-caption">L2T3</figcaption>
</figure>

<figure class="figure center-block">
  <img alt="" src="assets/images/scalability_S2T1.png" class="figure-img img-fluid">
  <figcaption class="figure-caption">S2T1</figcaption>
</figure>

<figure class="figure center-block">
  <img alt="" src="assets/images/scalability_S2T2.png" class="figure-img img-fluid">
  <figcaption class="figure-caption">S2T2</figcaption>
</figure>

<figure class="figure center-block">
  <img alt="" src="assets/images/scalability_S2T3.png" class="figure-img img-fluid">
  <figcaption class="figure-caption">S2T3</figcaption>
</figure>

<figure class="figure center-block">
  <img alt="" src="assets/images/mhoro/SCALABILITY_L3T2_KEY.png" class="figure-img img-fluid">
  <figcaption class="figure-caption">L3T2_KEY</figcaption>
</figure>

<figure class="figure center-block">
  <img alt="" src="assets/images/mhoro/SCALABILITY_L3T3_KEY.png" class="figure-img img-fluid">
  <figcaption class="figure-caption">L3T3_KEY</figcaption>
</figure>

<figure class="figure center-block">
  <img alt="" src="assets/images/mhoro/SCALABILITY_L4T5_KEY.png" class="figure-img img-fluid">
  <figcaption class="figure-caption">L4T5_KEY</figcaption>
</figure>

<figure class="figure center-block">
  <img alt="" src="assets/images/mhoro/SCALABILITY_L4T7_KEY.png" class="figure-img img-fluid">
  <figcaption class="figure-caption">L4T7_KEY</figcaption>
</figure>

<figure class="figure center-block">
  <img alt="" src="assets/images/mhoro/SCALABILITY_L3T2_KEY_SHIFT.png" class="figure-img img-fluid">
  <figcaption class="figure-caption">L3T2_KEY_SHIFT</figcaption>
</figure>

<figure class="figure center-block">
  <img alt="" src="assets/images/mhoro/SCALABILITY_L3T3_KEY_SHIFT.png" class="figure-img img-fluid">
  <figcaption class="figure-caption">L3T3_KEY_SHIFT</figcaption>
</figure>

<figure class="figure center-block">
  <img alt="" src="assets/images/mhoro/SCALABILITY_L4T5_KEY_SHIFT.png" class="figure-img img-fluid">
  <figcaption class="figure-caption">L4T5_KEY_SHIFT</figcaption>
</figure>

<figure class="figure center-block">
  <img alt="" src="assets/images/mhoro/SCALABILITY_L4T7_KEY_SHIFT.png" class="figure-img img-fluid">
  <figcaption class="figure-caption">L4T7_KEY_SHIFT</figcaption>
</figure>



### Scalability structure semantics ### {#scalability_structure_semantics}

#### General #### {#general}

**Note:** The scalability_structure is intended for use by intermediate processing entities that may
perform selective layer elimination.  Its presence allows these entities to know the structure of the
video bitstream without have to decode individual frames.  Scalability structures should be placed
immediately after the sequence header so that these entities are informed of the scalability
structure of the video sequence as early as possible.
{:.alert .alert-info }

**spatial_layers_cnt_minus_1** indicates the number of spatial layers present in the coded video sequence minus one.

**spatial_layer_description_present_flag** indicates when set to 1 that the
spatial_layer_ref_id is present for each of the (spatial_layers_cnt_minus_1 + 1) layers, or that it is
not present when set to 0.

**spatial_layer_dimensions_present_flag** indicates when set to 1 that the
spatial_layer_max_width and spatial_layer_max_height parameters are present for each of
the (spatial_layers_cnt_minus_1 + 1) layers, or that it they are not present when set to 0.

**temporal_group_description_present_flag** indicates when set to 1 that the temporal dependency
information is present, or that it is not when set to 0.
When any temporal unit in a coded video sequence contains OBU extension headers
that have temporal_id values that are not equal to each other,
temporal_group_description_present_flag must be equal to 0.

**scalability_structure_reserved_3bits** must be set to zero and be ignored by decoders.

**spatial_layer_max_width[ i ]** specifies the maximum frame width for the frames with
spatial_id equal to i. This number must not be larger than max_frame_width_minus_1 + 1.

**spatial_layer_max_height[ i ]** specifies the maximum frame height for the frames with
spatial_id equal to i.  This number must not be larger than max_frame_height_minus_1 + 1.

**spatial_layer_ref_id[ i ]** specifies the spatial_id value of the frame within the current
temporal unit that the frame of layer i uses for reference. If no frame within the current temporal unit is
used for reference the value must be equal to 255.

**temporal_group_size** indicates the number of pictures in a temporal picture group. If the
temporal_group_size is greater than 0, then the scalability structure data allows the inter-picture
temporal dependency structure of the coded video sequence to be specified.  If the temporal_group_size is
greater than 0, then for temporal_group_size pictures in the temporal group, each picture's temporal
layer id (temporal_id), switch up points (temporal_group_temporal_switching_up_point_flag and
temporal_group_spatial_switching_up_point_flag), and the reference
picture indices (temporal_group_ref_pic_diff) are specified.

The first picture specified in a temporal group must have temporal_id equal to 0.

If the parameter temporal_group_size is not present or set to 0, then either there is only one temporal
layer or there is no fixed inter-picture temporal dependency present in the coded video sequence.

Note that for a given picture, all frames follow the same inter-picture temporal dependency structure.
However, the frame rate of each layer can be different from each other.  The specified dependency
structure in the scalability structure data must be for the highest frame rate layer.

**temporal_group_temporal_id[ i ]** specifies the temporal_id value for the i-th picture in the temporal group.

**temporal_group_temporal_switching_up_point_flag[ i ]** is set to 1 if subsequent (in decoding order) pictures with
a temporal_id higher than temporal_group_temporal_id[ i ] do not depend on any picture preceding the
current picture (in coding order) with temporal_id higher than temporal_group_temporal_id[ i ].

**Note:** This condition ensures that switching up to a higher frame rate is possible at the current
picture.
{:.alert .alert-info }

**temporal_group_spatial_switching_up_point_flag[ i ]**] is set to 1 if spatial layers of the
current picture in the temporal group (i.e., pictures with a spatial_id higher than zero) do not depend on
any picture preceding the current picture in the temporal group.

**temporal_group_ref_cnt[ i ]** indicates the number of reference pictures used by the i-th picture in the
temporal group.

**temporal_group_ref_pic_diff[ i ][ j ]** indicates, for the i-th picture in the temporal group, the temporal
distance between the i-th picture and the j-th reference picture used by the i-th picture.  The temporal
distance is measured in frames, counting only frames of identical spatial_id values.

**Note:** The scalability structure description does not allow different temporal prediction
structures across non-temporal layers (i.e., layers with different spatial_id values).  It also
only allows for a single reference picture for inter-layer prediction.
{:.alert .alert-info }

The following sections contain the value of these syntax elements for certain predefined modes.
Prediction structures having scalability_mode_idc values in the range 21 to 28, inclusive, cannot
be described using temporal group description syntax and are not described in the sections that follow.


#### L1T2 (Informative) #### {#l1t2_(informative)}

| ----------- | ------------------------------------------------ | ---------------- |
| **Layer** | **Spatial Layers Description**  | **Value**
|  | spatial_layers_cnt_minus_1 | 0
|  |  |
| **Picture** | **Temporal Group Description**  | **Value**
|  | temporal_group_size | 2
| 0 | temporal_group_temporal_id[0] | 0
|  | temporal_group_temporal_switching_up_point_flag[0] | 1
|  | temporal_group_spatial_switching_up_point_flag[0] | 0
|  | temporal_group_ref_cnt[0] | 1
|  |     temporal_group_ref_pic_diff[0][0] | 2
| 1 | temporal_group_temporal_id[1] | 1
|  | temporal_group_temporal_switching_up_point_flag[1] | 1
|  | temporal_group_spatial_switching_up_point_flag[1] | 0
|  | temporal_group_ref_cnt[1] | 1
|  |     temporal_group_ref_pic_diff[0][0] | 1
{:.table .table-sm .table-bordered }

#### L1T3 (Informative) #### {#l1t3_(informative)}

| ----------- | ------------------------------------------------ | ---------------- |
| **Layer** | **Spatial Layers Description**  | **Value**
|  | spatial_layers_cnt_minus_1 | 0
|  |  |
| **Picture** | **Temporal Group Description**  | **Value**
|  | temporal_group_size | 4
| 0 | temporal_group_temporal_id[0] | 0
|  | temporal_group_temporal_switching_up_point_flag[0] | 1
|  | temporal_group_spatial_switching_up_point_flag[0] | 0
|  | temporal_group_ref_cnt[0] | 1
|  |     temporal_group_ref_pic_diff[0][0] | 4
| 1 | temporal_group_temporal_id[1] | 2
|  | temporal_group_temporal_switching_up_point_flag[1] | 1
|  | temporal_group_spatial_switching_up_point_flag[1] | 0
|  | temporal_group_ref_cnt[1] | 1
|  |     temporal_group_ref_pic_diff[1][0] | 1
| 2 | temporal_group_temporal_id[2] | 1
|  | temporal_group_temporal_switching_up_point_flag[1] | 0
|  | temporal_group_ref_cnt[2] | 1
|  |     temporal_group_ref_pic_diff[2][0] | 2
| 3 | temporal_group_temporal_id[3] | 2
|  | temporal_group_temporal_switching_up_point_flag[1] | 1
|  | temporal_group_spatial_switching_up_point_flag[1] | 0
|  | temporal_group_ref_cnt[3] | 1
|  |     temporal_group_ref_pic_diff[3][0] | 1
{:.table .table-sm .table-bordered }

#### L2T1 / L2T1h (Informative) #### {#l2t1_/_l2t1h_(informative)}

| ----------- | ------------------------------------------------ | ---------------- |
| **Layer** | **Spatial Layers Description**  | **Value**
|  | spatial_layers_cnt_minus_1 | 1
| 0 | spatial_layer_ref_id[0] | 255
| 1 |  spatial_layer_ref_id[1] | 0
|  |  |
| **Picture** | **Temporal Group Description**  | **Value**
|  | temporal_group_size | 1
| 0 | temporal_group_temporal_id[0] | 0
|  | temporal_group_temporal_switching_up_point_flag[0] | 1
|  | temporal_group_spatial_switching_up_point_flag[0] | 0
|  | temporal_group_ref_cnt[0] | 1
|  |     temporal_group_ref_pic_diff[0][0] | 1
{:.table .table-sm .table-bordered }

#### L2T2 / L2T2h (Informative) #### {#l2t2_/_l2t2h_(informative)}

| ----------- | ------------------------------------------------ | ---------------- |
| **Layer** | **Spatial Layers Description**  | **Value**
|  | spatial_layers_cnt_minus_1 | 1
| 0 | spatial_layer_ref_id[0] | 255
| 1 |  spatial_layer_ref_id[1] | 0
|  |  |
| **Picture** | **Temporal Group Description**  | **Value**
|  | temporal_group_size | 2
| 0 | temporal_group_temporal_id[0] | 0
|  | temporal_group_temporal_switching_up_point_flag[0] | 1
|  | temporal_group_spatial_switching_up_point_flag[0] | 0
|  | temporal_group_ref_cnt[0] | 1
|  |     temporal_group_ref_pic_diff[0][0] | 2
| 1 | temporal_group_temporal_id[1] | 1
|  | temporal_group_temporal_switching_up_point_flag[1] | 1
|  | temporal_group_spatial_switching_up_point_flag[1] | 0
|  | temporal_group_ref_cnt[1] | 1
|  |     temporal_group_ref_pic_diff[1][0] | 1
{:.table .table-sm .table-bordered }

#### L2T3 / L2T3h (Informative) #### {#l2t3_/_l2t3h_(informative)}

| ----------- | ------------------------------------------------ | ---------------- |
| **Layer** | **Spatial Layers Description**  | **Value**
|  | spatial_layers_cnt_minus_1 | 1
| 0 | spatial_layer_ref_id[0] | 255
| 1 |  spatial_layer_ref_id[1] | 0
|  |  |
| **Picture** | **Temporal Group Description**  | **Value**
|  | temporal_group_size | 4
| 0 | temporal_group_temporal_id[0] | 0
|  | temporal_group_temporal_switching_up_point_flag[0] | 1
|  | temporal_group_spatial_switching_up_point_flag[0] | 0
|  | temporal_group_ref_cnt[0] | 1
|  |     temporal_group_ref_pic_diff[0][0] | 4
| 1 | temporal_group_temporal_id[1] | 2
|  | temporal_group_temporal_switching_up_point_flag[1] | 1
|  | temporal_group_spatial_switching_up_point_flag[1] | 0
|  | temporal_group_ref_cnt[1] | 1
|  |     temporal_group_ref_pic_diff[1][0] | 1
| 2 | temporal_group_temporal_id[2] | 1
|  | temporal_group_temporal_switching_up_point_flag[1] | 0
|  | temporal_group_ref_cnt[2] | 1
|  |     temporal_group_ref_pic_diff[2][0] | 2
| 3 | temporal_group_temporal_id[3] | 2
|  | temporal_group_temporal_switching_up_point_flag[1] | 1
|  | temporal_group_spatial_switching_up_point_flag[1] | 0
|  | temporal_group_ref_cnt[3] | 1
|  |     temporal_group_ref_pic_diff[3][0] | 1
{:.table .table-sm .table-bordered }

#### S2T1 / S2T1h (Informative) #### {#s2t1_/_s2t1h_(informative)}

| ----------- | ------------------------------------------------ | ---------------- |
| **Layer** | **Spatial Layers Description**  | **Value**
|  | spatial_layers_cnt_minus_1 | 1
| 0 | spatial_layer_ref_id[0] | 255
| 1 |  spatial_layer_ref_id[1] | 255
|  |  |
| **Picture** | **Temporal Group Description**  | **Value**
|  | temporal_group_size | 1
| 0 | temporal_group_temporal_id[0] | 0
|  | temporal_group_temporal_switching_up_point_flag[0] | 1
|  | temporal_group_spatial_switching_up_point_flag[0] | 0
|  | temporal_group_ref_cnt[0] | 1
|  |     temporal_group_ref_pic_diff[0][0] | 1
{:.table .table-sm .table-bordered }

#### S2T2 / S2T2h (Informative) #### {#s2t2_/_s2t2h_(informative)}

| ----------- | ------------------------------------------------ | ---------------- |
| **Layer** | **Spatial Layers Description**  | **Value**
|  | spatial_layers_cnt_minus_1 | 1
| 0 | spatial_layer_ref_id[0] | 255
| 1 |  spatial_layer_ref_id[1] | 255
|  |  |
| **Picture** | **Temporal Group Description**  | **Value**
|  | temporal_group_size | 2
| 0 | temporal_group_temporal_id[0] | 0
|  | temporal_group_temporal_switching_up_point_flag[0] | 1
|  | temporal_group_spatial_switching_up_point_flag[0] | 0
|  | temporal_group_ref_cnt[0] | 1
|  |     temporal_group_ref_pic_diff[0][0] | 2
| 1 | temporal_group_temporal_id[1] | 1
|  | temporal_group_temporal_switching_up_point_flag[1] | 1
|  | temporal_group_spatial_switching_up_point_flag[1] | 0
|  | temporal_group_ref_cnt[1] | 1
|  |     temporal_group_ref_pic_diff[1][0] | 1
{:.table .table-sm .table-bordered }

#### S2T3 / S2T3h (Informative) #### {#s2t3_/_s2t3h_(informative)}

| ----------- | ------------------------------------------------ | ---------------- |
| **Layer** | **Spatial Layers Description**  | **Value**
|  | spatial_layers_cnt_minus_1 | 1
| 0 | spatial_layer_ref_id[0] | 255
| 1 |  spatial_layer_ref_id[1] | 255
|  |  |
| **Picture** | **Temporal Group Description**  | **Value**
|  | temporal_group_size | 4
| 0 | temporal_group_temporal_id[0] | 0
|  | temporal_group_temporal_switching_up_point_flag[0] | 1
|  | temporal_group_spatial_switching_up_point_flag[0] | 0
|  | temporal_group_ref_cnt[0] | 1
|  |     temporal_group_ref_pic_diff[0][0] | 4
| 1 | temporal_group_temporal_id[1] | 2
|  | temporal_group_temporal_switching_up_point_flag[1] | 1
|  | temporal_group_spatial_switching_up_point_flag[1] | 0
|  | temporal_group_ref_cnt[1] | 1
|  |     temporal_group_ref_pic_diff[1][0] | 1
| 2 | temporal_group_temporal_id[2] | 1
|  | temporal_group_temporal_switching_up_point_flag[1] | 0
|  | temporal_group_ref_cnt[2] | 1
|  |     temporal_group_ref_pic_diff[2][0] | 2
| 3 | temporal_group_temporal_id[3] | 2
|  | temporal_group_temporal_switching_up_point_flag[1] | 1
|  | temporal_group_spatial_switching_up_point_flag[1] | 0
|  | temporal_group_ref_cnt[3] | 1
|  |     temporal_group_ref_pic_diff[3][0] | 1
{:.table .table-sm .table-bordered }

#### L3T1 (Informative) #### {#l3t1_(informative)}

| ----------- | ------------------------------------------------ | ---------------- |
| **Layer** | **Spatial Layers Description**  | **Value**
|  | spatial_layers_cnt_minus_1 | 1
| 0 | spatial_layer_ref_id[0] | 255
| 1 |  spatial_layer_ref_id[1] | 0
| 2 |  spatial_layer_ref_id[1] | 1

|  |  |
| **Picture** | **Temporal Group Description**  | **Value**
|  | temporal_group_size | 1
| 0 | temporal_group_temporal_id[0] | 0
|  | temporal_group_temporal_switching_up_point_flag[0] | 1
|  | temporal_group_spatial_switching_up_point_flag[0] | 0
|  | temporal_group_ref_cnt[0] | 1
|  |     temporal_group_ref_pic_diff[0][0] | 1
{:.table .table-sm .table-bordered }

#### L3T2 (Informative) #### {#l3t2_(informative)}

| ----------- | ------------------------------------------------ | ---------------- |
| **Layer** | **Spatial Layers Description**  | **Value**
|  | spatial_layers_cnt_minus_1 | 1
| 0 | spatial_layer_ref_id[0] | 255
| 1 |  spatial_layer_ref_id[1] | 0
| 2 |  spatial_layer_ref_id[1] | 1
|  |  |
| **Picture** | **Temporal Group Description**  | **Value**
|  | temporal_group_size | 2
| 0 | temporal_group_temporal_id[0] | 0
|  | temporal_group_temporal_switching_up_point_flag[0] | 1
|  | temporal_group_spatial_switching_up_point_flag[0] | 0
|  | temporal_group_ref_cnt[0] | 1
|  |     temporal_group_ref_pic_diff[0][0] | 2
| 1 | temporal_group_temporal_id[1] | 1
|  | temporal_group_temporal_switching_up_point_flag[1] | 1
|  | temporal_group_spatial_switching_up_point_flag[1] | 0
|  | temporal_group_ref_cnt[1] | 1
|  |     temporal_group_ref_pic_diff[1][0] | 1
{:.table .table-sm .table-bordered }

#### L3T3 (Informative) #### {#l3t3_(informative)}

| ----------- | ------------------------------------------------ | ---------------- |
| **Layer** | **Spatial Layers Description**  | **Value**
|  | spatial_layers_cnt_minus_1 | 1
| 0 | spatial_layer_ref_id[0] | 255
| 1 |  spatial_layer_ref_id[1] | 0
| 2 |  spatial_layer_ref_id[1] | 1
|  |  |
| **Picture** | **Temporal Group Description**  | **Value**
|  | temporal_group_size | 4
| 0 | temporal_group_temporal_id[0] | 0
|  | temporal_group_temporal_switching_up_point_flag[0] | 1
|  | temporal_group_spatial_switching_up_point_flag[0] | 0
|  | temporal_group_ref_cnt[0] | 1
|  |     temporal_group_ref_pic_diff[0][0] | 4
| 1 | temporal_group_temporal_id[1] | 2
|  | temporal_group_temporal_switching_up_point_flag[1] | 1
|  | temporal_group_spatial_switching_up_point_flag[1] | 0
|  | temporal_group_ref_cnt[1] | 1
|  |     temporal_group_ref_pic_diff[1][0] | 1
| 2 | temporal_group_temporal_id[2] | 1
|  | temporal_group_temporal_switching_up_point_flag[1] | 0
|  | temporal_group_ref_cnt[2] | 1
|  |     temporal_group_ref_pic_diff[2][0] | 2
| 3 | temporal_group_temporal_id[3] | 2
|  | temporal_group_temporal_switching_up_point_flag[1] | 1
|  | temporal_group_spatial_switching_up_point_flag[1] | 0
|  | temporal_group_ref_cnt[3] | 1
|  |     temporal_group_ref_pic_diff[3][0] | 1
{:.table .table-sm .table-bordered }

#### S3T1 (Informative) #### {#s3t1_(informative)}

| ----------- | ------------------------------------------------ | ---------------- |
| **Layer** | **Spatial Layers Description**  | **Value**
|  | spatial_layers_cnt_minus_1 | 1
| 0 | spatial_layer_ref_id[0] | 255
| 1 |  spatial_layer_ref_id[1] | 255
| 2 |  spatial_layer_ref_id[1] | 255

|  |  |
| **Picture** | **Temporal Group Description**  | **Value**
|  | temporal_group_size | 1
| 0 | temporal_group_temporal_id[0] | 0
|  | temporal_group_temporal_switching_up_point_flag[0] | 1
|  | temporal_group_spatial_switching_up_point_flag[0] | 0
|  | temporal_group_ref_cnt[0] | 1
|  |     temporal_group_ref_pic_diff[0][0] | 1
{:.table .table-sm .table-bordered }

#### S3T2 (Informative) #### {#s3t2_(informative)}

| ----------- | ------------------------------------------------ | ---------------- |
| **Layer** | **Spatial Layers Description**  | **Value**
|  | spatial_layers_cnt_minus_1 | 1
| 0 | spatial_layer_ref_id[0] | 255
| 1 |  spatial_layer_ref_id[1] | 255
| 2 |  spatial_layer_ref_id[1] | 255
|  |  |
| **Picture** | **Temporal Group Description**  | **Value**
|  | temporal_group_size | 2
| 0 | temporal_group_temporal_id[0] | 0
|  | temporal_group_temporal_switching_up_point_flag[0] | 1
|  | temporal_group_spatial_switching_up_point_flag[0] | 0
|  | temporal_group_ref_cnt[0] | 1
|  |     temporal_group_ref_pic_diff[0][0] | 2
| 1 | temporal_group_temporal_id[1] | 1
|  | temporal_group_temporal_switching_up_point_flag[1] | 1
|  | temporal_group_spatial_switching_up_point_flag[1] | 0
|  | temporal_group_ref_cnt[1] | 1
|  |     temporal_group_ref_pic_diff[1][0] | 1
{:.table .table-sm .table-bordered }

#### S3T3 (Informative) #### {#s3t3_(informative)}

| ----------- | ------------------------------------------------ | ---------------- |
| **Layer** | **Spatial Layers Description**  | **Value**
|  | spatial_layers_cnt_minus_1 | 1
| 0 | spatial_layer_ref_id[0] | 255
| 1 |  spatial_layer_ref_id[1] | 255
| 2 |  spatial_layer_ref_id[1] | 255
|  |  |
| **Picture** | **Temporal Group Description**  | **Value**
|  | temporal_group_size | 4
| 0 | temporal_group_temporal_id[0] | 0
|  | temporal_group_temporal_switching_up_point_flag[0] | 1
|  | temporal_group_spatial_switching_up_point_flag[0] | 0
|  | temporal_group_ref_cnt[0] | 1
|  |     temporal_group_ref_pic_diff[0][0] | 4
| 1 | temporal_group_temporal_id[1] | 2
|  | temporal_group_temporal_switching_up_point_flag[1] | 1
|  | temporal_group_spatial_switching_up_point_flag[1] | 0
|  | temporal_group_ref_cnt[1] | 1
|  |     temporal_group_ref_pic_diff[1][0] | 1
| 2 | temporal_group_temporal_id[2] | 1
|  | temporal_group_temporal_switching_up_point_flag[1] | 0
|  | temporal_group_ref_cnt[2] | 1
|  |     temporal_group_ref_pic_diff[2][0] | 2
| 3 | temporal_group_temporal_id[3] | 2
|  | temporal_group_temporal_switching_up_point_flag[1] | 1
|  | temporal_group_spatial_switching_up_point_flag[1] | 0
|  | temporal_group_ref_cnt[3] | 1
|  |     temporal_group_ref_pic_diff[3][0] | 1
{:.table .table-sm .table-bordered }


### Metadata timecode semantics ### {#metadata_timecode_semantics}

**counting_type** specifies the method of dropping values of the n_frames syntax element
as specified in the table below. counting_type should be the same for all
pictures in the coded video sequence.

| counting_type | Meaning
| ------------- | ------------------
| 0             | no dropping of n_frames count values and no use of time_offset_value
| 1             | no dropping of n_frames count values
| 2             | dropping of individual zero values of n_frames count
| 3             | dropping of individual values of n_frames count equal to maxFps − 1
| 4             | dropping of the two lowest (value 0 and 1) n_frames counts when seconds_value is equal to 0 and minutes_value is not an integer multiple of 10
| 5             | dropping of unspecified individual n_frames count values
| 6             | dropping of unspecified numbers of unspecified n_frames count values
| 7..31         | reserved
{:.table .table-sm .table-bordered }

**full_timestamp_flag** equal to 1 indicates that the the seconds_value, minutes_value, hours_value syntax elements will be present.
full_timestamp_flag equal to 0 indicates that there are flags to control the presence of these syntax elements.

When timing_info_present_flag is equal to 1, the contents of the clock timestamp indicate a
time of origin, capture, or ideal display. This indicated time is computed as follows:

~~~~~c
if ( equal_picture_interval ) {
  ticksPerPicture = num_ticks_per_picture_minus_1 + 1
} else {
  ticksPerPicture = 1
}
ss = ( ( hours_value * 60 + minutes_value) * 60 + seconds_value )
clockTimestamp = ss * time_scale + n_frames * ticksPerPicture + time_offset_value
~~~~~

clockTimestamp is in units of clock ticks of a clock with clock frequency equal to time_scale Hz, relative to
some unspecified point in time for which clockTimestamp would be equal to 0.

**discontinuity_flag** equal to 0 indicates that the difference between the current value of
clockTimestamp and the value of clockTimestamp computed from the previous set of
timestamp syntax elements in output order can be interpreted as the time difference
between the times of origin or capture of the associated frames or fields.
discontinuity_flag equal to 1 indicates that the difference between the current value of
clockTimestamp and the value of clockTimestamp computed from the previous set of
clock timestamp syntax elements in output order should not be interpreted as the time
difference between the times of origin or capture of the associated frames or fields.

When timing_info_present_flag is equal to 1 and discontinuity_flag is equal to 0, the
value of clockTimestamp shall be greater than or equal to the value of clockTimestamp
for the previous set of clock timestamp syntax elements in output order.

**cnt_dropped_flag** specifies the skipping of one or more values of n_frames using the
counting method specified by counting_type.

**n_frames** is used to compute clockTimestamp. When
timing_info_present_flag is equal to 1, n_frames shall be less than maxFps, where
maxFps is specified by maxFps = ceil( time_scale / ( 2 * num_units_in_display_tick ) ).

**seconds_flag** equal to 1 specifies that seconds_value and minutes_flag are present
when full_timestamp_flag is equal to 0. seconds_flag equal to 0 specifies that
seconds_value and minutes_flag are not present.

**seconds_value** is used to compute clockTimestamp and shall be
in the range of 0 to 59. When seconds_value is not present, its value is inferred to be
equal to the value of seconds_value for the previous set of clock timestamp syntax
elements in decoding order, and it is required that such a previous seconds_value shall
have been present.

**minutes_flag** equal to 1 specifies that minutes_value and hours_flag are present when
full_timestamp_flag is equal to 0 and seconds_flag is equal to 1. minutes_flag equal to 0
specifies that minutes_value and hours_flag are not present.

**minutes_value** specifies the value of mm used to compute clockTimestamp and shall
be in the range of 0 to 59, inclusive. When minutes_value is not present, its value is
inferred to be equal to the value of minutes_value for the previous set of clock
timestamp syntax elements in decoding order, and it is required that such a previous
minutes_value shall have been present.

**hours_flag** equal to 1 specifies that hours_value is present when full_timestamp_flag is
equal to 0 and seconds_flag is equal to 1 and minutes_flag is equal to 1.

**hours_value** is used to compute clockTimestamp and shall be in
the range of 0 to 23, inclusive. When hours_value is not present, its value is inferred to
be equal to the value of hours_value for the previous set of clock timestamp syntax
elements in decoding order, and it is required that such a previous hours_value shall
have been present.

**time_offset_length** greater than 0 specifies the length in bits of the time_offset_value
syntax element. time_offset_length equal to 0 specifies that the time_offset_value syntax
element is not present. time_offset_length should be the same for all pictures in the
coded video sequence.

**time_offset_value** is used to compute clockTimestamp. The
number of bits used to represent time_offset_value is equal to time_offset_length. When
time_offset_value is not present, its value is inferred to be equal to 0.

## Frame header OBU semantics ## {#frame_header_obu_semantics}

### General frame header OBU semantics ### {#general_frame_header_obu_semantics}

It is a requirement of bitstream conformance that a sequence header OBU has been received
before a frame header OBU.

**frame_header_copy** is a function call that indicates that a copy of the previous
frame_header_obu should be inserted at this point.

**Note:** Bitstreams may contain several copies of the frame_header_obu interspersed
with tile_group_obu to allow for greater error resilience.
However, the copies must contain identical contents to the original frame_header_obu.
{:.alert .alert-info }

If obu_type is equal to OBU_FRAME_HEADER or obu_type is equal to OBU_FRAME, it is a requirement of bitstream conformance that
SeenFrameHeader is equal to 0.

If obu_type is equal to OBU_REDUNDANT_FRAME_HEADER, it is a requirement of bitstream conformance that
SeenFrameHeader is equal to 1.

**Note:** These requirements ensure that the first frame header for a frame has obu_type equal to OBU_FRAME_HEADER,
while later copies of this frame header (if present) have obu_type equal to OBU_REDUNDANT_FRAME_HEADER.
{:.alert .alert-info }

**TileNum** is a variable giving the index (zero-based) of the current tile.

**decode_frame_wrapup** is a function call that indicates that the decode frame wrapup process
specified in [section 7.4][] should be invoked.

### Uncompressed header semantics ### {#uncompressed_header_semantics}

**show_existing_frame** equal to 1, indicates the frame indexed by
frame_to_show_map_idx is to be output; show_existing_frame equal to 0
indicates that further processing is required.

If obu_type is equal to OBU_FRAME, it is a requirement of bitstream conformance that show_existing_frame is equal to 0.

**frame_to_show_map_idx** specifies the frame to be output. It is only
available if show_existing_frame is 1.

**display_frame_id** provides the frame id number for the frame to output.
It is a requirement of bitstream conformance that whenever display_frame_id is read, the value matches RefFrameId[ frame_to_show_map_idx ]
(the value of current_frame_id at the time that the frame indexed by
frame_to_show_map_idx was stored), and that RefValid[ frame_to_show_map_idx ] is equal to 1.

It is a requirement of bitstream conformance that the number of bits needed to read display_frame_id
does not exceed 16.  This is equivalent to the constraint that idLen <= 16.

**frame_type** specifies the type of the frame:

| frame_type | Name of frame_type
| ---------- | ------------------
| 0          | KEY_FRAME
| 1          | INTER_FRAME
| 2          | INTRA_ONLY_FRAME
| 3          | SWITCH_FRAME
{:.table .table-sm .table-bordered }

**show_frame** equal to 1 specifies that this frame should be immediately output once decoded.
show_frame equal to 0 specifies that this frame should not be immediately output.
(It may be output later if a later uncompressed header uses show_existing_frame equal to 1).

**showable_frame** equal to 1 specifies that the frame may be output using the show_existing_frame mechanism.
showable_frame equal to 0 specifies that this frame will not be output using the show_existing_frame mechanism.

It is a requirement of bitstream conformance that when show_existing_frame is used to show a previous frame,
that the value of showable_frame for the previous frame was equal to 1.

It is a requirement of bitstream conformance that when show_existing_frame is used to show a previous frame with RefFrameType[ frame_to_show_map_idx ] equal to KEY_FRAME,
that the frame is output via the show_existing_frame mechanism at most once.

**Note:** This requirement also forbids storing a frame with frame_type equal to KEY_FRAME into multiple reference frames and then using show_existing_frame for each reference frame.
{:.alert .alert-info }

**error_resilient_mode** equal to 1 indicates that error resilient mode is
enabled; error_resilient_mode equal to 0 indicates that error resilient mode
is disabled.

**Note:** Error resilient mode allows the syntax of a frame to be parsed
independently of previously decoded frames.
{:.alert .alert-info }

**disable_cdf_update** specifies whether the CDF update in the symbol decoding process should be
disabled.

**current_frame_id** specifies the frame id number for the current frame.
Frame id numbers are additional information that do not affect the decoding process, but provide decoders
with a way of detecting missing reference frames so that appropriate action can be taken.

If frame_type is not equal to KEY_FRAME or show_frame is equal to 0, it is a requirement of bitstream conformance
that all of the following conditions are true:

  * current_frame_id is not equal to PrevFrameID,

  * DiffFrameID is less than 1 \<\< ( idLen - 1 )

where DiffFrameID is specified as follows:

  * If current_frame_id is greater than PrevFrameID, DiffFrameID is equal to current_frame_id - PrevFrameID.

  * Otherwise, DiffFrameID is equal to ( 1 \<\< idLen ) + current_frame_id - PrevFrameID.

**frame_size_override_flag** equal to 0 specifies that the frame size is equal to the size in the sequence header.
frame_size_override_flag equal to 1 specifies that the frame size
will either be specified as the size of one of the reference frames, or computed from the
frame_width_minus_1 and frame_height_minus_1 syntax elements.

**order_hint** is used to compute OrderHint.

**OrderHint** specifies OrderHintBits least significant bits of the expected output order for this frame.

**Note:** There is no requirement that OrderHint should reflect the true output order.
As a guideline, the motion vector prediction is expected to be more accurate if the true output order is used for frames that will be shown later.
If a frame is never to be shown (e.g. it has been constructed as an average of several frames for reference purposes),
the encoder is free to choose whichever value of OrderHint will give the best compression.
{:.alert .alert-info }

**primary_ref_frame** specifies which reference frame contains the CDF values and other state that should be loaded at the start of the frame.

**Note:** It is allowed for primary_ref_frame to be coded as PRIMARY_REF_NONE, this will cause default
values to be used for the CDF values and other state.
{:.alert .alert-info }

**buffer_removal_time_present_flag** equal to 1 specifies that buffer_removal_time is present.
buffer_removal_time_present_flag equal to 0 specifies that buffer_removal_time is not present.

**buffer_removal_time[ opNum ]** specifies the frame removal time in units of DecCT
clock ticks counted from the removal time of the last random access point
for operating point opNum when the current frame is not associated with a random access point and from
the previous random access point when the current frame is associated with a random access point.
buffer_removal_time is signaled as a fixed length unsigned integer with a length in bits
given by buffer_removal_time_length_minus_1 + 1.

buffer_removal_time is the remainder of a modulo 1 \<\< ( buffer_removal_time_length_minus_1 + 1 ) counter.

**allow_screen_content_tools** equal to 1 indicates that intra blocks may use
palette encoding; allow_screen_content_tools equal to 0 indicates that palette
encoding is never used.

**allow_intrabc** equal to 1 indicates that intra block copy may be used in this frame.
allow_intrabc equal to 0 indicates that intra block copy is not allowed in this frame.

**Note:** intra block copy is only allowed in intra frames, and disables all loop filtering.
force_integer_mv will be equal to 1 for intra frames, so only integer offsets are allowed in block copy mode.
{:.alert .alert-info }

**force_integer_mv** equal to 1 specifies that motion vectors will always be integers.
force_integer_mv equal to 0 specifies that motion vectors can contain fractional bits.

**ref_order_hint[ i ]** specifies the expected output order hint for each reference frame.

**Note:**
The values in the ref_order_hint array are provided to allow implementations to gracefully handle
cases when some frames have been lost.
{:.alert .alert-info }

**Note:** When scalability is used, the values in RefOrderHint during the decode process
may depend on the selected operating point.
{:.alert .alert-info }

**refresh_frame_flags** contains a bitmask that specifies which reference frame
slots will be updated with the current frame after it is decoded.

If frame_type is equal to INTRA_ONLY_FRAME, it is a requirement of bitstream conformance
that refresh_frame_flags is not equal to 0xff.

**Note:** This restriction encourages encoders to correctly label random access points
(by forcing frame_type to be equal to KEY_FRAME when an intra frame is used to reset the decoding process).
{:.alert .alert-info }

See [section 7.20][] for details of the frame update process.

**frame_refs_short_signaling** equal to 1 indicates that only two reference frames are explicitly signaled.
frame_refs_short_signaling equal to 0 indicates that all reference frames are explicitly signaled.

**last_frame_idx** specifies the reference frame to use for LAST_FRAME.

**gold_frame_idx** specifies the reference frame to use for GOLDEN_FRAME.

**set_frame_refs** is a function call that indicates the conceptual point where
the ref_frame_idx values are computed (in the case when frame_refs_short_signaling is equal to 1, these syntax elements are computed instead of being explicitly signaled).
When this function is called, the set frame refs
process specified in [section 7.8][] is invoked.

**ref_frame_idx[ i ]** specifies which reference frames are used by inter frames. It
is a requirement of bitstream conformance that RefValid[ ref_frame_idx[ i ] ] is equal
to 1, and that the selected reference frames match the current frame in bit depth,
profile, chroma subsampling, and color space.

**Note:** Syntax elements indicate a reference (such as LAST_FRAME, ALTREF_FRAME).
These references are looked up in the ref_frame_idx array to find which reference frame should
be used during inter prediction.
There is no requirement that the values in ref_frame_idx should be distinct.
{:.alert .alert-info }

**RefFrameSignBias** specifies the intended direction of the motion vector
in time for each reference frame. A sign bias equal to 0 indicates that the
reference frame is a forwards reference (i.e. the reference frame is expected to
be output before the current frame); a sign bias equal to 1 indicates that
the reference frame is a backwards reference.

**Note:** The sign bias is just an indication that can improve the accuracy of
motion vector prediction and is not constrained to reflect the actual output
order of pictures.
{:.alert .alert-info }

**delta_frame_id_minus_1** is used to calculate DeltaFrameId.

**DeltaFrameId** specifies the distance to the frame id for the reference frame.

**RefFrameId[ i ]** specifies the frame id for each reference frame.

**expectedFrameId[ i ]** specifies the frame id for each frame used for
reference. It is a requirement of bitstream conformance that whenever
expectedFrameId[ i ] is calculated, the value matches
RefFrameId[ ref_frame_idx[ i ] ]
(this contains the value of current_frame_id at the time that the frame indexed
by ref_frame_idx[ i ] was stored).

**allow_high_precision_mv** equal to 0 specifies that motion vectors are
specified to quarter pel precision; allow_high_precision_mv equal to 1
specifies that motion vectors are specified to eighth pel precision.

**is_motion_mode_switchable** equal to 0 specifies that only the SIMPLE
motion mode will be used.

**use_ref_frame_mvs** equal to 1 specifies that motion vector information
from a previous frame can be used when decoding the current frame.
use_ref_frame_mvs equal to 0 specifies that this information will not be used.

**disable_frame_end_update_cdf** equal to 1 indicates that the end of frame CDF update is disabled;
disable_frame_end_update_cdf equal to 0 indicates that the end of frame CDF update is enabled.

**Note:** It can be useful to disable the CDF update because it means the next frame can start to be decoded
as soon as the frame headers of the current frame have been processed.
{:.alert .alert-info }

**motion_field_estimation** is a function call which indicates that the motion field estimation process in [section 7.9][] should be
invoked.

**OrderHints** specifies the expected output order for each reference frame.

**CodedLossless** is a variable that is equal to 1 when all segments use lossless
encoding.  This indicates that the frame is fully lossless at the coded resolution of FrameWidth by FrameHeight.
In this case, the loop filter and CDEF filter are disabled.

It is a requirement of bitstream conformance that delta_q_present is equal to 0 when CodedLossless is equal to 1.

**AllLossless** is a variable that is equal to 1 when CodedLossless is equal to 1 and FrameWidth is equal to UpscaledWidth.
This indicates that the frame is fully lossless at the upscaled resolution.
In this case, the loop filter, CDEF filter, and loop restoration are disabled.

**allow_warped_motion** equal to 1 indicates that the syntax element motion_mode may be present.
allow_warped_motion equal to 0 indicates that the syntax element motion_mode will not be present
(this means that LOCALWARP cannot be signaled if allow_warped_motion is equal to 0).

**reduced_tx_set** equal to 1 specifies that the frame is restricted to a
reduced subset of the full set of transform types.

**setup_past_independence** is a function call that indicates that this frame
can be decoded without dependence on previous coded frames. When this function
is invoked the following takes place:

  * FeatureData[ i ][ j ] and FeatureEnabled[ i ][ j ] are set equal to 0 for
    i = 0..MAX_SEGMENTS-1 and j = 0..SEG_LVL_MAX-1.

  * PrevSegmentIds[ row ][ col ] is set equal to 0 for row = 0..MiRows-1 and
    col = 0..MiCols-1.

  * PrevGmParams[ ref ][ i ] is set equal to ( ( i % 3 == 2 ) ? 1 \<\< WARPEDMODEL_PREC_BITS : 0 )
    for ref = LAST_FRAME..ALTREF_FRAME, for i = 0..5.

  * loop_filter_delta_enabled is set equal to 1.

  * loop_filter_ref_deltas[ INTRA_FRAME ] is set equal to 1.

  * loop_filter_ref_deltas[ LAST_FRAME ] is set equal to 0.

  * loop_filter_ref_deltas[ LAST2_FRAME ] is set equal to 0.

  * loop_filter_ref_deltas[ LAST3_FRAME ] is set equal to 0.

  * loop_filter_ref_deltas[ BWDREF_FRAME ] is set equal to 0.

  * loop_filter_ref_deltas[ GOLDEN_FRAME ] is set equal to -1.

  * loop_filter_ref_deltas[ ALTREF_FRAME ] is set equal to -1.

  * loop_filter_ref_deltas[ ALTREF2_FRAME ] is set equal to -1.

  * loop_filter_mode_deltas[ i ] is set equal to 0 for i = 0..1.

**init_non_coeff_cdfs** is a function call that indicates that the CDF tables
which are not used in the coeff( ) syntax structure should be initialised. When
this function is invoked, the following steps apply:

  * YModeCdf is set to a copy of Default_Y_Mode_Cdf

  * UVModeCflNotAllowedCdf is set to a copy of Default_Uv_Mode_Cfl_Not_Allowed_Cdf

  * UVModeCflAllowedCdf is set to a copy of Default_Uv_Mode_Cfl_Allowed_Cdf

  * AngleDeltaCdf is set to a copy of Default_Angle_Delta_Cdf

  * IntrabcCdf is set to a copy of Default_Intrabc_Cdf

  * PartitionW8Cdf is set to a copy of Default_Partition_W8_Cdf

  * PartitionW16Cdf is set to a copy of Default_Partition_W16_Cdf

  * PartitionW32Cdf is set to a copy of Default_Partition_W32_Cdf

  * PartitionW64Cdf is set to a copy of Default_Partition_W64_Cdf

  * PartitionW128Cdf is set to a copy of Default_Partition_W128_Cdf

  * SegmentIdCdf is set to a copy of Default_Segment_Id_Cdf

  * SegmentIdPredictedCdf is set to a copy of Default_Segment_Id_Predicted_Cdf

  * Tx8x8Cdf is set to a copy of Default_Tx_8x8_Cdf

  * Tx16x16Cdf is set to a copy of Default_Tx_16x16_Cdf

  * Tx32x32Cdf is set to a copy of Default_Tx_32x32_Cdf

  * Tx64x64Cdf is set to a copy of Default_Tx_64x64_Cdf

  * TxfmSplitCdf is set to a copy of Default_Txfm_Split_Cdf

  * FilterIntraModeCdf is set to a copy of Default_Filter_Intra_Mode_Cdf

  * FilterIntraCdf is set to a copy of Default_Filter_Intra_Cdf

  * InterpFilterCdf is set to a copy of Default_Interp_Filter_Cdf

  * MotionModeCdf is set to a copy of Default_Motion_Mode_Cdf

  * NewMvCdf is set to a copy of Default_New_Mv_Cdf

  * ZeroMvCdf is set to a copy of Default_Zero_Mv_Cdf

  * RefMvCdf is set to a copy of Default_Ref_Mv_Cdf

  * CompoundModeCdf is set to a copy of Default_Compound_Mode_Cdf

  * DrlModeCdf is set to a copy of Default_Drl_Mode_Cdf

  * IsInterCdf is set to a copy of Default_Is_Inter_Cdf

  * CompModeCdf is set to a copy of Default_Comp_Mode_Cdf

  * SkipModeCdf is set to a copy of Default_Skip_Mode_Cdf

  * SkipCdf is set to a copy of Default_Skip_Cdf

  * CompRefCdf is set to a copy of Default_Comp_Ref_Cdf

  * CompBwdRefCdf is set to a copy of Default_Comp_Bwd_Ref_Cdf

  * SingleRefCdf is set to a copy of Default_Single_Ref_Cdf

  * MvJointCdf[ i ] is set to a copy of Default_Mv_Joint_Cdf for i = 0..MV_CONTEXTS-1

  * MvClassCdf[ i ] is set to a copy of Default_Mv_Class_Cdf for i = 0..MV_CONTEXTS-1

  * MvClass0BitCdf[ i ][ comp ] is set to a copy of Default_Mv_Class0_Bit_Cdf for i = 0..MV_CONTEXTS-1 and comp = 0..1

  * MvFrCdf[ i ] is set to a copy of Default_Mv_Fr_Cdf for i = 0..MV_CONTEXTS-1

  * MvClass0FrCdf[ i ] is set to a copy of Default_Mv_Class0_Fr_Cdf for i = 0..MV_CONTEXTS-1

  * MvClass0HpCdf[ i ][ comp ] is set to a copy of Default_Mv_Class0_Hp_Cdf for i = 0..MV_CONTEXTS-1 and comp = 0..1

  * MvSignCdf[ i ][ comp ] is set to a copy of Default_Mv_Sign_Cdf for i = 0..MV_CONTEXTS-1 and comp = 0..1

  * MvBitCdf[ i ][ comp ] is set to a copy of Default_Mv_Bit_Cdf for i = 0..MV_CONTEXTS-1 and comp = 0..1

  * MvHpCdf[ i ][ comp ] is set to a copy of Default_Mv_Hp_Cdf for i = 0..MV_CONTEXTS-1 and comp = 0..1

  * PaletteYModeCdf is set to a copy of Default_Palette_Y_Mode_Cdf

  * PaletteUVModeCdf is set to a copy of Default_Palette_Uv_Mode_Cdf

  * PaletteYSizeCdf is set to a copy of Default_Palette_Y_Size_Cdf

  * PaletteUVSizeCdf is set to a copy of Default_Palette_Uv_Size_Cdf

  * PaletteSize2YColorCdf is set to a copy of
    Default_Palette_Size_2_Y_Color_Cdf

  * PaletteSize2UVColorCdf is set to a copy of
    Default_Palette_Size_2_Uv_Color_Cdf

  * PaletteSize3YColorCdf is set to a copy of
    Default_Palette_Size_3_Y_Color_Cdf

  * PaletteSize3UVColorCdf is set to a copy of
    Default_Palette_Size_3_Uv_Color_Cdf

  * PaletteSize4YColorCdf is set to a copy of
    Default_Palette_Size_4_Y_Color_Cdf

  * PaletteSize4UVColorCdf is set to a copy of
    Default_Palette_Size_4_Uv_Color_Cdf

  * PaletteSize5YColorCdf is set to a copy of
    Default_Palette_Size_5_Y_Color_Cdf

  * PaletteSize5UVColorCdf is set to a copy of
    Default_Palette_Size_5_Uv_Color_Cdf

  * PaletteSize6YColorCdf is set to a copy of
    Default_Palette_Size_6_Y_Color_Cdf

  * PaletteSize6UVColorCdf is set to a copy of
    Default_Palette_Size_6_Uv_Color_Cdf

  * PaletteSize7YColorCdf is set to a copy of
    Default_Palette_Size_7_Y_Color_Cdf

  * PaletteSize7UVColorCdf is set to a copy of
    Default_Palette_Size_7_Uv_Color_Cdf

  * PaletteSize8YColorCdf is set to a copy of
    Default_Palette_Size_8_Y_Color_Cdf

  * PaletteSize8UVColorCdf is set to a copy of
    Default_Palette_Size_8_Uv_Color_Cdf

  * DeltaQCdf is set to a copy of Default_Delta_Q_Cdf

  * DeltaLFCdf is set to a copy of Default_Delta_Lf_Cdf

  * DeltaLFMultiCdf[ i ] is set to a copy of Default_Delta_Lf_Cdf for i = 0..FRAME_LF_COUNT-1

  * IntraTxTypeSet1Cdf is set to a copy of Default_Intra_Tx_Type_Set1_Cdf

  * IntraTxTypeSet2Cdf is set to a copy of Default_Intra_Tx_Type_Set2_Cdf

  * InterTxTypeSet1Cdf is set to a copy of Default_Inter_Tx_Type_Set1_Cdf

  * InterTxTypeSet2Cdf is set to a copy of Default_Inter_Tx_Type_Set2_Cdf

  * InterTxTypeSet3Cdf is set to a copy of Default_Inter_Tx_Type_Set3_Cdf

  * UseObmcCdf is set to a copy of Default_Use_Obmc_Cdf

  * InterIntraCdf is set to a copy of Default_Inter_Intra_Cdf

  * CompRefTypeCdf is set to a copy of Default_Comp_Ref_Type_Cdf

  * CflSignCdf is set to a copy of Default_Cfl_Sign_Cdf

  * UniCompRefCdf is set to a copy of Default_Uni_Comp_Ref_Cdf

  * WedgeInterIntraCdf is set to a copy of Default_Wedge_Inter_Intra_Cdf

  * CompGroupIdxCdf is set to a copy of Default_Comp_Group_Idx_Cdf

  * CompoundIdxCdf is set to a copy of Default_Compound_Idx_Cdf

  * CompoundTypeCdf is set to a copy of Default_Compound_Type_Cdf

  * InterIntraModeCdf is set to a copy of Default_Inter_Intra_Mode_Cdf

  * WedgeIndexCdf is set to a copy of Default_Wedge_Index_Cdf

  * CflAlphaCdf is set to a copy of Default_Cfl_Alpha_Cdf

  * UseWienerCdf is set to a copy of Default_Use_Wiener_Cdf

  * UseSgrprojCdf is set to a copy of Default_Use_Sgrproj_Cdf

  * RestorationTypeCdf is set to a copy of Default_Restoration_Type_Cdf

**init_coeff_cdfs( )** is a function call that indicates that the CDF tables
used in the coeff( ) syntax structure should be initialised. When this function
is invoked, the following steps apply:

  * The variable idx is derived as follows:

    * If base_q_idx is less than or equal to 20, idx is set equal to 0.

    * Otherwise, if base_q_idx is less than or equal to 60, idx is set equal to 1.

    * Otherwise, if base_q_idx is less than or equal to 120, idx is set equal to 2.

    * Otherwise, idx is set equal to 3.

  * The cumulative distribution function arrays are reset to default values as follows:

    * TxbSkipCdf is set to a copy of Default_Txb_Skip_Cdf[ idx ].

    * EobPt16Cdf is set to a copy of Default_Eob_Pt_16_Cdf[ idx ].

    * EobPt32Cdf is set to a copy of Default_Eob_Pt_32_Cdf[ idx ].

    * EobPt64Cdf is set to a copy of Default_Eob_Pt_64_Cdf[ idx ].

    * EobPt128Cdf is set to a copy of Default_Eob_Pt_128_Cdf[ idx ].

    * EobPt256Cdf is set to a copy of Default_Eob_Pt_256_Cdf[ idx ].

    * EobPt512Cdf is set to a copy of Default_Eob_Pt_512_Cdf[ idx ].

    * EobPt1024Cdf is set to a copy of Default_Eob_Pt_1024_Cdf[ idx ].

    * EobExtraCdf is set to a copy of Default_Eob_Extra_Cdf[ idx ].

    * DcSignCdf is set to a copy of Default_Dc_Sign_Cdf[ idx ].

    * CoeffBaseEobCdf is set to a copy of Default_Coeff_Base_Eob_Cdf[ idx ].

    * CoeffBaseCdf is set to a copy of Default_Coeff_Base_Cdf[ idx ].

    * CoeffBrCdf is set to a copy of Default_Coeff_Br_Cdf[ idx ].

**load_cdfs( ctx )** is a function call that indicates that the CDF tables are
loaded from frame context number ctx in the range 0 to (NUM_REF_FRAMES - 1).
When this function is invoked, a copy of each CDF array mentioned in the
semantics for init_coeff_cdfs and init_non_coeff_cdfs is loaded from an area of memory indexed
by ctx. (The memory contents of these frame contexts have been initialized by
previous calls to save_cdfs).  Once the CDF arrays have been loaded, the last entry
in each array, representing the symbol count for that context, is set to 0.

**load_previous( )** is a function call that indicates that information from a
previous frame may be loaded for use in decoding the current frame.
When this function is invoked the following ordered steps apply:

  1. The variable prevFrame is set equal to ref_frame_idx[ primary_ref_frame ].

  2. PrevGmParams is set equal to SavedGmParams[ prevFrame ].

  3. The function load_loop_filter_params( prevFrame ) specified in [section 7.21][] is invoked.

  4. The function load_segmentation_params( prevFrame ) specified in [section 7.21][] is invoked.

**load_previous_segment_ids( )** is a function call that indicates that a segmentation map from a
previous frame may be loaded for use in decoding the current frame.
When this function is invoked the segmentation map contained in PrevSegmentIds is set as follows:

  1. The variable prevFrame is set equal to ref_frame_idx[ primary_ref_frame ].

  2. If segmentation_enabled is equal to 1, RefMiCols[ prevFrame ] is equal to MiCols, and
     RefMiRows[ prevFrame ] is equal to MiRows, PrevSegmentIds[ row ][ col ] is set equal to
     SavedSegmentIds[ prevFrame ][ row ][ col ] for row = 0..MiRows-1, for col = 0..MiCols-1.

     Otherwise, PrevSegmentIds[ row ][ col ] is set equal to 0 for row = 0..MiRows-1, for col = 0..MiCols-1.

### Reference frame marking semantics ### {#reference_frame_marking_semantics}

**RefValid** is an array which is indexed by a reference picture slot number. A value of 1 in the array signifies
that the corresponding reference picture slot is valid for use as a reference picture, while a value of 0 signifies
that the corresponding reference picture slot is not valid for use as a reference picture.

**Note:** RefValid is used for bitstream conformance checking.
Frames are marked as invalid when they are too far in the past to be referenced by the frame id mechanism
or when the order hints do not match.
{:.alert .alert-info }


### Frame size semantics ### {#frame_size_semantics}

**frame_width_minus_1** plus one is the width of the frame in luma samples.

**frame_height_minus_1** plus one is the height of the frame in luma samples.

It is a requirement of bitstream conformance that frame_width_minus_1 is less than or equal to max_frame_width_minus_1.

It is a requirement of bitstream conformance that frame_height_minus_1 is less than or equal to max_frame_height_minus_1.

If FrameIsIntra is equal to 0 (indicating that this frame may use inter prediction), the requirements described in the frame size with refs semantics of [section 6.8.6] must also be satisfied.

### Render size semantics ### {#render_size_semantics}

The render size is provided as a hint to the application about the desired
display size. It has no effect on the decoding process.

**render_and_frame_size_different** equal to 0 means that the render width and
height are inferred from the frame width and height.
render_and_frame_size_different equal to 1 means that the render width and
height are explicitly coded.

**Note:** It is allowed for the bitstream to explicitly code the render
dimensions in the bitstream even if they are an exact match for the frame
dimensions.
{:.alert .alert-info }

**render_width_minus_1** plus one is the render width of the frame in luma samples.

**render_height_minus_1** plus one is the render height of the frame in luma samples.


### Frame size with refs semantics ### {#frame_size_with_refs_semantics}

For inter frames, the frame size is either set equal to the size of a reference
frame, or can be sent explicitly.

**found_ref** equal to 1 indicates that the frame dimensions can be inferred
from reference frame i where i is the loop counter in the syntax parsing
process for frame_size_with_refs. found_ref equal to 0 indicates that the
frame dimensions are not inferred from reference frame i.

Once the FrameWidth and FrameHeight have been computed for an inter frame, it
is a requirement of bitstream conformance that for all values of i in
the range 0..(REFS_PER_FRAME - 1), all the following conditions are true:

  * 2 * FrameWidth >= RefUpscaledWidth[ ref_frame_idx[ i ] ]
  * 2 * FrameHeight >= RefFrameHeight[ ref_frame_idx[ i ] ]
  * FrameWidth <= 16 * RefUpscaledWidth[ ref_frame_idx[ i ] ]
  * FrameHeight <= 16 * RefFrameHeight[ ref_frame_idx[ i ] ]

**Note:** This is a requirement even if all the blocks in an inter frame are
coded using intra prediction.
{:.alert .alert-info }

### Superres params semantics ### {#superres_params_semantics}

**use_superres** equal to 0 indicates that no upscaling is needed.
use_superres equal to 1 indicates that upscaling is needed.

**coded_denom** is used to compute the amount of upscaling.

**SuperresDenom** is the denominator of a fraction that specifies the ratio between the superblock width before and after upscaling.
The numerator of this fraction is equal to the constant SUPERRES_NUM.

### Compute image size semantics ### {#compute_image_size_semantics}

**MiCols** is the number of 4x4 block columns in the frame.

**MiRows** is the number of 4x4 block rows in the frame.

### Interpolation filter semantics ### {#interpolation_filter_semantics}

**is_filter_switchable** equal to 1 indicates that the filter selection is
signaled at the block level; is_filter_switchable equal to 0 indicates that the
filter selection is signaled at the frame level.

**interpolation_filter** specifies the filter selection used for performing
inter prediction:


| interpolation_filter  | Name of interpolation_filter
|:---------------------:|:----------------------------:
| 0                     | EIGHTTAP
| 1                     | EIGHTTAP_SMOOTH
| 2                     | EIGHTTAP_SHARP
| 3                     | BILINEAR
| 4                     | SWITCHABLE
{:.table .table-sm .table-bordered }


### Loop filter semantics ### {#loop_filter_semantics}

**loop_filter_level** is an array containing loop filter strength values. Different
loop filter strength values from the array are used depending on the image plane being
filtered, and the edge direction (vertical or horizontal) being filtered.

**loop_filter_sharpness** indicates the sharpness level. The loop_filter_level
and loop_filter_sharpness together determine when a block edge is filtered, and
by how much the filtering can change the sample values.

The loop filter process is described in [section 7.14][].

**loop_filter_delta_enabled** equal to 1 means that the filter level depends on
the mode and reference frame used to predict a block. loop_filter_delta_enabled
equal to 0 means that the filter level does not depend on the mode and
reference frame.

**loop_filter_delta_update** equal to 1 means that
additional syntax elements are present that specify which mode and reference frame deltas
are to be updated. loop_filter_delta_update equal to 0 means that these syntax
elements are not present.

**update_ref_delta** equal to 1 means that the syntax
element loop_filter_ref_deltas is present; update_ref_delta equal to 0 means that
this syntax element is not present.

**loop_filter_ref_deltas** contains the adjustment needed for the filter level
based on the chosen reference frame. If this syntax element is not present,
it maintains its previous value.

**update_mode_delta** equal to 1 means that the syntax
element loop_filter_mode_deltas is present; update_mode_delta equal to 0 means that
this syntax element is not present.

**loop_filter_mode_deltas** contains the adjustment needed for the filter level
based on the chosen mode. If this syntax element is not present,
it maintains its previous value.

**Note:** The previous values for loop_filter_mode_deltas and
loop_filter_ref_deltas are intially set by the setup_past_independence function
and can be subsequently modified by these syntax elements being coded in a
previous frame.
{:.alert .alert-info }


### Quantization params semantics ### {#quantization_params_semantics}

The residual is specified via decoded coefficients which are adjusted by one of
four quantization parameters before the inverse transform is applied. The
choice depends on the plane (Y or UV) and coefficient position (DC/AC
coefficient). The Dequantization process is specified in [section 7.12][].

**base_q_idx** indicates the base frame qindex. This is used for Y AC
coefficients and as the base value for the other quantizers.

**DeltaQYDc** indicates the Y DC quantizer relative to base_q_idx.

**diff_uv_delta** equal to 1 indicates that the U and V delta quantizer values are coded separately.
diff_uv_delta equal to 0 indicates that the U and V delta quantizer values share a common value.

**DeltaQUDc** indicates the U DC quantizer relative to base_q_idx.

**DeltaQUAc** indicates the U AC quantizer relative to base_q_idx.

**DeltaQVDc** indicates the V DC quantizer relative to base_q_idx.

**DeltaQVAc** indicates the V AC quantizer relative to base_q_idx.

**using_qmatrix** specifies that the quantizer matrix will be used to
compute quantizers.

**qm_y** specifies the level in the quantizer matrix that should be used
for luma plane decoding.

**qm_u** specifies the level in the quantizer matrix that should be used
for chroma U plane decoding.

**qm_v** specifies the level in the quantizer matrix that should be used
for chroma V plane decoding.


### Delta quantizer semantics ### {#delta_quantizer_semantics}

**delta_coded** specifies that the delta_q syntax element is present.

**delta_q** specifies an offset (relative to base_q_idx) for a particular
quantization parameter.


### Segmentation params semantics ### {#segmentation_params_semantics}

AV1 provides a means of segmenting the image and then applying various
adjustments at the segment level.

Up to 8 segments may be specified for any given frame. For each of these
segments it is possible to specify:

  1. A quantizer (absolute value or delta).
  2. A loop filter strength (absolute value or delta).
  3. A prediction reference frame.
  4. A block skip mode that implies both the use of a (0,0) motion vector and
     that no residual will be coded.

Each of these data values for each segment may be individually updated at the
frame level. Where a value is not updated in a given frame, the value from the
previous frame persists. The exceptions to this are key frames, intra only
frames or other frames where independence from past frame values is required
(for example to enable error resilience). In such cases all values are reset
as described in the semantics for setup_past_independence.

The segment affiliation (the segmentation map) is stored at the resolution of
4x4 blocks. If no explicit update is coded for a block's segment affiliation,
then it persists from frame to frame (until reset by a call to
setup_past_independence).

**SegIdPreSkip** equal to 1 indicates that the segment id will be read before
the skip syntax element.  SegIdPreSkip equal to 0 indicates that the skip syntax element
will be read first.

**LastActiveSegId** indicates the highest numbered segment id that has some enabled feature.
This is used when decoding the segment id to only decode choices corresponding to used segments.

**segmentation_enabled** equal to 1 indicates that this frame makes use of the
segmentation tool; segmentation_enabled equal to 0 indicates that the frame
does not use segmentation.

**segmentation_update_map** equal to 1 indicates that the segmentation map is
updated during the decoding of this frame. segmentation_update_map equal to 0
means that the segmentation map from the previous frame is used.

**segmentation_temporal_update** equal to 1 indicates that the updates to the
segmentation map are coded relative to the existing segmentation map.
segmentation_temporal_update equal to 0 indicates that the new
segmentation map is coded without reference to the existing segmentation map.

**segmentation_update_data** equal to 1 indicates that new parameters are about
to be specified for each segment. segmentation_update_data equal to 0 indicates
that the segmentation parameters should keep their existing values.

**feature_enabled** equal to 0 indicates that the corresponding feature is
unused and has value equal to 0. feature_enabled equal to 1 indicates that the
feature value is coded.

**feature_value** specifies the feature data for a segment feature.

### Tile info semantics ### {#tile_info_semantics}

**uniform_tile_spacing_flag** equal to 1 means that the tiles are uniformly spaced
across the frame.  (In other words, all tiles are the same size except for the ones at the right and bottom edge which can be smaller.)
uniform_tile_spacing_flag equal to 0 means that the tile sizes are coded.

**increment_tile_cols_log2** is used to compute TileColsLog2.

**TileColsLog2** specifies the base 2 logarithm of the desired number of tiles
across the frame.

**TileCols** specifies the number of tiles across the frame.
It is a requirement of bitstream conformance that TileCols is less than or equal to MAX_TILE_COLS.

**increment_tile_rows_log2** is used to compute
TileRowsLog2.

**TileRowsLog2** specifies the base 2 logarithm of the desired number of tiles
down the frame.

**Note:** For small frame sizes the actual number of tiles in the frame may be
smaller than the desired number because the tile size is rounded up to a
multiple of the maximum superblock size.
{:.alert .alert-info }

**TileRows** specifies the number of tiles down the frame.
It is a requirement of bitstream conformance that TileRows is less than or equal to MAX_TILE_ROWS.

**tileWidthSb** is used to specify the width of each tile in units of superblocks.
It is a requirement of bitstream conformance that tileWidthSb is less than or equal to maxTileWidthSb.

**tileHeightSb** is used to specify the height of each tile in units of superblocks.
It is a requirement of bitstream conformance that tileWidthSb * tileHeightSb is less than or equal to maxTileAreaSb.

If uniform_tile_spacing_flag is equal to 0, it is a requirement of bitstream conformance that
startSb is equal to sbCols when the loop writing MiColStarts exits.

If uniform_tile_spacing_flag is equal to 0, it is a requirement of bitstream conformance that
startSb is equal to sbRows when the loop writing MiRowStarts exits.

**Note:** The requirements on startSb ensure that the sizes of each tile add up to the full size of the frame when measured in superblocks.
{:.alert .alert-info }

**MiColStarts** is an array specifying the start column (in units of 4x4 luma samples)
for each tile across the image.

**MiRowStarts** is an array specifying the start row (in units of 4x4 luma samples)
for each tile down the image.

**width_in_sbs_minus_1** specifies the width of a tile minus 1 in units of superblocks.

**height_in_sbs_minus_1** specifies the height of a tile minus 1 in units of superblocks.

**maxTileHeightSb** specifies the maximum height (in units of superblocks) that can be used for a tile (to avoid making tiles with too much area).

**context_update_tile_id** specifies which tile to use for the CDF update.
It is a requirement of bitstream conformance that context_update_tile_id is less than TileCols * TileRows.

**tile_size_bytes_minus_1** is used to compute TileSizeBytes.

**TileSizeBytes** specifies the number of bytes needed to code each tile size.


### Quantizer index delta parameters semantics ### {#quantizer_index_delta_parameters_semantics}

**delta_q_present** specifies whether quantizer index delta values are present.

**delta_q_res** specifies the left shift which should be applied to decoded
quantizer index delta values.


### Loop filter delta parameters semantics ### {#loop_filter_delta_parameters_semantics}

**delta_lf_present** specifies whether loop filter delta values are present.

**delta_lf_res** specifies the left shift which should be applied to decoded
loop filter delta values.

**delta_lf_multi** equal to 1 specifies that separate loop filter deltas are sent
for horizontal luma edges, vertical luma edges, the U edges, and the V edges.
delta_lf_multi equal to 0 specifies that the same loop filter delta is used for
all edges.

### Global motion params semantics ### {#global_motion_params_semantics}

**is_global** specifies whether global motion parameters are present for a
particular reference frame.

**is_rot_zoom** specifies whether a particular reference frame uses rotation and
zoom global motion.

**is_translation** specifies whether a particular reference frame uses
translation global motion.


### Global param semantics ### {#global_param_semantics}

**absBits** is used to compute the range of values that can be used for
gm_params[ref][idx]. The values allowed are in the range -(1 \<\< absBits) to
(1 \<\< absBits).

**precBits** specifies the number of fractional bits used for representing
gm_params[ref][idx]. All global motion parameters are stored in the model
with WARPEDMODEL_PREC_BITS fractional bits, but the parameters are encoded with
less precision.


### Decode subexp semantics ### {#decode_subexp_semantics}

**subexp_final_bits** provide the final bits that are read once the appropriate range has been determined.

**subexp_more_bits** equal to 0 specifies that the parameter is in the range mk
to mk+a-1.  subexp_more_bits equal to 1 specifies that the parameter is greater
than mk+a-1.

**subexp_bits** specifies the value of the parameter minus mk.

### Film grain params semantics ### {#film_grain_params_semantics}

**apply_grain** equal to 1 specifies that film grain should be added to this frame.
apply_grain equal to 0 specifies that film grain should not be added.

**reset_grain_params()** is a function call that indicates that all the syntax elements read in film_grain_params should be set equal to 0.

**grain_seed** specifies the starting value for the pseudo-random numbers used during film grain synthesis.

**update_grain** equal to 1 means that a new set of parameters should be sent.
update_grain equal to 0 means that the previous set of parameters should be used.

**film_grain_params_ref_idx** indicates which reference frame contains the film grain parameters to be used for this frame.

It is a requirement of bitstream conformance that film_grain_params_ref_idx is equal to ref_frame_idx[ j ]
for some value of j in the range 0 to REFS_PER_FRAME - 1.

**Note:** This requirement means that film grain can only be predicted from the frames that the current frame
is using as reference frames.
{:.alert .alert-info }

**load_grain_params(idx)** is a function call that indicates that all the syntax elements
read in film_grain_params should be set equal to the values stored in an area of memory indexed by idx.

**tempGrainSeed** is a temporary variable that is used to avoid losing the value of grain_seed when load_grain_params is called.
When update_grain is equal to 0, a previous set of parameters should be used for everything except grain_seed.

**num_y_points** specifies the number of points for the piece-wise linear
scaling function of the luma component.

It is a requirement of bitstream conformance that num_y_points is less than or equal to 14.

**point_y_value[ i ]**  represents the x (luma value) coordinate for the i-th point of the piecewise
linear scaling function for luma component. The values are signaled on the scale of
0..255. (In case of 10 bit video, these values correspond to luma values divided by 4.
In case of 12 bit video, these values correspond to luma values divided by 16.)

If i is greater than 0, it is a requirement of bitstream conformance that point_y_value[ i ] is greater than point_y_value[ i - 1 ]
(this ensures the x coordinates are specified in increasing order).

**point_y_scaling[ i ]** represents the scaling (output) value for the i-th point of the piecewise
linear scaling function for luma component.

**chroma_scaling_from_luma** specifies that the chroma scaling is inferred from the luma scaling.

**num_cb_points** specifies the number of points for the piece-wise linear
scaling function of the cb component.

It is a requirement of bitstream conformance that num_cb_points is less than or equal to 10.

**Note:** When chroma_scaling_from_luma is equal to 1, it is still allowed for num_y_points to take values up to 14.
This means that the chroma scaling also needs to support up to 14 points.
{:.alert .alert-info }

**point_cb_value[ i ]**  represents the x coordinate for the i-th point of the piece-wise linear
scaling function for cb component. The values are signaled on the scale of 0..255.

If i is greater than 0, it is a requirement of bitstream conformance that point_cb_value[ i ] is greater than point_cb_value[ i - 1 ].

**point_cb_scaling[ i ]**  represents the scaling (output) value for the i-th point of the piecewise
linear scaling function for cb component.

**num_cr_points** specifies  represents the number of points for the piece-wise linear
scaling function of the cr component.

It is a requirement of bitstream conformance that num_cr_points is less than or equal to 10.

If subsampling_x is equal to 1 and subsampling_y is equal to 1 and num_cb_points is equal to 0,
it is a requirement of bitstream conformance that num_cr_points is equal to 0.

If subsampling_x is equal to 1 and subsampling_y is equal to 1 and num_cb_points is not equal to 0,
it is a requirement of bitstream conformance that num_cr_points is not equal to 0.

**Note:** These requirements ensure that for 4:2:0 chroma subsampling, film grain noise will be applied to both chroma components, or to neither.
There is no restriction for 4:2:2 or 4:4:4 chroma subsampling.
{:.alert .alert-info }

**point_cr_value[ i ]**  represents the x coordinate for the i-th point of the piece-wise linear
scaling function for cr component. The values are signaled on the scale of 0..255.

If i is greater than 0, it is a requirement of bitstream conformance that point_cr_value[ i ] is greater than point_cr_value[ i - 1 ].

**point_cr_scaling[ i ]** represents the scaling (output) value for the i-th point of the piecewise
linear scaling function for cr component.

**grain_scaling_minus_8** represents the shift – 8 applied to the values of the chroma
component. The grain_scaling_minus_8 can take values of 0..3 and determines the
range and quantization step of the standard deviation of film grain.

**ar_coeff_lag** specifies the number of auto-regressive coefficients for
luma and chroma.

**ar_coeffs_y_plus_128[ i ]** specifies auto-regressive coefficients used for the Y plane.

**ar_coeffs_cb_plus_128[ i ]** specifies auto-regressive coefficients used for the U plane.

**ar_coeffs_cr_plus_128[ i ]** specifies auto-regressive coefficients used for the V plane.

**ar_coeff_shift_minus_6** specifies the range of the auto-regressive coefficients. Values of 0, 1, 2, and 3
correspond to the ranges for auto-regressive coefficients of [-2, 2), [-1, 1), [-0.5, 0.5) and [-0.25, 0.25)
respectively.

**grain_scale_shift** specifies how much the Gaussian random numbers should be scaled down during
the grain synthesis process.

**cb_mult** represents a multiplier for the cb component used in derivation of the input
index to the cb component scaling function.

**cb_luma_mult** represents a multiplier for the average luma component used in
derivation of the input index to the cb component scaling function.

**cb_offset** represents an offset used in derivation of the input index to the cb component
scaling function.

**cr_mult** represents a multiplier for the cr component used in derivation of the input index
to the cr component scaling function.

**cr_luma_mult** represents a multiplier for the average luma component used in
derivation of the input index to the cr component scaling function.

**cr_offset** represents an offset used in derivation of the input index to the cr component
scaling function.

**overlap_flag** equal to 1 indicates that the overlap between film grain blocks shall be
applied. overlap_flag equal to 0 indicates that the overlap between film grain blocks shall
not be applied.

**clip_to_restricted_range** equal to 1 indicates that clipping to the restricted (studio)
range shall be applied to the sample values after adding the film grain (see the semantics for color_range for an explanation of studio swing).
clip_to_restricted_range equal to 0 indicates that clipping to the full range shall be
applied to the sample values after adding the film grain.

### TX mode semantics ### {#tx_mode_semantics}

**tx_mode_select** is used to compute TxMode.

**TxMode** specifies how the transform size is determined:

| TxMode | Name of TxMode
|:-------:|:---------------:
| 0       | ONLY_4X4
| 1       | TX_MODE_LARGEST
| 2       | TX_MODE_SELECT
{:.table .table-sm .table-bordered }


For tx_mode equal to TX_MODE_LARGEST, the inverse transform will use the largest
transform size that fits inside the block.

For tx_mode equal to ONLY_4X4, the inverse transform will use only 4x4 transforms.

For tx_mode equal to TX_MODE_SELECT, the choice of transform size is specified
explicitly for each block.

### Skip mode params semantics ### {#skip_mode_params_semantics}

**SkipModeFrame[ list ]** specifies the frames to use for compound prediction when skip_mode is equal to 1.

**skip_mode_present** equal to 1 specifies that the syntax element skip_mode will be present.
skip_mode_present equal to 0 specifies that skip_mode will not be used for this frame.

**Note:** Skip mode tries to use the closest forward and backward references (as measured by values in the RefOrderHint array).
If no backward reference is found, then the second closest forward reference is used.
If no forward reference is found, then skip mode is disabled.
(Forward prediction is when a frame is used for reference that is considered to be output before the current frame,
backward prediction is when a frame is used that has not yet been output.)
{:.alert .alert-info }


### Frame reference mode semantics ### {#frame_reference_mode_semantics}

**reference_select** equal to 1 specifies that the mode info for inter blocks
contains the syntax element comp_mode that indicates whether to use single or
compound reference prediction. reference_select equal to 0 specifies that all
inter blocks will use single prediction.

### Temporal point info semantics ### {#temporal_point_info_semantics}

**frame_presentation_time** specifies the presentation time of the frame in clock ticks
DispCT counted from the presentation time of the previous key frame random access point
or a key frame dependent recovery point for the operating point that is being decoded
if the current frame is associated with a key frame random access point, a
key frame recovery point or a frame following a delayed random access point and
preceding the associated key frame dependent recovery point. It specifies the
presentation time of the frame in clock ticks DispCT counted from the presentation time
of the most recent key frame random access point
or a key frame dependent recovery point if the current frame is not associated with a
random access point or if the current frame follows a key frame dependent recovery point.
The syntax element is signaled as a fixed length unsigned integer with a length in bits
given by frame_presentation_time_length_minus_1 + 1.
The frame_presentation_time is the remainder of a modulo 1 \<\< (frame_presentation_time_length_minus_1 + 1) counter.

## Frame OBU semantics ## {#frame_obu_semantics}

A frame OBU consists of a frame header OBU and a tile group OBU packed into a single OBU.

**Note:** The intention is to provide a more compact way of coding the common use case where
the frame header is immediately followed by tile group data.
{:.alert .alert-info }

## Tile group OBU semantics ## {#tile_group_obu_semantics}

### General tile group OBU semantics ### {#general_tile_group_obu_semantics}

**NumTiles** specifies the total number of tiles in the frame.

**tile_start_and_end_present_flag** specifies whether tg_start and tg_end are present. If
tg_start and tg_end are not present, this tile group covers the entire frame.

If obu_type is equal to OBU_FRAME,
it is a requirement of bitstream conformance that the value of tile_start_and_end_present_flag is equal to 0.

**tg_start** specifies the zero-based index of the first tile in the current
tile group.

It is a requirement of bitstream conformance that the value of tg_start is equal to the value of TileNum at the point that
tile_group_obu is invoked.

**tg_end** specifies the zero-based index of the last tile in the current
tile group.

It is a requirement of bitstream conformance that the value of tg_end is
greater than or equal to tg_start.

It is a requirement of bitstream conformance that the value of tg_end for
the last tile group in each frame is equal to NumTiles - 1.

**Note:** These requirements ensure that conceptually all tile groups are present and
received in order for the purposes of specifying the decode process.
{:.alert .alert-info }

**frame_end_update_cdf** is a function call that indicates that the frame CDF
arrays are set equal to the  saved CDFs. This process is described in
[section 7.7][].

**tile_size_minus_1** is used to compute tileSize.

**tileSize** specifies the size in bytes of the next coded tile.

**Note:** This size includes any padding bytes if added by the exit process for the
Symbol decoder. The size does not include the bytes used for tile_size_minus_1 or syntax elements sent before tile_size_minus_1.
For the last tile in the tile group, tileSize is computed instead of being read and includes the OBU trailing bits.
{:.alert .alert-info }

**decode_frame_wrapup** is a function call that indicates that the decode frame wrapup process
specified in [section 7.4][] should be invoked.

### Decode tile semantics ### {#decode_tile_semantics}

**clear_left_context** is a function call that indicates that some arrays used
to determine the probabilities are zeroed. When this function is invoked the
arrays LeftLevelContext, LeftDcContext, and LeftSegPredContext are set
equal to 0.

**Note:** LeftLevelContext[ plane ][ i ], LeftDcContext[ plane ][ i ], and
LeftSegPredContext[ i ] need to be set to 0 for i = 0..MiRows-1, for plane = 0..2.
{:.alert .alert-info }

**clear_above_context** is a function call that indicates that some arrays used
to determine the probabilities are zeroed. When this function is invoked the
arrays AboveLevelContext, AboveDcContext, and AboveSegPredContext are set equal to 0.

**Note:** AboveLevelContext[ plane ][ i ], AboveDcContext[ plane ][ i ], and
AboveSegPredContext[ i ] need to be set to 0 for i = 0..MiCols-1, for plane = 0..2.
{:.alert .alert-info }

**ReadDeltas** specifies whether the current block may read delta values
for the quantizer index and loop filter.
If the entire superblock is skipped the delta values are not read, otherwise
delta values for the quantizer index and loop filter are
read on the first block of a superblock.
If delta_q_present is equal to 0, no delta values are read for the quantizer index.
If delta_lf_present is equal to 0, no delta values are read for the loop filter.


### Clear block decoded flags semantics ### {#clear_block_decoded_flags_semantics}

**BlockDecoded** is an array which stores one boolean value per 4x4 sample block
per plane in the current superblock, plus a border of one 4x4 sample block on
all sides of the superblock. Except for the borders, a value of 1 in
BlockDecoded indicates that the corresponding 4x4 sample block has been decoded.
The borders are used when computing above-right and below-left availability
along the top and left edges of the superblock.


### Decode partition semantics ### {#decode_partition_semantics}

**partition** specifies how a block is partitioned:


| partition | Name of partition
|:---------:|:-----------------:
| 0         | PARTITION_NONE
| 1         | PARTITION_HORZ
| 2         | PARTITION_VERT
| 3         | PARTITION_SPLIT
| 4         | PARTITION_HORZ_A
| 5         | PARTITION_HORZ_B
| 6         | PARTITION_VERT_A
| 7         | PARTITION_VERT_B
| 8         | PARTITION_HORZ_4
| 9         | PARTITION_VERT_4
{:.table .table-sm .table-bordered }


The variable **subSize** is computed from partition and indicates the size of
the component blocks within this block:


| subSize | Name of subSize
|:-------:|:---------------:
| 0       | BLOCK_4X4
| 1       | BLOCK_4X8
| 2       | BLOCK_8X4
| 3       | BLOCK_8X8
| 4       | BLOCK_8X16
| 5       | BLOCK_16X8
| 6       | BLOCK_16X16
| 7       | BLOCK_16X32
| 8       | BLOCK_32X16
| 9       | BLOCK_32X32
| 10      | BLOCK_32X64
| 11      | BLOCK_64X32
| 12      | BLOCK_64X64
| 13      | BLOCK_64X128
| 14      | BLOCK_128X64
| 15      | BLOCK_128X128
| 16      | BLOCK_4X16
| 17      | BLOCK_16X4
| 18      | BLOCK_8X32
| 19      | BLOCK_32X8
| 20      | BLOCK_16X64
| 21      | BLOCK_64X16
{:.table .table-sm .table-bordered }


The dimensions of these blocks are given in width, height order (e.g.
BLOCK_8X16 corresponds to a block that is 8 samples wide, and 16 samples high).

It is a requirement of bitstream conformance that
get_plane_residual_size( subSize, 1 ) is not equal to BLOCK_INVALID every time
subSize is computed.

**Note:** This requirement prevents the UV blocks from being too tall or too
wide (i.e. having aspect ratios outside the range 1:4 to 4:1). For example,
when 4:2:2 chroma subsampling is used a luma partition of size 8x32 is invalid,
as it implies a chroma partition of size 4x32, which results in an aspect
ratio of 1:8.
{:.alert .alert-info }

**split_or_vert** is used to compute partition for blocks when only split or
vert partitions are allowed because of overlap with the right hand edge of the
frame.

**split_or_horz** is used to compute partition for blocks when only split or
horz partitions are allowed because of overlap with the bottom edge of the frame.


### Decode block semantics ### {#decode_block_semantics}

**MiRow** is a variable holding the vertical location of the block in units of
4x4 luma samples.

**MiCol** is a variable holding the horizontal location of the block in units of
4x4 luma samples.

**MiSize** is a variable holding the size of the block with values having the
same interpretation for the variable subSize.

**HasChroma** is a variable that specifies whether chroma information is coded
for this block.

Variable **AvailU** is equal to 0 if the information from the block above cannot
be used on the luma plane; AvailU is equal to 1 if the information from the block
above can be used on the luma plane.

Variable **AvailL** is equal to 0 if the information from the block to the left
can not be used on the luma plane; AvailL is equal to 1 if the information from
the block to the left can be used on the luma plane.

Variables **AvailUChroma** and **AvailLChroma** have the same significance
as AvailU and AvailL, but on the chroma planes.

### Intra frame mode info semantics ### {#intra_frame_mode_info_semantics}

This syntax is used when coding an intra block within an intra frame.

**use_intrabc** equal to 1 specifies that intra block copy should be used for this block.
use_intrabc equal to 0 specifies that intra block copy should not be used.

**intra_frame_y_mode** specifies the direction of intra prediction filtering:

| intra_frame_y_mode  | Name of intra_frame_y_mode
|:-------------------:|:--------------------------:
| 0                   | DC_PRED
| 1                   | V_PRED
| 2                   | H_PRED
| 3                   | D45_PRED
| 4                   | D135_PRED
| 5                   | D113_PRED
| 6                   | D157_PRED
| 7                   | D203_PRED
| 8                   | D67_PRED
| 9                   | SMOOTH_PRED
| 10                  | SMOOTH_V_PRED
| 11                  | SMOOTH_H_PRED
| 12                  | PAETH_PRED
{:.table .table-sm .table-bordered }


**uv_mode** specifies the chrominance intra prediction mode using
values with the same interpretation as in the semantics for intra_frame_y_mode,
with an additional mode UV_CFL_PRED.

| uv_mode  | Name of uv_mode
|:-------------------:|:--------------------------:
| 0                   | DC_PRED
| 1                   | V_PRED
| 2                   | H_PRED
| 3                   | D45_PRED
| 4                   | D135_PRED
| 5                   | D113_PRED
| 6                   | D157_PRED
| 7                   | D203_PRED
| 8                   | D67_PRED
| 9                   | SMOOTH_PRED
| 10                  | SMOOTH_V_PRED
| 11                  | SMOOTH_H_PRED
| 12                  | PAETH_PRED
| 13                  | UV_CFL_PRED
{:.table .table-sm .table-bordered }

**Note:** Due to the way the uv_mode syntax element is read, uv_mode can only be
read as UV_CFL_PRED when Max( Block_Width[ MiSize ], Block_Height[
MiSize ] ) <\= 32.
{:.alert .alert-info }

### Intra segment ID semantics ### {#intra_segment_id_semantics}

**Lossless** is a variable which, if equal to 1, indicates that the block
is coded using a special 4x4 transform designed for encoding frames that
are bit-identical with the original frames.

### Read segment ID semantics ### {#read_segment_id_semantics}

**segment_id** specifies which segment is associated with the current intra
block being decoded.  It is first read from the stream, and then postprocessed
based on the predicted segment id.

It is a requirement of bitstream conformance that the postprocessed value
of segment_id (i.e. the value returned by neg_deinterleave) is in the range
0 to LastActiveSegId (inclusive of endpoints).


### Inter segment ID semantics ### {#inter_segment_id_semantics}

**seg_id_predicted** equal to 1 specifies that the segment_id is taken from
the segmentation map. seg_id_predicted equal to 0 specifies that the syntax
element segment_id is parsed.

**Note:** It is allowed for seg_id_predicted to be equal to 0 even if the value
coded for the segment_id is equal to predictedSegmentId.
{:.alert .alert-info }

### Skip mode semantics ### {#skip_mode_semantics}

**skip_mode** equal to 1 indicates that this block will use some default settings (that correspond to compound prediction) and so most of the mode info is skipped.
skip_mode equal to 0 indicates that the mode info is not skipped.


### Skip semantics ### {#skip_semantics}

**skip** equal to 0 indicates that there may be some transform coefficients to
read for this block; skip equal to 1 indicates that there are no transform
coefficients.


### Quantizer index delta semantics ### {#quantizer_index_delta_semantics}

**delta_q_abs** specifies the absolute value of the quantizer index delta value
being decoded. If delta_q_abs is equal to DELTA_Q_SMALL, the value is encoded
using delta_q_rem_bits and delta_q_abs_bits.

**delta_q_rem_bits** and **delta_q_abs_bits** encode the absolute value of the
quantizer index delta value being decoded, where the absolute value of the
quantizer index delta value is of the form:

~~~~~ c
(1 << delta_q_rem_bits) + delta_q_abs_bits + 1
~~~~~

**delta_q_sign_bit** equal to 0 indicates that the quantizer index delta value
is positive; delta_q_sign_bit equal to 1 indicates that the quantizer index
delta value is negative.


### Loop filter delta semantics ### {#loop_filter_delta_semantics}

**delta_lf_abs** specifies the absolute value of the loop filter delta value
being decoded. If delta_lf_abs is equal to DELTA_LF_SMALL, the value is encoded
using delta_lf_rem_bits and delta_lf_abs_bits.

**delta_lf_rem_bits** and **delta_lf_abs_bits** encode the absolute value of the
loop filter delta value being decoded, where the absolute value of the loop
filter delta value is of the form:

~~~~~ c
( 1 << ( delta_lf_rem_bits + 1 ) ) + delta_lf_abs_bits + 1
~~~~~

**delta_lf_sign_bit** equal to 0 indicates that the loop filter delta value is
positive; delta_lf_sign_bit equal to 1 indicates that the loop filter delta
value is negative.


### CDEF params semantics ### {#cdef_params_semantics}

**cdef_damping_minus_3** controls the amount of damping in the deringing filter.

**cdef_bits** specifies the number of bits needed to specify which CDEF filter
to apply.

**cdef_y_pri_strength** and **cdef_uv_pri_strength** specify the strength of the
primary filter.

**cdef_y_sec_strength** and **cdef_uv_sec_strength** specify the strength of the
secondary filter.

### Loop restoration params semantics ### {#loop_restoration_params_semantics}

**lr_type** is used to compute FrameRestorationType.

**FrameRestorationType** specifies the type of restoration used for each plane as follows:

| lr_type | FrameRestorationType | Name of FrameRestorationType
|:-------:|:--------------------:|:---------------------------:
| 0       | 0                    | RESTORE_NONE
| 1       | 3                    | RESTORE_SWITCHABLE
| 2       | 1                    | RESTORE_WIENER
| 3       | 2                    | RESTORE_SGRPROJ
{:.table .table-sm .table-bordered }

**UsesLr** indicates if any plane uses loop restoration.

**lr_unit_shift** specifies if the luma restoration size should be halved.

**lr_unit_extra_shift** specifies if the luma restoration size should be halved again.

**lr_uv_shift** is only present for 4:2:0 formats and specifies if the chroma size should be half the luma size.

**LoopRestorationSize[plane]** specifies the size of loop restoration units in units of samples in the current plane.


### TX size semantics ### {#tx_size_semantics}

**tx_depth** is used to compute TxSize.  tx_depth is inverted with respect to TxSize, i.e. it specifies
how much smaller the transform size should be made than the largest possible transform size for the block.

**TxSize** specifies the transform size to be used for this block:

| TxSize | Name of TxSize
|:------:|:---------------:
| 0      | TX_4X4
| 1      | TX_8X8
| 2      | TX_16X16
| 3      | TX_32X32
| 4      | TX_64X64
| 5      | TX_4X8
| 6      | TX_8X4
| 7      | TX_8X16
| 8      | TX_16X8
| 9      | TX_16X32
| 10     | TX_32X16
| 11     | TX_32X64
| 12     | TX_64X32
| 13     | TX_4X16
| 14     | TX_16X4
| 15     | TX_8X32
| 16     | TX_32X8
| 17     | TX_16X64
| 18     | TX_64X16
{:.table .table-sm .table-bordered }


**Note:** TxSize is determined for skipped intra blocks because TxSize controls
the granularity of the intra prediction.
{:.alert .alert-info }


### Block TX size semantics ### {#block_tx_size_semantics}

**InterTxSizes** is an array that holds the transform sizes within inter frames.

**Note:** TxSizes and InterTxSizes contain different values.
All the values in TxSizes across a residual block will share the same value, while InterTxSizes can represent several different transform sizes within a residual block.
{:.alert .alert-info }

### Var TX size semantics ### {#var_tx_size_semantics}

**txfm_split** equal to 1 specifies that the block should be split into smaller transform sizes.
txfm_split equal to 0 specifies that the block should not be split any more.

### Transform type semantics ### {#transform_type_semantics}

**set** specifies the transform set.

| is_inter   | set | Name of transform set
|:----------:|:---:|:---------------------:|
| Don't care | 0   | TX_SET_DCTONLY        |
|          0 | 1   | TX_SET_INTRA_1        |
|          0 | 2   | TX_SET_INTRA_2        |
|          1 | 1   | TX_SET_INTER_1        |
|          1 | 2   | TX_SET_INTER_2        |
|          1 | 3   | TX_SET_INTER_3        |
{:.table .table-sm .table-bordered }

The transform sets determine what subset of transform types can be used, according to the following table.

| Transform type    | TX_SET_<br/>DCTONLY | TX_SET_<br/>INTRA_1 | TX_SET_<br/>INTRA_2 | TX_SET_<br/>INTER_1 | TX_SET_<br/>INTER_2 | TX_SET_<br/>INTER_3 |
|:-----------------:|:-------------------:|:-------------------:|:-------------------:|:-------------------:|:-------------------:|:-------------------:|
| DCT_DCT           | X                   | X                   | X                   | X                   | X                   | X                   |
| ADST_DCT          |                     | X                   | X                   | X                   | X                   |                     |
| DCT_ADST          |                     | X                   | X                   | X                   | X                   |                     |
| ADST_ADST         |                     | X                   | X                   | X                   | X                   |                     |
| FLIPADST_DCT      |                     |                     |                     | X                   | X                   |                     |
| DCT_FLIPADST      |                     |                     |                     | X                   | X                   |                     |
| FLIPADST_FLIPADST |                     |                     |                     | X                   | X                   |                     |
| ADST_FLIPADST     |                     |                     |                     | X                   | X                   |                     |
| FLIPADST_ADST     |                     |                     |                     | X                   | X                   |                     |
| IDTX              |                     | X                   | X                   | X                   | X                   | X                   |
| V_DCT             |                     | X                   |                     | X                   | X                   |                     |
| H_DCT             |                     | X                   |                     | X                   | X                   |                     |
| V_ADST            |                     |                     |                     | X                   |                     |                     |
| H_ADST            |                     |                     |                     | X                   |                     |                     |
| V_FLIPADST        |                     |                     |                     | X                   |                     |                     |
| H_FLIPADST        |                     |                     |                     | X                   |                     |                     |
{:.table .table-sm .table-bordered }


**inter_tx_type** specifies the transform type for inter blocks.

**intra_tx_type** specifies the transform type for intra blocks.


### Is inter semantics ### {#is_inter_semantics}

**is_inter** equal to 0 specifies that the block is an intra block; is_inter
equal to 1 specifies that the block is an inter block.


### Intra block mode info semantics ### {#intra_block_mode_info_semantics}

This syntax is used when coding an intra block within an inter frame.

**y_mode** specifies the direction of luminance intra
prediction using values with the same interpretation as for intra_frame_y_mode.

**uv_mode** specifies the chrominance intra prediction mode using
values with the same interpretation as in the semantics for intra_frame_y_mode,
with an additional mode UV_CFL_PRED.

**Note:** Due to the way the uv_mode syntax element is read, uv_mode can only be
read as UV_CFL_PRED when Max( Block_Width[ MiSize ], Block_Height[
MiSize ] ) <\= 32.
{:.alert .alert-info }


### Inter block mode info semantics ### {#inter_block_mode_info_semantics}

This syntax is used when coding an inter block.

**compound_mode** specifies how the motion vector used by inter prediction is
obtained when using compound prediction. An offset is added to compound_mode to
compute YMode as follows:

| YMode | Name of YMode
|:------:|:-------------
| 14     | NEARESTMV
| 15     | NEARMV
| 16     | GLOBALMV
| 17     | NEWMV
| 18     | NEAREST_NEARESTMV
| 19     | NEAR_NEARMV
| 20     | NEAREST_NEWMV
| 21     | NEW_NEARESTMV
| 22     | NEAR_NEWMV
| 23     | NEW_NEARMV
| 24     | GLOBAL_GLOBALMV
| 25     | NEW_NEWMV
{:.table .table-sm .table-bordered }

**Note:** The intra modes take values 0..13 so these YMode values start at 14.
{:.alert .alert-info }

**new_mv** equal to 0 means that a motion vector difference should be read.

**zero_mv** equal to 0 means that the motion vector should be set equal to
default motion for the frame.

**ref_mv** equal to 0 means that the most likely motion vector should be used
(called NEAREST), ref_mv equal to 1 means that the second most likely motion
vector should be used (called NEAR).

**interp_filter** specifies the type of filter used in inter prediction.
Values 0..3 are allowed with the same interpretation as for
interpolation_filter. One filter type is specified for the vertical filter
direction and one for the horizontal filter direction.

**Note:** The syntax element interpolation_filter from the uncompressed header
can specify the type of filter to be used for the whole frame. If it is set to
SWITCHABLE then the interp_filter syntax element is read from the bitstream
for every inter block.
{:.alert .alert-info }

**RefMvIdx** specifies which candidate in the RefStackMv should be used.

**drl_mode** is a bit sent for candidates in the motion vector stack to indicate
if they should be used. drl_mode equal to 0 means to use the current value of
idx.  drl_mode equal to 1 says to continue searching. DRL stands for "Dynamic
Reference List".

### Filter intra mode info semantics ### {#filter_intra_mode_info_semantics}

**use_filter_intra** is a bit specifying whether or not intra filtering can be used.

**filter_intra_mode** specifies the type of intra filtering, and can take on any of the
following values:

| filter_intra_mode | Name of filter_intra_mode
|:-----------------:|:--------------------------:
| 0                 | FILTER_DC_PRED
| 1                 | FILTER_V_PRED
| 2                 | FILTER_H_PRED
| 3                 | FILTER_D157_PRED
| 4                 | FILTER_PAETH_PRED
{:.table .table-sm .table-bordered }


### Ref frames semantics ### {#ref_frames_semantics}

**comp_mode** specifies whether single or compound prediction is used:

| comp_mode       | Name of comp_mode
|:---------------:|:----------------------:
| 0               | SINGLE_REFERENCE
| 1               | COMPOUND_REFERENCE
{:.table .table-sm .table-bordered }

**SINGLE_REFERENCE** indicates that the inter block uses only a single
reference frame to generate motion compensated prediction.

**COMPOUND_REFERENCE** indicates that the inter block uses compound mode.

There are two reference frame groups:

  * Group 1: LAST_FRAME, LAST2_FRAME, LAST3_FRAME, and GOLDEN_FRAME.

  * Group 2: BWDREF_FRAME, ALTREF2_FRAME, and ALTREF_FRAME.

**Note:** Encoders are free to assign these references to any of the reference frames
(via the ref_frame_idx array).
For example, there is no requirement of bitstream conformance that LAST_FRAME
should indicate a frame that appears before the current frame in output order.
Similarly, encoders can assign multiple references to the same reference frame.
{:.alert .alert-info }

**comp_ref_type** is used for compound prediction to specify whether both
reference frames come from the same group or not:

| comp_ref_type | Name of comp_ref_type| Description
|:-------------:|:---------------------: -----------
| 0             | UNIDIR_COMP_REFERENCE| Both reference frames from the same group
| 1             | BIDIR_COMP_REFERENCE | One from Group 1 and one from Group 2
{:.table .table-sm .table-bordered }

**uni_comp_ref**, **uni_comp_ref_p1**, and **uni_comp_ref_p2** specify which
reference frames are in use when both come from the same group.

**comp_ref**, **comp_ref_p1**, and **comp_ref_p2** specify the first reference
frame when the two reference frames come from different groups.

**comp_bwdref** and **comp_bwdref_p1** specify the second reference frame when
the two reference frames come from different groups.

**single_ref_p1**, **single_ref_p2**, **single_ref_p3**, **single_ref_p4**,
**single_ref_p5**, and **single_ref_p6** specify the reference frame when only a
single reference frame is in use.

**RefFrame[ 0 ]** specifies which frame is used to compute the predicted
samples for this block:


| RefFrame[ 0 ] | Name of ref_frame
|:-------------:|:-----------------:
| 0             | INTRA_FRAME
| 1             | LAST_FRAME
| 2             | LAST2_FRAME
| 3             | LAST3_FRAME
| 4             | GOLDEN_FRAME
| 5             | BWDREF_FRAME
| 6             | ALTREF2_FRAME
| 7             | ALTREF_FRAME
{:.table .table-sm .table-bordered }


**RefFrame[ 1 ]** specifies which additional frame is used in compound
prediction:


| RefFrame[ 1 ] | Name of ref_frame
|:-------------:|:-----------------:
| -1            | NONE (this block uses single prediction)
| 0             | INTRA_FRAME (this block uses interintra prediction)
| 1             | LAST_FRAME
| 2             | LAST2_FRAME
| 3             | LAST3_FRAME
| 4             | GOLDEN_FRAME
| 5             | BWDREF_FRAME
| 6             | ALTREF2_FRAME
| 7             | ALTREF_FRAME
{:.table .table-sm .table-bordered }

**Note:** Not all combinations of RefFrame[0] and RefFrame[1] can be coded.
{:.alert .alert-info }

### Assign mv semantics ### {#assign_mv_semantics}

It is a requirement of bitstream conformance that whenever assign_mv returns,
the function is_mv_valid(isCompound) would return 1, where is_mv_valid is defined as:

~~~~~ c
is_mv_valid( isCompound ) {
    for ( i = 0; i < 1 + isCompound; i++ ) {
        for ( comp = 0; comp < 2; comp++ ) {
            if ( Abs( Mv[ i ][ comp ] ) >= ( 1 << 14 ) )
                return 0
        }
    }
    if ( !use_intrabc ) {
        return 1
    }
    bw = Block_Width[ MiSize ]
    bh = Block_Height[ MiSize ]
    if ( (Mv[ 0 ][ 0 ] & 7) || (Mv[ 0 ][ 1 ] & 7) ) {
        return 0
    }
    deltaRow = Mv[ 0 ][ 0 ] >> 3
    deltaCol = Mv[ 0 ][ 1 ] >> 3
    srcTopEdge = MiRow * MI_SIZE + deltaRow
    srcLeftEdge = MiCol * MI_SIZE + deltaCol
    srcBottomEdge = srcTopEdge + bh
    srcRightEdge = srcLeftEdge + bw
    if ( HasChroma ) {
        if ( bw < 8 && subsampling_x )
            srcLeftEdge -= 4
        if ( bh < 8 && subsampling_y )
            srcTopEdge -= 4
    }
    if ( srcTopEdge < MiRowStart * MI_SIZE ||
         srcLeftEdge < MiColStart * MI_SIZE ||
         srcBottomEdge > MiRowEnd * MI_SIZE ||
         srcRightEdge > MiColEnd * MI_SIZE ) {
        return 0
    }
    sbSize = use_128x128_superblock ? BLOCK_128X128 : BLOCK_64X64
    sbH = Block_Height[ sbSize ]
    activeSbRow = (MiRow * MI_SIZE) / sbH
    activeSb64Col = (MiCol * MI_SIZE) >> 6
    srcSbRow = (srcBottomEdge - 1) / sbH
    srcSb64Col = (srcRightEdge - 1) >> 6
    totalSb64PerRow = ((MiColEnd - MiColStart - 1) >> 4) + 1
    activeSb64 = activeSbRow * totalSb64PerRow + activeSb64Col
    srcSb64 = srcSbRow * totalSb64PerRow + srcSb64Col
    if ( srcSb64 >= activeSb64 - INTRABC_DELAY_SB64) {
        return 0
    }
    gradient = 1 + INTRABC_DELAY_SB64 + use_128x128_superblock
    wfOffset = gradient * (activeSbRow - srcSbRow)
    if ( srcSbRow > activeSbRow ||
         srcSb64Col >= activeSb64Col - INTRABC_DELAY_SB64 + wfOffset ) {
        return 0
    }
    return 1
}
~~~~~

**Note:** The purpose of this function is to limit the maximum size of motion vectors
and also, if use_intrabc is equal to 1, to additionally constrain the motion vector
in order that the data is fetched from parts of the tile that have already been decoded,
and that are not too close to the current block (in order to make a pipelined decoder implementation feasible).
{:.alert .alert-info }

### Read motion mode semantics ### {#read_motion_mode_semantics}

**use_obmc** equal to 1 means that OBMC should be used.  use_obmc equal to 0
means that simple translation should be used.

**motion_mode** specifies the type of motion compensation to perform:

| motion_mode   | Name of motion_mode
|:-------------:|:-----------------:
| 0             | SIMPLE
| 1             | OBMC
| 2             | LOCALWARP
{:.table }

**Note:** A motion_mode equal to SIMPLE is used for blocks requiring global motion.
{:.alert .alert-info }

### Read inter intra semantics ### {#read_inter_intra_semantics}

**interintra** equal to 1 specifies that an inter prediction should be blended
with an intra prediction.

**interintra_mode** specifies the type of intra prediction to be used:

| interintra_mode   | Name of interintra_mode
|:-----------------:|:-----------------:
| 0                 | II_DC_PRED
| 1                 | II_V_PRED
| 2                 | II_H_PRED
| 3                 | II_SMOOTH_PRED
{:.table .table-sm .table-bordered }

**wedge_interintra** equal to 1 specifies that wedge blending should be used.
wedge_interintra equal to 0 specifies that intra blending should be used.

**wedge_index** is used to derive the direction and offset of the wedge mask used during blending.


### Read compound type semantics ### {#read_compound_type_semantics}

**comp_group_idx** equal to 0 indicates that the compound_idx syntax element should be read.
comp_group_idx equal to 1 indicates that the compound_idx syntax element is not present.

**compound_idx** equal to 0 indicates that a distance based weighted scheme should be used for blending.
compound_idx equal to 1 indicates that the averaging scheme should be used for blending.

**compound_type** specifies how the two predictions should be blended together:

| compound_type     | Name of compound_type
|:-----------------:|:-----------------:
| 0                 | COMPOUND_WEDGE
| 1                 | COMPOUND_DIFFWTD
| 2                 | COMPOUND_AVERAGE
| 3                 | COMPOUND_INTRA
| 4                 | COMPOUND_DISTANCE
{:.table .table-sm .table-bordered }

**Note:** COMPOUND_AVERAGE, COMPOUND_INTRA, and COMPOUND_DISTANCE cannot be directly signaled with the compound_type
syntax element but are inferred from other syntax elements.
{:.alert .alert-info }

**wedge_index** is used to derive the direction and offset of the wedge mask used during blending.

**wedge_sign** specifies the sign of the wedge blend.

**mask_type** specifies the type of mask to be used during blending:

| mask_type         | Name of mask_type
|:-----------------:|:-----------------:
| 0                 | UNIFORM_45
| 1                 | UNIFORM_45_INV
{:.table .table-sm .table-bordered }


### MV semantics ### {#mv_semantics}

**MvCtx** is used to determine which CDFs to use for the motion vector syntax
elements.

**mv_joint** specifies which components of the motion vector difference are
non-zero:


| mv_joint  | Name of mv_joint  | Changes row | Changes col
|:---------:|:-----------------:|:-----------:|:-----------:
| 0         | MV_JOINT_ZERO     | No          | No
| 1         | MV_JOINT_HNZVZ    | No          | Yes
| 2         | MV_JOINT_HZVNZ    | Yes         | No
| 3         | MV_JOINT_HNZVNZ   | Yes         | Yes
{:.table .table-sm .table-bordered }


The motion vector difference is added to the PredMv to compute the final
motion vector in Mv.

### MV component semantics ### {#mv_component_semantics}

**mv_sign** equal to 0 means that the motion vector difference is positive;
mv_sign equal to 1 means that the motion vector difference is negative.

**mv_class** specifies the class of the motion vector difference. A higher
class means that the motion vector difference represents a larger update:


| mv_class  | Name of mv_class
|:---------:|:----------------:
| 0         | MV_CLASS_0
| 1         | MV_CLASS_1
| 2         | MV_CLASS_2
| 3         | MV_CLASS_3
| 4         | MV_CLASS_4
| 5         | MV_CLASS_5
| 6         | MV_CLASS_6
| 7         | MV_CLASS_7
| 8         | MV_CLASS_8
| 9         | MV_CLASS_9
| 10        | MV_CLASS_10
{:.table .table-sm .table-bordered }


**mv_class0_bit** specifies the integer part of the motion vector difference.
This is only present for class 0 motion vector differences.

**mv_class0_fr** specifies the first 2 fractional bits of the motion vector
difference. This is only present for class 0 motion vector
differences.

**mv_class0_hp** specifies the third fraction bit of the motion vector
difference. This is only present for class 0 motion vector
differences.

**mv_bit** specifies bit i of the integer part of the motion vector difference.

**mv_fr** specifies the first 2 fractional bits of the motion vector
difference.

**mv_hp** specifies the third fractional bit of the motion vector difference.

### Compute prediction semantics ### {#compute_prediction_semantics}

The prediction for inter and interintra blocks is triggered within compute_prediction.
However, intra prediction is done at the transform block granularity so predict_intra is also called from transform_block.

**predW** and **predH** are variables containing the smallest size that can be used for
inter prediction.
(This size may be increased for chroma blocks if not all blocks use inter prediction.)

**predict_inter** is a function call that indicates the conceptual point where
inter prediction happens. When this function is called, the inter prediction
process specified in [section 7.11.3][] is invoked.

**predict_intra** is a function call that indicates the conceptual point where
intra prediction happens. When this function is called, the intra prediction
process specified in [section 7.11.2][] is invoked.

**Note:** The predict_inter and predict_intra functions do not affect the syntax
decode process.
{:.alert .alert-info }

**someUseIntra** is a variable that indicates if some of the blocks corresponding to
this residual require intra prediction.

**Note:** The chroma residual block
size is always at least 4 in width and height.  This means that no transform width
or height
smaller than 4 is required.  As such, a chroma residual may actually cover
several luma blocks.
If any of these blocks are intra, a single prediction is performed
for the entire chroma residual block based on the mode info of the bottom right luma block.
However, if all the constituent blocks are
inter blocks, a special case is triggered and inter prediction is done using
the smaller chroma block size that corresponds to each of the luma blocks.
{:.alert .alert-info }

### Residual semantics ### {#residual_semantics}

The residual consists of a number of transform blocks.

If the block is wider or higher than 64 luma samples, then the residual is split into 64 by 64 chunks.

Within each chunk, the transform blocks are either sent in raster order (if use_inter is equal to 0 or LossLess is equal to 1),
or within a recursive transform tree.

### Transform block semantics ### {#transform_block_semantics}

**reconstruct** is a function call that indicates the conceptual point where
inverse transform and reconstruction happens. When this function is called,
the reconstruction process specified in [section 7.12.3][] is invoked.

**predict_palette** is a function call that indicates the conceptual point where
palette prediction happens. When this function is called, the palette prediction
process specified in [section 7.11.4][] is invoked.

**predict_chroma_from_luma** is a function call that indicates the conceptual
point where predicting chroma from luma happens. When this function is called,
the predict chroma from luma process specified in [section 7.11.5][] is invoked.

**MaxLumaW** and **MaxLumaH** are needed for chroma from luma prediction and
store the extent of luma samples that can be used for prediction.

**LoopfilterTxSizes** is an array that stores the transform size for each plane and
position for use in loop filtering.
LoopfilterTxSizes[ plane ][ row ][ col ] stores the transform size where row and col are in units of 4x4 samples.

**Note:** The transform size is always equal for planes 1 and 2.
{:.alert .alert-info }

### Coefficients semantics ### {#coefficients_semantics}

**TxTypes** is an array which stores at a 4x4 luma sample granularity the transform type to be used.

**Note:** The transform type is only read for luma transform blocks, the chroma uses
the transform type for a corresponding luma block.  Chroma blocks will only use transform
types that have been written for the current residual block.
{:.alert .alert-info }

**Quant** is an array storing the quantised coefficients for the current transform block.

**all_zero** equal to 1 specifies that all coefficients are zero.

**Note:** The transform type is only present when this is a luminance block
and all_zero is equal to 0.  If all_zero is equal to 1 for a luminance block, the transform type is set to DCT_DCT.
{:.alert .alert-info }

**eob_extra** and **eob_extra_bit** specify the position of the last non-zero coefficient by being used to compute the variable eob.

**eob_pt_16**, **eob_pt_32**, **eob_pt_64**, **eob_pt_128**, **eob_pt_256**, **eob_pt_512**, **eob_pt_1024**:
syntax elements used to compute eob.

**eob** is a variable that indicates the index of the end of block.
This index is equal to one plus the index of the last non-zero coefficient.

**coeff_base_eob** is a syntax element used to compute the base level of the last non-zero coefficient.

**Note:** The base level is set to coeff_base_eob plus 1.
Since this coefficient is known to be non-zero, only base levels of 1, 2, or 3 can be coded via coeff_base_eob.
{:.alert .alert-info }

**coeff_base** specifies the base level of a coefficient
(this syntax element is used for all coefficients except the last non-zero coefficient).

**Note:** The base level can take values of 0, 1, 2, or 3.
If the base level is less than 3, then it contains the actual level of the coefficient.
Otherwise, the syntax element coeff_br is used to optionally increase the level.
{:.alert .alert-info }

**dc_sign** specifies the sign of the DC coefficient.

**sign_bit** specifies the sign of a non-zero AC coefficient.

**coeff_br** specifies an increment to the coefficient.

**Note:** Each quantized coefficient can use coeff_br to provide up to 4 increments.
If an increment less than 3 is coded, it signifies that this was the final increment.
{:.alert .alert-info }

**golomb_length_bit** is used to compute the number of extra bits required to code the coefficient.

If length is equal to 20, it is a requirement of bitstream conformance that golomb_length_bit is equal to 1.

**golomb_data_bit** specifies the value of one of the extra bits.

**AboveLevelContext** and **LeftLevelContext** are arrays that store at a
4 sample granularity the cumulative sum of coefficient levels.

**AboveDcContext** and **LeftDcContext** are arrays that store at a 4 sample
granularity 2 bits signaling the sign of the DC coefficient (zero being
counted as a separate sign).


### Intra angle info semantics ### {#intra_angle_info_semantics}

**angle_delta_y** specifies the offset to be applied to the intra prediction
angle specified by the prediction mode in the luma plane, biased by
MAX_ANGLE_DELTA so as to encode a positive value.

**angle_delta_uv** specifies the offset to be applied to the intra prediction
angle specified by the prediction mode in the chroma plane biased by
MAX_ANGLE_DELTA so as to encode a positive value.

**AngleDeltaY** is computed from angle_delta_y by removing the MAX_ANGLE_DELTA
offset to produce the final luma angle offset value, which may be positive or
negative.

**AngleDeltaUV** is computed from angle_delta_uv by removing the MAX_ANGLE_DELTA
offset to produce the final chroma angle offset value, which may be positive or
negative.


### Read CFL alphas semantics ### {#read_cfl_alphas_semantics}

**cfl_alpha_signs** contains the sign of the alpha values for U and V packed
together into a single syntax element with 8 possible values.  (The combination
of two zero signs is prohibited as it is redundant with DC Intra prediction.)

| cfl_alpha_signs | Name of signU | Name of signV
|:--------------:|:-------------:|:-------------:
| 0              | CFL_SIGN_ZERO | CFL_SIGN_NEG
| 1              | CFL_SIGN_ZERO | CFL_SIGN_POS
| 2              | CFL_SIGN_NEG  | CFL_SIGN_ZERO
| 3              | CFL_SIGN_NEG  | CFL_SIGN_NEG
| 4              | CFL_SIGN_NEG  | CFL_SIGN_POS
| 5              | CFL_SIGN_POS  | CFL_SIGN_ZERO
| 6              | CFL_SIGN_POS  | CFL_SIGN_NEG
| 7              | CFL_SIGN_POS  | CFL_SIGN_POS
{:.table .table-sm .table-bordered }

**signU** contains the sign of the alpha value for the U component:

| signU | Name of signU
|:-----:|:-------------:
| 0     | CFL_SIGN_ZERO
| 1     | CFL_SIGN_NEG
| 2     | CFL_SIGN_POS
{:.table .table-sm .table-bordered }

**signV** contains the sign of the alpha value for the V component with the same
interpretation as for signU.

**cfl_alpha_u** contains the absolute value of alpha minus one for the U
component.

**cfl_alpha_v** contains the absolute value of alpha minus one for the V
component.

**CflAlphaU** contains the signed value of the alpha component for the U
component.

**CflAlphaV** contains the signed value of the alpha component for the V
component.


### Palette mode info semantics ### {#palette_mode_info_semantics}

**has_palette_y** is a boolean value specifying whether a palette is encoded for
the Y plane.

**has_palette_uv** is a boolean value specifying whether a palette is encoded
for the UV plane.

**palette_size_y_minus_2** is used to compute PaletteSizeY.

**PaletteSizeY** is a variable holding the Y plane palette size.

**palette_size_uv_minus_2** is used to compute PaletteSizeUV.

**PaletteSizeUV** is a variable holding the UV plane palette size.

**use_palette_color_cache_y**, if equal to 1, indicates that for a particular palette
entry in the luma palette, the cached entry should be used.

**use_palette_color_cache_u**, if equal to 1, indicates that for a particular palette
entry in the U chroma palette, the cached entry should be used.

**palette_colors_y** is an array holding the Y plane palette colors.

**palette_colors_u** is an array holding the U plane palette colors.

**palette_colors_v** is an array holding the V plane palette colors.

**delta_encode_palette_colors_v**, if equal to 1, indicates that the V chroma palette
is encoded using delta encoding.

**palette_num_extra_bits_y** is used to calculate the number of bits used to store each
palette delta value for the luma palette.

**palette_num_extra_bits_u** is used to calculate the number of bits used to store each
palette delta value for the U chroma palette.

**palette_num_extra_bits_v** is used to calculate the number of bits used to store each
palette delta value for the V chroma palette.

**palette_delta_y** is a delta value for the luma palette.

**palette_delta_u** is a delta value for the U chroma palette.

**palette_delta_v** is a delta value for the V chroma palette.

**Note:** Luma and U delta values give a positive offset relative
to the previous palette entry in the same plane. V delta values give
a signed offset relative to the U palette entries.
{:.alert .alert-info }

**palette_delta_sign_bit_v**, if equal to 1, indicates that the decoded V chroma palette
delta value should be negated.


### Palette tokens semantics ### {#palette_tokens_semantics}

**color_index_map_y** holds the index in palette_colors_y for the block's
Y plane top left sample.

**color_index_map_uv** holds the index in palette_colors_u and palette_colors_v
for the block's UV plane top left sample.

**palette_color_idx_y** holds the index in ColorOrder for a sample in the block's
Y plane.

**palette_color_idx_uv** holds the index in ColorOrder for a sample in the
block's UV plane.


### Palette color context semantics ### {#palette_color_context_semantics}

**ColorOrder** is an array holding the mapping from an encoded index to the
palette. ColorOrder is ranked in order of frequency of occurrence of each color
in the neighborhood of the current block, weighted by closeness to the current
block.

**ColorContextHash** is a variable derived from the distribution of colors in
the neighborhood of the current block, which is used to determine the
probability context used to decode palette_color_idx_y and palette_color_idx_uv.


### Read CDEF semantics ### {#read_cdef_semantics}

**cdef_idx** specifies which CDEF filtering parameters should be used for a
particular 64 by 64 block.  A value of -1 means that CDEF is disabled for
that block.

### Read loop restoration unit semantics ### {#read_loop_restoration_unit_semantics}

**use_wiener** specifies if the Wiener filter should be used.

**use_sgrproj** specifies if the self guided filter should be used.

**restoration_type** specifies the restoration filter that should be used with the same interpretation as FrameRestorationType.

**lr_sgr_set** specifies which set of parameters to use for the self guided filter.

**subexp_more_bools** equal to 0 specifies that the parameter is in the range mk
to mk+a-1.  subexp_more_bools equal to 1 specifies that the parameter is greater
than mk+a-1.

**subexp_unif_bools** specifies the value of the parameter minus mk.

**subexp_bools** specifies the value of the parameter minus mk.

## Tile list OBU semantics ## {#tile_list_obu_semantics}

### General tile list OBU semantics ### {#general_tile_list_obu_semantics}

**output_frame_width_in_tiles_minus_1** plus one is the width of the output frame, in tile units.

**output_frame_height_in_tiles_minus_1** plus one is the height of the output frame, in tile units.

**tile_count_minus_1** plus one is the number of tile_list_entry in the list.

It is a requirement of bitstream conformance that tile_count_minus_1 is less than or equal to 511.

### Tile list entry semantics ### {#tile_list_entry_semantics}

**anchor_frame_idx** is the index into an array AnchorFrames of the frames that the tile uses for prediction.
The AnchorFrames array is provided by external means and may change for each tile list OBU.
The process for creating the AnchorFrames array is outside of the scope of this specification.

It is a requirement of bitstream conformance that anchor_frame_idx is less than or equal to 127.

**anchor_tile_row** is the row coordinate of the tile in the frame that it belongs, in tile units.

It is a requirement of bitstream conformance that anchor_tile_row is less than TileRows.

**anchor_tile_col** is the column coordinate of the tile in the frame that it belongs, in tile units.

It is a requirement of bitstream conformance that anchor_tile_col is less than TileCols.

**tile_data_size_minus_1** plus one is the size of the coded tile data, coded_tile_data, in bytes.

**coded_tile_data** are the tile_data_size_minus_1 + 1 bytes of the coded tile.
